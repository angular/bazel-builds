/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
import * as fs from 'fs';
import * as path from 'path';
import fastGlob from 'fast-glob';
import { analyzeFileAndEnsureNoCrossImports } from './cross_entry_points_imports';
/**
 * List of known `package.json` fields which provide information about
 * supported package formats and their associated entry paths.
 */
const knownFormatPackageJsonFormatFields = ['main', 'typings', 'module'];
// Main entry-point.
main(process.argv.slice(2));
function main(args) {
    // This utility expects all of its arguments to be specified in a params file generated by
    // bazel (see https://docs.bazel.build/versions/master/skylark/lib/Args.html#use_param_file).
    const paramFilePath = args[0];
    // Bazel params may be surrounded with quotes
    function unquoteParameter(s) {
        return s.replace(/^'(.*)'$/, '$1');
    }
    // Parameters are specified in the file one per line.
    const params = fs.readFileSync(paramFilePath, 'utf-8').split('\n').map(unquoteParameter);
    const [
    // Output directory for the npm package.
    outputDirExecPath, 
    // The package segment of the ng_package rule's label (e.g. 'package/common').
    owningPackageName, 
    // JSON data capturing metadata of the package being built. See `PackageMetadata`.
    metadataArg, 
    // Path to the package's README.md.
    readmeMd, 
    // Path to the package's LICENSE file.
    licenseFile, 
    // List of individual ES2022 modules
    esm2022Arg, 
    // List of static files that should be copied into the package.
    staticFilesArg, 
    // List of all type definitions that need to packaged into the ng_package.
    typeDefinitionsArg, 
    // List of side-effectful entry-points
    sideEffectEntryPointsArg,] = params;
    const esm2022 = JSON.parse(esm2022Arg);
    const typeDefinitions = JSON.parse(typeDefinitionsArg);
    const staticFiles = JSON.parse(staticFilesArg);
    const metadata = JSON.parse(metadataArg);
    const sideEffectEntryPoints = JSON.parse(sideEffectEntryPointsArg);
    if (readmeMd) {
        copyFile(readmeMd, 'README.md');
    }
    if (licenseFile) {
        copyFile(licenseFile, 'LICENSE');
    }
    /**
     * Writes a file with the specified content into the package output.
     * @param outputRelativePath Relative path in the output directory where the
     *   file is written to.
     * @param fileContent Content of the file.
     */
    function writeFile(outputRelativePath, fileContent) {
        const outputPath = path.join(outputDirExecPath, outputRelativePath);
        // Always ensure that the target directory exists.
        fs.mkdirSync(path.dirname(outputPath), { recursive: true });
        fs.writeFileSync(outputPath, fileContent);
    }
    /**
     * Copies a file into the package output to the specified location.
     * @param inputPath File that should be copied.
     * @param outputRelativePath Relative path in the output directory where the
     *   file is written to.
     */
    function copyFile(inputPath, outputRelativePath) {
        const fileContent = fs.readFileSync(inputPath, 'utf8');
        writeFile(outputRelativePath, fileContent);
    }
    /**
     * Gets the relative path for the given file within the owning package. This
     * assumes the file is contained in the owning package.
     *
     * e.g. consider the owning package is `packages/core` and the input file
     * is `packages/core/testing/index.d.ts`. This function would return the
     * relative path as followed: `testing/index.d.ts`.
     */
    function getOwningPackageRelativePath(file) {
        return path.relative(owningPackageName, file.shortPath);
    }
    /** Gets the output-relative path where the typing file is being written to. */
    function getTypingOutputRelativePath(file) {
        // Type definitions are intended to be copied into the package output while preserving the
        // sub-path from the owning package. e.g. a file like `packages/animations/browser/__index.d.ts`
        // will end up being written to `<pkg-out>/browser/index.d.ts`. Note that types are bundled
        // as a separate action in the `ng_package` Starlark rule and prefixed with `__` to avoid
        // conflicts with source `index.d.ts` files. We remove this prefix here.
        return getOwningPackageRelativePath(file).replace(/__index\.d\.ts$/, 'index.d.ts');
    }
    /**
     * Gets the entry-point sub-path from the package root. e.g. if the package name
     * is `@angular/cdk`, then for `@angular/cdk/a11y` just `a11y` would be returned.
     */
    function getEntryPointSubpath(moduleName) {
        return moduleName.slice(`${metadata.npmPackageName}/`.length);
    }
    /**
     * Gets whether the given module name resolves to a secondary entry-point.
     * e.g. if the package name is `@angular/cdk`, then for `@angular/cdk/a11y`
     * this would return `true`.
     */
    function isSecondaryEntryPoint(moduleName) {
        return getEntryPointSubpath(moduleName) !== '';
    }
    const crossEntryPointFailures = esm2022.flatMap((file) => analyzeFileAndEnsureNoCrossImports(file, metadata));
    if (crossEntryPointFailures.length) {
        console.error(crossEntryPointFailures);
        process.exit(1);
    }
    const fesmFiles = fastGlob.sync('**/*', { cwd: metadata.bundlesOut.path });
    // Copy all FESM files (and their potential shared chunks) into the package output.
    fesmFiles.forEach((f) => copyFile(path.join(metadata.bundlesOut.path, f), f));
    // Copy all type definitions into the package, preserving the sub-path from the
    // owning package. e.g. a file like `packages/animations/browser/__index.d.ts` will
    // end up in `browser/index.d.ts`
    typeDefinitions.forEach((f) => copyFile(f.path, getTypingOutputRelativePath(f)));
    for (const file of staticFiles) {
        // We copy all files into the package output while preserving the sub-path from
        // the owning package. e.g. `packages/core/package.json` ends up `<pkg-out>/package.json`.
        const outputRelativePath = getOwningPackageRelativePath(file);
        let content = fs.readFileSync(file.path, 'utf8');
        // Check and modify package.json files as necessary for publishing
        if (path.basename(file.path) === 'package.json') {
            const isPrimaryPackageJson = outputRelativePath === 'package.json';
            const packageJson = JSON.parse(content);
            const packageName = packageJson['name'];
            // Prevent non-primary `package.json` files which would throw-off resolution.
            // Resolution in the package should only be based on the top-level `package.json`.
            if (!isPrimaryPackageJson) {
                throw Error(`Found a nested "package.json" file in the package output: ${file.shortPath}.\n` +
                    `All information of the package should reside in the primary package file.`);
            }
            // Check if the `name` field of the `package.json` files are matching with
            // name of the NPM package. This is an additional safety check.
            if (packageName !== metadata.npmPackageName) {
                throw Error(`Primary "package.json" has mismatching package name. Expected the ` +
                    `package to be named "${metadata.npmPackageName}", but is set to: ${packageName}.`);
            }
            let newPackageJson = insertFormatFieldsIntoPackageJson(outputRelativePath, packageJson, false);
            newPackageJson = updatePrimaryPackageJson(newPackageJson);
            // Update the content with the new `package.json` file content.
            content = JSON.stringify(newPackageJson, null, 2);
        }
        writeFile(outputRelativePath, content);
    }
    /**
     * Inserts or edits properties into the package.json file(s) in the package so that
     * they point to all the right generated artifacts.
     *
     * @param packageJsonOutRelativePath Path where the `package.json` is stored in
     *   the package output.
     * @param parsedPackage Parsed package.json content
     * @param isGeneratedPackageJson Whether the passed package.json has been generated.
     */
    function insertFormatFieldsIntoPackageJson(packageJsonOutRelativePath, parsedPackage, isGeneratedPackageJson) {
        const packageJson = { ...parsedPackage };
        const packageName = packageJson['name'];
        const entryPointInfo = metadata.entryPoints[packageName];
        const packageJsonContainingDir = path.dirname(packageJsonOutRelativePath);
        // If a package json file has been discovered that does not match any
        // entry-point in the metadata, we report a warning as most likely the target
        // is configured incorrectly (e.g. missing `module_name` attribute).
        if (!entryPointInfo) {
            // Ideally we should throw here, as we got an entry point that doesn't
            // have flat module metadata / bundle index, so it may have been an
            // ng_module that's missing a module_name attribute.
            // However, @angular/compiler can't be an ng_module, as it's the internals
            // of the ngc compiler, yet we want to build an ng_package for it.
            // So ignore package.json files when we are missing data.
            console.error('WARNING: no module metadata for package', packageName);
            console.error('   Not updating the package.json file to point to it');
            console.error('   The ng_module for this package is possibly missing the module_name attribute ');
            return packageJson;
        }
        // If we guessed the index paths for a module, and it contains an explicit `package.json`
        // file that already sets format properties, we skip automatic insertion of format
        // properties but report a warning in case properties have been set by accident.
        if (entryPointInfo.guessedPaths &&
            !isGeneratedPackageJson &&
            hasExplicitFormatProperties(packageJson)) {
            console.error('WARNING: `package.json` explicitly sets format properties (like `main`).');
            console.error('    Skipping automatic insertion of format properties as explicit ' +
                'format properties are set.');
            console.error('    Ignore this warning if explicit properties are set intentionally.');
            return packageJson;
        }
        const fesm2022RelativeOutPath = entryPointInfo.fesm2022RelativePath;
        const typingsRelativeOutPath = getTypingOutputRelativePath(entryPointInfo.typings);
        packageJson.module = normalizePath(path.relative(packageJsonContainingDir, fesm2022RelativeOutPath));
        packageJson.typings = normalizePath(path.relative(packageJsonContainingDir, typingsRelativeOutPath));
        return packageJson;
    }
    /**
     * Updates the primary `package.json` file of the NPM package to specify
     * the module conditional exports and the ESM module type.
     */
    function updatePrimaryPackageJson(packageJson) {
        if (packageJson.type !== undefined && packageJson.type !== 'module') {
            throw Error('The primary "package.json" file of the package sets the "type" field ' +
                'that is controlled by the packager. Please unset it or set `type` to `module`.');
        }
        const newPackageJson = { ...packageJson };
        newPackageJson.type = 'module';
        // The `package.json` file is made publicly accessible for tools that
        // might want to query information from the Angular NPM package.
        insertExportMappingOrError(newPackageJson, './package.json', { default: './package.json' });
        // Capture all entry-points in the `exports` field using the subpath export declarations:
        // https://nodejs.org/api/packages.html#packages_subpath_exports.
        for (const [moduleName, entryPoint] of Object.entries(metadata.entryPoints)) {
            const subpath = isSecondaryEntryPoint(moduleName)
                ? `./${getEntryPointSubpath(moduleName)}`
                : '.';
            const fesm2022OutRelativePath = entryPoint.fesm2022RelativePath;
            const typesOutRelativePath = getTypingOutputRelativePath(entryPoint.typings);
            // Insert the export mapping for the entry-point. We set `default` to the FESM 2022
            // output, and also set the `types` condition which will be respected by TS 4.5.
            // https://github.com/microsoft/TypeScript/pull/45884.
            insertExportMappingOrError(newPackageJson, subpath, {
                types: normalizePath(typesOutRelativePath),
                // Note: The default conditions needs to be the last one.
                default: normalizePath(fesm2022OutRelativePath),
            });
        }
        checkPackageJsonSideEffects(packageJson);
        return newPackageJson;
    }
    function checkPackageJsonSideEffects(packageJson) {
        // Convenience if there are no side effects, and it's explicitly marked.
        // This is okay and we don't ask the developer to drop the explicit field.
        if (packageJson.sideEffects === false && sideEffectEntryPoints.length === 0) {
            return;
        }
        if (packageJson.sideEffects === true) {
            throw Error('Unexpected `sideEffects` field in `package.json`. ' +
                'Side effects should be fine-grained and marked via the Bazel `side_effect_entry_points` option.');
        }
        const sideEffects = packageJson.sideEffects;
        const neededSideEffects = sideEffectEntryPoints.map((entryPointModule) => `./${metadata.entryPoints[entryPointModule].fesm2022RelativePath}`);
        const missingSideEffects = neededSideEffects.filter((p) => 
        // It's missing, if the whole package is marked as having no side effects.
        sideEffects === false ||
            // Alternatively, it's missing if the explicit list doesn't contain the pattern.
            !(sideEffects ?? []).includes(p));
        if (missingSideEffects.length > 0) {
            throw Error('Missing side effects in `package.json` `sideEffects` field. ' +
                'Please add the following side effect file patterns:\n' +
                missingSideEffects.join('\n - '));
        }
        // Find potential side-effects that refer to our FESM bundles, but aren't part
        // of the `ng_package` known entry points.
        const unexpectedExtra = sideEffects !== false
            ? (sideEffects ?? []).filter((p) => p.includes('fesm2022') && !neededSideEffects.includes(p))
            : [];
        if (unexpectedExtra.length > 0) {
            throw Error('Unexpected side effects in `package.json` `sideEffects` field that is not known to `ng_package`. ' +
                'Please add the side effect entry point to the Bazel `side_effect_entry_points` option. ' +
                'Unexpected patterns:\n' +
                unexpectedExtra.join('\n - '));
        }
    }
    /**
     * Inserts a subpath export mapping into the specified `package.json` object.
     * @throws An error if the mapping is already defined and would conflict.
     */
    function insertExportMappingOrError(packageJson, subpath, mapping) {
        if (packageJson.exports === undefined) {
            packageJson.exports = {};
        }
        if (packageJson.exports[subpath] === undefined) {
            packageJson.exports[subpath] = {};
        }
        const subpathExport = packageJson.exports[subpath];
        // Go through all conditions that should be inserted. If the condition is already
        // manually set of the subpath export, we throw an error. In general, we allow for
        // additional conditions to be set. These will always precede the generated ones.
        for (const conditionName of Object.keys(mapping)) {
            if (subpathExport[conditionName] !== undefined) {
                throw Error(`Found a conflicting export condition for "${subpath}". The "${conditionName}" ` +
                    `condition would be overridden by the packager. Please unset it.`);
            }
            // **Note**: The order of the conditions is preserved even though we are setting
            // the conditions once at a time (the latest assignment will be at the end).
            subpathExport[conditionName] = mapping[conditionName];
        }
    }
    /** Whether the package explicitly sets any of the format properties (like `main`). */
    function hasExplicitFormatProperties(parsedPackage) {
        return Object.keys(parsedPackage).some((fieldName) => knownFormatPackageJsonFormatFields.includes(fieldName));
    }
    /**
     * Normalizes the specified path by replacing backslash separators with Posix
     * forward slash separators.
     */
    function normalizePath(path) {
        const result = path.replace(/\\/g, '/');
        return result.startsWith('.') ? result : `./${result}`;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFja2FnZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9iYXplbC9zcmMvbmdfcGFja2FnZS9wYWNrYWdlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFFSCxPQUFPLEtBQUssRUFBRSxNQUFNLElBQUksQ0FBQztBQUN6QixPQUFPLEtBQUssSUFBSSxNQUFNLE1BQU0sQ0FBQztBQUM3QixPQUFPLFFBQVEsTUFBTSxXQUFXLENBQUM7QUFHakMsT0FBTyxFQUFDLGtDQUFrQyxFQUFDLE1BQU0sOEJBQThCLENBQUM7QUFFaEY7OztHQUdHO0FBQ0gsTUFBTSxrQ0FBa0MsR0FBRyxDQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUUsUUFBUSxDQUFVLENBQUM7QUF3QmxGLG9CQUFvQjtBQUNwQixJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUU1QixTQUFTLElBQUksQ0FBQyxJQUFjO0lBQzFCLDBGQUEwRjtJQUMxRiw2RkFBNkY7SUFDN0YsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRTlCLDZDQUE2QztJQUM3QyxTQUFTLGdCQUFnQixDQUFDLENBQVM7UUFDakMsT0FBTyxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQscURBQXFEO0lBQ3JELE1BQU0sTUFBTSxHQUFHLEVBQUUsQ0FBQyxZQUFZLENBQUMsYUFBYSxFQUFFLE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztJQUV6RixNQUFNO0lBQ0osd0NBQXdDO0lBQ3hDLGlCQUFpQjtJQUVqQiw4RUFBOEU7SUFDOUUsaUJBQWlCO0lBRWpCLGtGQUFrRjtJQUNsRixXQUFXO0lBRVgsbUNBQW1D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LENBQUM7WUFFRCxnRkFBZ0Y7WUFDaEYsNEVBQTRFO1lBQzVFLGFBQWEsQ0FBQyxhQUFhLENBQUMsR0FBRyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDeEQsQ0FBQztJQUNILENBQUM7SUFFRCxzRkFBc0Y7SUFDdEYsU0FBUywyQkFBMkIsQ0FBQyxhQUFvQztRQUN2RSxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsU0FBaUIsRUFBRSxFQUFFLENBQzNELGtDQUFrQyxDQUFDLFFBQVEsQ0FBQyxTQUF5QyxDQUFDLENBQ3ZGLENBQUM7SUFDSixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsU0FBUyxhQUFhLENBQUMsSUFBWTtRQUNqQyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztRQUN4QyxPQUFPLE1BQU0sQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxNQUFNLEVBQUUsQ0FBQztJQUN6RCxDQUFDO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmRldi9saWNlbnNlXG4gKi9cblxuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCBmYXN0R2xvYiBmcm9tICdmYXN0LWdsb2InO1xuXG5pbXBvcnQge0JhemVsRmlsZUluZm8sIFBhY2thZ2VNZXRhZGF0YX0gZnJvbSAnLi9hcGknO1xuaW1wb3J0IHthbmFseXplRmlsZUFuZEVuc3VyZU5vQ3Jvc3NJbXBvcnRzfSBmcm9tICcuL2Nyb3NzX2VudHJ5X3BvaW50c19pbXBvcnRzJztcblxuLyoqXG4gKiBMaXN0IG9mIGtub3duIGBwYWNrYWdlLmpzb25gIGZpZWxkcyB3aGljaCBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0XG4gKiBzdXBwb3J0ZWQgcGFja2FnZSBmb3JtYXRzIGFuZCB0aGVpciBhc3NvY2lhdGVkIGVudHJ5IHBhdGhzLlxuICovXG5jb25zdCBrbm93bkZvcm1hdFBhY2thZ2VKc29uRm9ybWF0RmllbGRzID0gWydtYWluJywgJ3R5cGluZ3MnLCAnbW9kdWxlJ10gYXMgY29uc3Q7XG5cbi8qKiBVbmlvbiB0eXBlIG1hdGNoaW5nIGtub3duIGBwYWNrYWdlLmpzb25gIGZvcm1hdCBmaWVsZHMuICovXG50eXBlIEtub3duUGFja2FnZUpzb25Gb3JtYXRGaWVsZHMgPSAodHlwZW9mIGtub3duRm9ybWF0UGFja2FnZUpzb25Gb3JtYXRGaWVsZHMpW251bWJlcl07XG5cbi8qKlxuICogVHlwZSBkZXNjcmliaW5nIHRoZSBjb25kaXRpb25hbCBleHBvcnRzIGRlc2NyaXB0b3IgZm9yIGFuIGVudHJ5LXBvaW50LlxuICogaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9wYWNrYWdlcy5odG1sI3BhY2thZ2VzX2NvbmRpdGlvbmFsX2V4cG9ydHNcbiAqL1xudHlwZSBDb25kaXRpb25hbEV4cG9ydCA9IHtcbiAgdHlwZXM/OiBzdHJpbmc7XG4gIGRlZmF1bHQ/OiBzdHJpbmc7XG59O1xuXG4vKiogVHlwZSBkZXNjcmliaW5nIGEgYHBhY2thZ2UuanNvbmAgdGhlIHBhY2thZ2VyIGRlYWxzIHdpdGguICovXG50eXBlIFBhY2thZ2VKc29uID0ge1xuICBba2V5IGluIEtub3duUGFja2FnZUpzb25Gb3JtYXRGaWVsZHNdPzogc3RyaW5nO1xufSAmIHtcbiAgbmFtZTogc3RyaW5nO1xuICB0eXBlPzogc3RyaW5nO1xuICBzaWRlRWZmZWN0cz86IHN0cmluZ1tdIHwgYm9vbGVhbjtcbiAgZXhwb3J0cz86IFJlY29yZDxzdHJpbmcsIENvbmRpdGlvbmFsRXhwb3J0Pjtcbn07XG5cbi8vIE1haW4gZW50cnktcG9pbnQuXG5tYWluKHByb2Nlc3MuYXJndi5zbGljZSgyKSk7XG5cbmZ1bmN0aW9uIG1haW4oYXJnczogc3RyaW5nW10pOiB2b2lkIHtcbiAgLy8gVGhpcyB1dGlsaXR5IGV4cGVjdHMgYWxsIG9mIGl0cyBhcmd1bWVudHMgdG8gYmUgc3BlY2lmaWVkIGluIGEgcGFyYW1zIGZpbGUgZ2VuZXJhdGVkIGJ5XG4gIC8vIGJhemVsIChzZWUgaHR0cHM6Ly9kb2NzLmJhemVsLmJ1aWxkL3ZlcnNpb25zL21hc3Rlci9za3lsYXJrL2xpYi9BcmdzLmh0bWwjdXNlX3BhcmFtX2ZpbGUpLlxuICBjb25zdCBwYXJhbUZpbGVQYXRoID0gYXJnc1swXTtcblxuICAvLyBCYXplbCBwYXJhbXMgbWF5IGJlIHN1cnJvdW5kZWQgd2l0aCBxdW90ZXNcbiAgZnVuY3Rpb24gdW5xdW90ZVBhcmFtZXRlcihzOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKC9eJyguKiknJC8sICckMScpO1xuICB9XG5cbiAgLy8gUGFyYW1ldGVycyBhcmUgc3BlY2lmaWVkIGluIHRoZSBmaWxlIG9uZSBwZXIgbGluZS5cbiAgY29uc3QgcGFyYW1zID0gZnMucmVhZEZpbGVTeW5jKHBhcmFtRmlsZVBhdGgsICd1dGYtOCcpLnNwbGl0KCdcXG4nKS5tYXAodW5xdW90ZVBhcmFtZXRlcik7XG5cbiAgY29uc3QgW1xuICAgIC8vIE91dHB1dCBkaXJlY3RvcnkgZm9yIHRoZSBucG0gcGFja2FnZS5cbiAgICBvdXRwdXREaXJFeGVjUGF0aCxcblxuICAgIC8vIFRoZSBwYWNrYWdlIHNlZ21lbnQgb2YgdGhlIG5nX3BhY2thZ2UgcnVsZSdzIGxhYmVsIChlLmcuICdwYWNrYWdlL2NvbW1vbicpLlxuICAgIG93bmluZ1BhY2thZ2VOYW1lLFxuXG4gICAgLy8gSlNPTiBkYXRhIGNhcHR1cmluZyBtZXRhZGF0YSBvZiB0aGUgcGFja2FnZSBiZWluZyBidWlsdC4gU2VlIGBQYWNrYWdlTWV0YWRhdGFgLlxuICAgIG1ldGFkYXRhQXJnLFxuXG4gICAgLy8gUGF0aCB0byB0aGUgcGFja2FnZSdzIFJFQURNRS5tZC5cbiAgICByZWFkbWVNZCxcblxuICAgIC8vIFBhdGggdG8gdGhlIHBhY2thZ2UncyBMSUNFTlNFIGZpbGUuXG4gICAgbGljZW5zZUZpbGUsXG5cbiAgICAvLyBMaXN0IG9mIGluZGl2aWR1YWwgRVMyMDIyIG1vZHVsZXNcbiAgICBlc20yMDIyQXJnLFxuXG4gICAgLy8gTGlzdCBvZiBzdGF0aWMgZmlsZXMgdGhhdCBzaG91bGQgYmUgY29waWVkIGludG8gdGhlIHBhY2thZ2UuXG4gICAgc3RhdGljRmlsZXNBcmcsXG5cbiAgICAvLyBMaXN0IG9mIGFsbCB0eXBlIGRlZmluaXRpb25zIHRoYXQgbmVlZCB0byBwYWNrYWdlZCBpbnRvIHRoZSBuZ19wYWNrYWdlLlxuICAgIHR5cGVEZWZpbml0aW9uc0FyZyxcblxuICAgIC8vIExpc3Qgb2Ygc2lkZS1lZmZlY3RmdWwgZW50cnktcG9pbnRzXG4gICAgc2lkZUVmZmVjdEVudHJ5UG9pbnRzQXJnLFxuICBdID0gcGFyYW1zO1xuXG4gIGNvbnN0IGVzbTIwMjIgPSBKU09OLnBhcnNlKGVzbTIwMjJBcmcpIGFzIEJhemVsRmlsZUluZm9bXTtcbiAgY29uc3QgdHlwZURlZmluaXRpb25zID0gSlNPTi5wYXJzZSh0eXBlRGVmaW5pdGlvbnNBcmcpIGFzIEJhemVsRmlsZUluZm9bXTtcbiAgY29uc3Qgc3RhdGljRmlsZXMgPSBKU09OLnBhcnNlKHN0YXRpY0ZpbGVzQXJnKSBhcyBCYXplbEZpbGVJbmZvW107XG4gIGNvbnN0IG1ldGFkYXRhID0gSlNPTi5wYXJzZShtZXRhZGF0YUFyZykgYXMgUGFja2FnZU1ldGFkYXRhO1xuICBjb25zdCBzaWRlRWZmZWN0RW50cnlQb2ludHMgPSBKU09OLnBhcnNlKHNpZGVFZmZlY3RFbnRyeVBvaW50c0FyZykgYXMgc3RyaW5nW107XG5cbiAgaWYgKHJlYWRtZU1kKSB7XG4gICAgY29weUZpbGUocmVhZG1lTWQsICdSRUFETUUubWQnKTtcbiAgfVxuXG4gIGlmIChsaWNlbnNlRmlsZSkge1xuICAgIGNvcHlGaWxlKGxpY2Vuc2VGaWxlLCAnTElDRU5TRScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlcyBhIGZpbGUgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbnRlbnQgaW50byB0aGUgcGFja2FnZSBvdXRwdXQuXG4gICAqIEBwYXJhbSBvdXRwdXRSZWxhdGl2ZVBhdGggUmVsYXRpdmUgcGF0aCBpbiB0aGUgb3V0cHV0IGRpcmVjdG9yeSB3aGVyZSB0aGVcbiAgICogICBmaWxlIGlzIHdyaXR0ZW4gdG8uXG4gICAqIEBwYXJhbSBmaWxlQ29udGVudCBDb250ZW50IG9mIHRoZSBmaWxlLlxuICAgKi9cbiAgZnVuY3Rpb24gd3JpdGVGaWxlKG91dHB1dFJlbGF0aXZlUGF0aDogc3RyaW5nLCBmaWxlQ29udGVudDogc3RyaW5nIHwgQnVmZmVyKSB7XG4gICAgY29uc3Qgb3V0cHV0UGF0aCA9IHBhdGguam9pbihvdXRwdXREaXJFeGVjUGF0aCwgb3V0cHV0UmVsYXRpdmVQYXRoKTtcblxuICAgIC8vIEFsd2F5cyBlbnN1cmUgdGhhdCB0aGUgdGFyZ2V0IGRpcmVjdG9yeSBleGlzdHMuXG4gICAgZnMubWtkaXJTeW5jKHBhdGguZGlybmFtZShvdXRwdXRQYXRoKSwge3JlY3Vyc2l2ZTogdHJ1ZX0pO1xuICAgIGZzLndyaXRlRmlsZVN5bmMob3V0cHV0UGF0aCwgZmlsZUNvbnRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvcGllcyBhIGZpbGUgaW50byB0aGUgcGFja2FnZSBvdXRwdXQgdG8gdGhlIHNwZWNpZmllZCBsb2NhdGlvbi5cbiAgICogQHBhcmFtIGlucHV0UGF0aCBGaWxlIHRoYXQgc2hvdWxkIGJlIGNvcGllZC5cbiAgICogQHBhcmFtIG91dHB1dFJlbGF0aXZlUGF0aCBSZWxhdGl2ZSBwYXRoIGluIHRoZSBvdXRwdXQgZGlyZWN0b3J5IHdoZXJlIHRoZVxuICAgKiAgIGZpbGUgaXMgd3JpdHRlbiB0by5cbiAgICovXG4gIGZ1bmN0aW9uIGNvcHlGaWxlKGlucHV0UGF0aDogc3RyaW5nLCBvdXRwdXRSZWxhdGl2ZVBhdGg6IHN0cmluZykge1xuICAgIGNvbnN0IGZpbGVDb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKGlucHV0UGF0aCwgJ3V0ZjgnKTtcbiAgICB3cml0ZUZpbGUob3V0cHV0UmVsYXRpdmVQYXRoLCBmaWxlQ29udGVudCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgcmVsYXRpdmUgcGF0aCBmb3IgdGhlIGdpdmVuIGZpbGUgd2l0aGluIHRoZSBvd25pbmcgcGFja2FnZS4gVGhpc1xuICAgKiBhc3N1bWVzIHRoZSBmaWxlIGlzIGNvbnRhaW5lZCBpbiB0aGUgb3duaW5nIHBhY2thZ2UuXG4gICAqXG4gICAqIGUuZy4gY29uc2lkZXIgdGhlIG93bmluZyBwYWNrYWdlIGlzIGBwYWNrYWdlcy9jb3JlYCBhbmQgdGhlIGlucHV0IGZpbGVcbiAgICogaXMgYHBhY2thZ2VzL2NvcmUvdGVzdGluZy9pbmRleC5kLnRzYC4gVGhpcyBmdW5jdGlvbiB3b3VsZCByZXR1cm4gdGhlXG4gICAqIHJlbGF0aXZlIHBhdGggYXMgZm9sbG93ZWQ6IGB0ZXN0aW5nL2luZGV4LmQudHNgLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0T3duaW5nUGFja2FnZVJlbGF0aXZlUGF0aChmaWxlOiBCYXplbEZpbGVJbmZvKTogc3RyaW5nIHtcbiAgICByZXR1cm4gcGF0aC5yZWxhdGl2ZShvd25pbmdQYWNrYWdlTmFtZSwgZmlsZS5zaG9ydFBhdGgpO1xuICB9XG5cbiAgLyoqIEdldHMgdGhlIG91dHB1dC1yZWxhdGl2ZSBwYXRoIHdoZXJlIHRoZSB0eXBpbmcgZmlsZSBpcyBiZWluZyB3cml0dGVuIHRvLiAqL1xuICBmdW5jdGlvbiBnZXRUeXBpbmdPdXRwdXRSZWxhdGl2ZVBhdGgoZmlsZTogQmF6ZWxGaWxlSW5mbykge1xuICAgIC8vIFR5cGUgZGVmaW5pdGlvbnMgYXJlIGludGVuZGVkIHRvIGJlIGNvcGllZCBpbnRvIHRoZSBwYWNrYWdlIG91dHB1dCB3aGlsZSBwcmVzZXJ2aW5nIHRoZVxuICAgIC8vIHN1Yi1wYXRoIGZyb20gdGhlIG93bmluZyBwYWNrYWdlLiBlLmcuIGEgZmlsZSBsaWtlIGBwYWNrYWdlcy9hbmltYXRpb25zL2Jyb3dzZXIvX19pbmRleC5kLnRzYFxuICAgIC8vIHdpbGwgZW5kIHVwIGJlaW5nIHdyaXR0ZW4gdG8gYDxwa2ctb3V0Pi9icm93c2VyL2luZGV4LmQudHNgLiBOb3RlIHRoYXQgdHlwZXMgYXJlIGJ1bmRsZWRcbiAgICAvLyBhcyBhIHNlcGFyYXRlIGFjdGlvbiBpbiB0aGUgYG5nX3BhY2thZ2VgIFN0YXJsYXJrIHJ1bGUgYW5kIHByZWZpeGVkIHdpdGggYF9fYCB0byBhdm9pZFxuICAgIC8vIGNvbmZsaWN0cyB3aXRoIHNvdXJjZSBgaW5kZXguZC50c2AgZmlsZXMuIFdlIHJlbW92ZSB0aGlzIHByZWZpeCBoZXJlLlxuICAgIHJldHVybiBnZXRPd25pbmdQYWNrYWdlUmVsYXRpdmVQYXRoKGZpbGUpLnJlcGxhY2UoL19faW5kZXhcXC5kXFwudHMkLywgJ2luZGV4LmQudHMnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBlbnRyeS1wb2ludCBzdWItcGF0aCBmcm9tIHRoZSBwYWNrYWdlIHJvb3QuIGUuZy4gaWYgdGhlIHBhY2thZ2UgbmFtZVxuICAgKiBpcyBgQGFuZ3VsYXIvY2RrYCwgdGhlbiBmb3IgYEBhbmd1bGFyL2Nkay9hMTF5YCBqdXN0IGBhMTF5YCB3b3VsZCBiZSByZXR1cm5lZC5cbiAgICovXG4gIGZ1bmN0aW9uIGdldEVudHJ5UG9pbnRTdWJwYXRoKG1vZHVsZU5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIG1vZHVsZU5hbWUuc2xpY2UoYCR7bWV0YWRhdGEubnBtUGFja2FnZU5hbWV9L2AubGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHdoZXRoZXIgdGhlIGdpdmVuIG1vZHVsZSBuYW1lIHJlc29sdmVzIHRvIGEgc2Vjb25kYXJ5IGVudHJ5LXBvaW50LlxuICAgKiBlLmcuIGlmIHRoZSBwYWNrYWdlIG5hbWUgaXMgYEBhbmd1bGFyL2Nka2AsIHRoZW4gZm9yIGBAYW5ndWxhci9jZGsvYTExeWBcbiAgICogdGhpcyB3b3VsZCByZXR1cm4gYHRydWVgLlxuICAgKi9cbiAgZnVuY3Rpb24gaXNTZWNvbmRhcnlFbnRyeVBvaW50KG1vZHVsZU5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBnZXRFbnRyeVBvaW50U3VicGF0aChtb2R1bGVOYW1lKSAhPT0gJyc7XG4gIH1cblxuICBjb25zdCBjcm9zc0VudHJ5UG9pbnRGYWlsdXJlcyA9IGVzbTIwMjIuZmxhdE1hcCgoZmlsZSkgPT5cbiAgICBhbmFseXplRmlsZUFuZEVuc3VyZU5vQ3Jvc3NJbXBvcnRzKGZpbGUsIG1ldGFkYXRhKSxcbiAgKTtcblxuICBpZiAoY3Jvc3NFbnRyeVBvaW50RmFpbHVyZXMubGVuZ3RoKSB7XG4gICAgY29uc29sZS5lcnJvcihjcm9zc0VudHJ5UG9pbnRGYWlsdXJlcyk7XG4gICAgcHJvY2Vzcy5leGl0KDEpO1xuICB9XG5cbiAgY29uc3QgZmVzbUZpbGVzID0gZmFzdEdsb2Iuc3luYygnKiovKicsIHtjd2Q6IG1ldGFkYXRhLmJ1bmRsZXNPdXQucGF0aH0pO1xuICAvLyBDb3B5IGFsbCBGRVNNIGZpbGVzIChhbmQgdGhlaXIgcG90ZW50aWFsIHNoYXJlZCBjaHVua3MpIGludG8gdGhlIHBhY2thZ2Ugb3V0cHV0LlxuICBmZXNtRmlsZXMuZm9yRWFjaCgoZikgPT4gY29weUZpbGUocGF0aC5qb2luKG1ldGFkYXRhLmJ1bmRsZXNPdXQucGF0aCwgZiksIGYpKTtcblxuICAvLyBDb3B5IGFsbCB0eXBlIGRlZmluaXRpb25zIGludG8gdGhlIHBhY2thZ2UsIHByZXNlcnZpbmcgdGhlIHN1Yi1wYXRoIGZyb20gdGhlXG4gIC8vIG93bmluZyBwYWNrYWdlLiBlLmcuIGEgZmlsZSBsaWtlIGBwYWNrYWdlcy9hbmltYXRpb25zL2Jyb3dzZXIvX19pbmRleC5kLnRzYCB3aWxsXG4gIC8vIGVuZCB1cCBpbiBgYnJvd3Nlci9pbmRleC5kLnRzYFxuICB0eXBlRGVmaW5pdGlvbnMuZm9yRWFjaCgoZikgPT4gY29weUZpbGUoZi5wYXRoLCBnZXRUeXBpbmdPdXRwdXRSZWxhdGl2ZVBhdGgoZikpKTtcblxuICBmb3IgKGNvbnN0IGZpbGUgb2Ygc3RhdGljRmlsZXMpIHtcbiAgICAvLyBXZSBjb3B5IGFsbCBmaWxlcyBpbnRvIHRoZSBwYWNrYWdlIG91dHB1dCB3aGlsZSBwcmVzZXJ2aW5nIHRoZSBzdWItcGF0aCBmcm9tXG4gICAgLy8gdGhlIG93bmluZyBwYWNrYWdlLiBlLmcuIGBwYWNrYWdlcy9jb3JlL3BhY2thZ2UuanNvbmAgZW5kcyB1cCBgPHBrZy1vdXQ+L3BhY2thZ2UuanNvbmAuXG4gICAgY29uc3Qgb3V0cHV0UmVsYXRpdmVQYXRoID0gZ2V0T3duaW5nUGFja2FnZVJlbGF0aXZlUGF0aChmaWxlKTtcbiAgICBsZXQgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhmaWxlLnBhdGgsICd1dGY4Jyk7XG5cbiAgICAvLyBDaGVjayBhbmQgbW9kaWZ5IHBhY2thZ2UuanNvbiBmaWxlcyBhcyBuZWNlc3NhcnkgZm9yIHB1Ymxpc2hpbmdcbiAgICBpZiAocGF0aC5iYXNlbmFtZShmaWxlLnBhdGgpID09PSAncGFja2FnZS5qc29uJykge1xuICAgICAgY29uc3QgaXNQcmltYXJ5UGFja2FnZUpzb24gPSBvdXRwdXRSZWxhdGl2ZVBhdGggPT09ICdwYWNrYWdlLmpzb24nO1xuICAgICAgY29uc3QgcGFja2FnZUpzb24gPSBKU09OLnBhcnNlKGNvbnRlbnQpIGFzIFBhY2thZ2VKc29uO1xuICAgICAgY29uc3QgcGFja2FnZU5hbWUgPSBwYWNrYWdlSnNvblsnbmFtZSddO1xuXG4gICAgICAvLyBQcmV2ZW50IG5vbi1wcmltYXJ5IGBwYWNrYWdlLmpzb25gIGZpbGVzIHdoaWNoIHdvdWxkIHRocm93LW9mZiByZXNvbHV0aW9uLlxuICAgICAgLy8gUmVzb2x1dGlvbiBpbiB0aGUgcGFja2FnZSBzaG91bGQgb25seSBiZSBiYXNlZCBvbiB0aGUgdG9wLWxldmVsIGBwYWNrYWdlLmpzb25gLlxuICAgICAgaWYgKCFpc1ByaW1hcnlQYWNrYWdlSnNvbikge1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBgRm91bmQgYSBuZXN0ZWQgXCJwYWNrYWdlLmpzb25cIiBmaWxlIGluIHRoZSBwYWNrYWdlIG91dHB1dDogJHtmaWxlLnNob3J0UGF0aH0uXFxuYCArXG4gICAgICAgICAgICBgQWxsIGluZm9ybWF0aW9uIG9mIHRoZSBwYWNrYWdlIHNob3VsZCByZXNpZGUgaW4gdGhlIHByaW1hcnkgcGFja2FnZSBmaWxlLmAsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBgbmFtZWAgZmllbGQgb2YgdGhlIGBwYWNrYWdlLmpzb25gIGZpbGVzIGFyZSBtYXRjaGluZyB3aXRoXG4gICAgICAvLyBuYW1lIG9mIHRoZSBOUE0gcGFja2FnZS4gVGhpcyBpcyBhbiBhZGRpdGlvbmFsIHNhZmV0eSBjaGVjay5cbiAgICAgIGlmIChwYWNrYWdlTmFtZSAhPT0gbWV0YWRhdGEubnBtUGFja2FnZU5hbWUpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgYFByaW1hcnkgXCJwYWNrYWdlLmpzb25cIiBoYXMgbWlzbWF0Y2hpbmcgcGFja2FnZSBuYW1lLiBFeHBlY3RlZCB0aGUgYCArXG4gICAgICAgICAgICBgcGFja2FnZSB0byBiZSBuYW1lZCBcIiR7bWV0YWRhdGEubnBtUGFja2FnZU5hbWV9XCIsIGJ1dCBpcyBzZXQgdG86ICR7cGFja2FnZU5hbWV9LmAsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGxldCBuZXdQYWNrYWdlSnNvbiA9IGluc2VydEZvcm1hdEZpZWxkc0ludG9QYWNrYWdlSnNvbihcbiAgICAgICAgb3V0cHV0UmVsYXRpdmVQYXRoLFxuICAgICAgICBwYWNrYWdlSnNvbixcbiAgICAgICAgZmFsc2UsXG4gICAgICApO1xuXG4gICAgICBuZXdQYWNrYWdlSnNvbiA9IHVwZGF0ZVByaW1hcnlQYWNrYWdlSnNvbihuZXdQYWNrYWdlSnNvbik7XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgY29udGVudCB3aXRoIHRoZSBuZXcgYHBhY2thZ2UuanNvbmAgZmlsZSBjb250ZW50LlxuICAgICAgY29udGVudCA9IEpTT04uc3RyaW5naWZ5KG5ld1BhY2thZ2VKc29uLCBudWxsLCAyKTtcbiAgICB9XG5cbiAgICB3cml0ZUZpbGUob3V0cHV0UmVsYXRpdmVQYXRoLCBjb250ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIG9yIGVkaXRzIHByb3BlcnRpZXMgaW50byB0aGUgcGFja2FnZS5qc29uIGZpbGUocykgaW4gdGhlIHBhY2thZ2Ugc28gdGhhdFxuICAgKiB0aGV5IHBvaW50IHRvIGFsbCB0aGUgcmlnaHQgZ2VuZXJhdGVkIGFydGlmYWN0cy5cbiAgICpcbiAgICogQHBhcmFtIHBhY2thZ2VKc29uT3V0UmVsYXRpdmVQYXRoIFBhdGggd2hlcmUgdGhlIGBwYWNrYWdlLmpzb25gIGlzIHN0b3JlZCBpblxuICAgKiAgIHRoZSBwYWNrYWdlIG91dHB1dC5cbiAgICogQHBhcmFtIHBhcnNlZFBhY2thZ2UgUGFyc2VkIHBhY2thZ2UuanNvbiBjb250ZW50XG4gICAqIEBwYXJhbSBpc0dlbmVyYXRlZFBhY2thZ2VKc29uIFdoZXRoZXIgdGhlIHBhc3NlZCBwYWNrYWdlLmpzb24gaGFzIGJlZW4gZ2VuZXJhdGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gaW5zZXJ0Rm9ybWF0RmllbGRzSW50b1BhY2thZ2VKc29uKFxuICAgIHBhY2thZ2VKc29uT3V0UmVsYXRpdmVQYXRoOiBzdHJpbmcsXG4gICAgcGFyc2VkUGFja2FnZTogUmVhZG9ubHk8UGFja2FnZUpzb24+LFxuICAgIGlzR2VuZXJhdGVkUGFja2FnZUpzb246IGJvb2xlYW4sXG4gICk6IFBhY2thZ2VKc29uIHtcbiAgICBjb25zdCBwYWNrYWdlSnNvbjogUGFja2FnZUpzb24gPSB7Li4ucGFyc2VkUGFja2FnZX07XG4gICAgY29uc3QgcGFja2FnZU5hbWUgPSBwYWNrYWdlSnNvblsnbmFtZSddO1xuICAgIGNvbnN0IGVudHJ5UG9pbnRJbmZvID0gbWV0YWRhdGEuZW50cnlQb2ludHNbcGFja2FnZU5hbWVdO1xuICAgIGNvbnN0IHBhY2thZ2VKc29uQ29udGFpbmluZ0RpciA9IHBhdGguZGlybmFtZShwYWNrYWdlSnNvbk91dFJlbGF0aXZlUGF0aCk7XG5cbiAgICAvLyBJZiBhIHBhY2thZ2UganNvbiBmaWxlIGhhcyBiZWVuIGRpc2NvdmVyZWQgdGhhdCBkb2VzIG5vdCBtYXRjaCBhbnlcbiAgICAvLyBlbnRyeS1wb2ludCBpbiB0aGUgbWV0YWRhdGEsIHdlIHJlcG9ydCBhIHdhcm5pbmcgYXMgbW9zdCBsaWtlbHkgdGhlIHRhcmdldFxuICAgIC8vIGlzIGNvbmZpZ3VyZWQgaW5jb3JyZWN0bHkgKGUuZy4gbWlzc2luZyBgbW9kdWxlX25hbWVgIGF0dHJpYnV0ZSkuXG4gICAgaWYgKCFlbnRyeVBvaW50SW5mbykge1xuICAgICAgLy8gSWRlYWxseSB3ZSBzaG91bGQgdGhyb3cgaGVyZSwgYXMgd2UgZ290IGFuIGVudHJ5IHBvaW50IHRoYXQgZG9lc24ndFxuICAgICAgLy8gaGF2ZSBmbGF0IG1vZHVsZSBtZXRhZGF0YSAvIGJ1bmRsZSBpbmRleCwgc28gaXQgbWF5IGhhdmUgYmVlbiBhblxuICAgICAgLy8gbmdfbW9kdWxlIHRoYXQncyBtaXNzaW5nIGEgbW9kdWxlX25hbWUgYXR0cmlidXRlLlxuICAgICAgLy8gSG93ZXZlciwgQGFuZ3VsYXIvY29tcGlsZXIgY2FuJ3QgYmUgYW4gbmdfbW9kdWxlLCBhcyBpdCdzIHRoZSBpbnRlcm5hbHNcbiAgICAgIC8vIG9mIHRoZSBuZ2MgY29tcGlsZXIsIHlldCB3ZSB3YW50IHRvIGJ1aWxkIGFuIG5nX3BhY2thZ2UgZm9yIGl0LlxuICAgICAgLy8gU28gaWdub3JlIHBhY2thZ2UuanNvbiBmaWxlcyB3aGVuIHdlIGFyZSBtaXNzaW5nIGRhdGEuXG4gICAgICBjb25zb2xlLmVycm9yKCdXQVJOSU5HOiBubyBtb2R1bGUgbWV0YWRhdGEgZm9yIHBhY2thZ2UnLCBwYWNrYWdlTmFtZSk7XG4gICAgICBjb25zb2xlLmVycm9yKCcgICBOb3QgdXBkYXRpbmcgdGhlIHBhY2thZ2UuanNvbiBmaWxlIHRvIHBvaW50IHRvIGl0Jyk7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAnICAgVGhlIG5nX21vZHVsZSBmb3IgdGhpcyBwYWNrYWdlIGlzIHBvc3NpYmx5IG1pc3NpbmcgdGhlIG1vZHVsZV9uYW1lIGF0dHJpYnV0ZSAnLFxuICAgICAgKTtcbiAgICAgIHJldHVybiBwYWNrYWdlSnNvbjtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBndWVzc2VkIHRoZSBpbmRleCBwYXRocyBmb3IgYSBtb2R1bGUsIGFuZCBpdCBjb250YWlucyBhbiBleHBsaWNpdCBgcGFja2FnZS5qc29uYFxuICAgIC8vIGZpbGUgdGhhdCBhbHJlYWR5IHNldHMgZm9ybWF0IHByb3BlcnRpZXMsIHdlIHNraXAgYXV0b21hdGljIGluc2VydGlvbiBvZiBmb3JtYXRcbiAgICAvLyBwcm9wZXJ0aWVzIGJ1dCByZXBvcnQgYSB3YXJuaW5nIGluIGNhc2UgcHJvcGVydGllcyBoYXZlIGJlZW4gc2V0IGJ5IGFjY2lkZW50LlxuICAgIGlmIChcbiAgICAgIGVudHJ5UG9pbnRJbmZvLmd1ZXNzZWRQYXRocyAmJlxuICAgICAgIWlzR2VuZXJhdGVkUGFja2FnZUpzb24gJiZcbiAgICAgIGhhc0V4cGxpY2l0Rm9ybWF0UHJvcGVydGllcyhwYWNrYWdlSnNvbilcbiAgICApIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1dBUk5JTkc6IGBwYWNrYWdlLmpzb25gIGV4cGxpY2l0bHkgc2V0cyBmb3JtYXQgcHJvcGVydGllcyAobGlrZSBgbWFpbmApLicpO1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgJyAgICBTa2lwcGluZyBhdXRvbWF0aWMgaW5zZXJ0aW9uIG9mIGZvcm1hdCBwcm9wZXJ0aWVzIGFzIGV4cGxpY2l0ICcgK1xuICAgICAgICAgICdmb3JtYXQgcHJvcGVydGllcyBhcmUgc2V0LicsXG4gICAgICApO1xuICAgICAgY29uc29sZS5lcnJvcignICAgIElnbm9yZSB0aGlzIHdhcm5pbmcgaWYgZXhwbGljaXQgcHJvcGVydGllcyBhcmUgc2V0IGludGVudGlvbmFsbHkuJyk7XG4gICAgICByZXR1cm4gcGFja2FnZUpzb247XG4gICAgfVxuXG4gICAgY29uc3QgZmVzbTIwMjJSZWxhdGl2ZU91dFBhdGggPSBlbnRyeVBvaW50SW5mby5mZXNtMjAyMlJlbGF0aXZlUGF0aDtcbiAgICBjb25zdCB0eXBpbmdzUmVsYXRpdmVPdXRQYXRoID0gZ2V0VHlwaW5nT3V0cHV0UmVsYXRpdmVQYXRoKGVudHJ5UG9pbnRJbmZvLnR5cGluZ3MpO1xuXG4gICAgcGFja2FnZUpzb24ubW9kdWxlID0gbm9ybWFsaXplUGF0aChcbiAgICAgIHBhdGgucmVsYXRpdmUocGFja2FnZUpzb25Db250YWluaW5nRGlyLCBmZXNtMjAyMlJlbGF0aXZlT3V0UGF0aCksXG4gICAgKTtcbiAgICBwYWNrYWdlSnNvbi50eXBpbmdzID0gbm9ybWFsaXplUGF0aChcbiAgICAgIHBhdGgucmVsYXRpdmUocGFja2FnZUpzb25Db250YWluaW5nRGlyLCB0eXBpbmdzUmVsYXRpdmVPdXRQYXRoKSxcbiAgICApO1xuXG4gICAgcmV0dXJuIHBhY2thZ2VKc29uO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHByaW1hcnkgYHBhY2thZ2UuanNvbmAgZmlsZSBvZiB0aGUgTlBNIHBhY2thZ2UgdG8gc3BlY2lmeVxuICAgKiB0aGUgbW9kdWxlIGNvbmRpdGlvbmFsIGV4cG9ydHMgYW5kIHRoZSBFU00gbW9kdWxlIHR5cGUuXG4gICAqL1xuICBmdW5jdGlvbiB1cGRhdGVQcmltYXJ5UGFja2FnZUpzb24ocGFja2FnZUpzb246IFJlYWRvbmx5PFBhY2thZ2VKc29uPik6IFBhY2thZ2VKc29uIHtcbiAgICBpZiAocGFja2FnZUpzb24udHlwZSAhPT0gdW5kZWZpbmVkICYmIHBhY2thZ2VKc29uLnR5cGUgIT09ICdtb2R1bGUnKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgJ1RoZSBwcmltYXJ5IFwicGFja2FnZS5qc29uXCIgZmlsZSBvZiB0aGUgcGFja2FnZSBzZXRzIHRoZSBcInR5cGVcIiBmaWVsZCAnICtcbiAgICAgICAgICAndGhhdCBpcyBjb250cm9sbGVkIGJ5IHRoZSBwYWNrYWdlci4gUGxlYXNlIHVuc2V0IGl0IG9yIHNldCBgdHlwZWAgdG8gYG1vZHVsZWAuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgbmV3UGFja2FnZUpzb246IFBhY2thZ2VKc29uID0gey4uLnBhY2thZ2VKc29ufTtcblxuICAgIG5ld1BhY2thZ2VKc29uLnR5cGUgPSAnbW9kdWxlJztcblxuICAgIC8vIFRoZSBgcGFja2FnZS5qc29uYCBmaWxlIGlzIG1hZGUgcHVibGljbHkgYWNjZXNzaWJsZSBmb3IgdG9vbHMgdGhhdFxuICAgIC8vIG1pZ2h0IHdhbnQgdG8gcXVlcnkgaW5mb3JtYXRpb24gZnJvbSB0aGUgQW5ndWxhciBOUE0gcGFja2FnZS5cbiAgICBpbnNlcnRFeHBvcnRNYXBwaW5nT3JFcnJvcihuZXdQYWNrYWdlSnNvbiwgJy4vcGFja2FnZS5qc29uJywge2RlZmF1bHQ6ICcuL3BhY2thZ2UuanNvbid9KTtcblxuICAgIC8vIENhcHR1cmUgYWxsIGVudHJ5LXBvaW50cyBpbiB0aGUgYGV4cG9ydHNgIGZpZWxkIHVzaW5nIHRoZSBzdWJwYXRoIGV4cG9ydCBkZWNsYXJhdGlvbnM6XG4gICAgLy8gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9wYWNrYWdlcy5odG1sI3BhY2thZ2VzX3N1YnBhdGhfZXhwb3J0cy5cbiAgICBmb3IgKGNvbnN0IFttb2R1bGVOYW1lLCBlbnRyeVBvaW50XSBvZiBPYmplY3QuZW50cmllcyhtZXRhZGF0YS5lbnRyeVBvaW50cykpIHtcbiAgICAgIGNvbnN0IHN1YnBhdGggPSBpc1NlY29uZGFyeUVudHJ5UG9pbnQobW9kdWxlTmFtZSlcbiAgICAgICAgPyBgLi8ke2dldEVudHJ5UG9pbnRTdWJwYXRoKG1vZHVsZU5hbWUpfWBcbiAgICAgICAgOiAnLic7XG4gICAgICBjb25zdCBmZXNtMjAyMk91dFJlbGF0aXZlUGF0aCA9IGVudHJ5UG9pbnQuZmVzbTIwMjJSZWxhdGl2ZVBhdGg7XG4gICAgICBjb25zdCB0eXBlc091dFJlbGF0aXZlUGF0aCA9IGdldFR5cGluZ091dHB1dFJlbGF0aXZlUGF0aChlbnRyeVBvaW50LnR5cGluZ3MpO1xuXG4gICAgICAvLyBJbnNlcnQgdGhlIGV4cG9ydCBtYXBwaW5nIGZvciB0aGUgZW50cnktcG9pbnQuIFdlIHNldCBgZGVmYXVsdGAgdG8gdGhlIEZFU00gMjAyMlxuICAgICAgLy8gb3V0cHV0LCBhbmQgYWxzbyBzZXQgdGhlIGB0eXBlc2AgY29uZGl0aW9uIHdoaWNoIHdpbGwgYmUgcmVzcGVjdGVkIGJ5IFRTIDQuNS5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9wdWxsLzQ1ODg0LlxuICAgICAgaW5zZXJ0RXhwb3J0TWFwcGluZ09yRXJyb3IobmV3UGFja2FnZUpzb24sIHN1YnBhdGgsIHtcbiAgICAgICAgdHlwZXM6IG5vcm1hbGl6ZVBhdGgodHlwZXNPdXRSZWxhdGl2ZVBhdGgpLFxuICAgICAgICAvLyBOb3RlOiBUaGUgZGVmYXVsdCBjb25kaXRpb25zIG5lZWRzIHRvIGJlIHRoZSBsYXN0IG9uZS5cbiAgICAgICAgZGVmYXVsdDogbm9ybWFsaXplUGF0aChmZXNtMjAyMk91dFJlbGF0aXZlUGF0aCksXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjaGVja1BhY2thZ2VKc29uU2lkZUVmZmVjdHMocGFja2FnZUpzb24pO1xuXG4gICAgcmV0dXJuIG5ld1BhY2thZ2VKc29uO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tQYWNrYWdlSnNvblNpZGVFZmZlY3RzKHBhY2thZ2VKc29uOiBQYWNrYWdlSnNvbik6IHZvaWQge1xuICAgIC8vIENvbnZlbmllbmNlIGlmIHRoZXJlIGFyZSBubyBzaWRlIGVmZmVjdHMsIGFuZCBpdCdzIGV4cGxpY2l0bHkgbWFya2VkLlxuICAgIC8vIFRoaXMgaXMgb2theSBhbmQgd2UgZG9uJ3QgYXNrIHRoZSBkZXZlbG9wZXIgdG8gZHJvcCB0aGUgZXhwbGljaXQgZmllbGQuXG4gICAgaWYgKHBhY2thZ2VKc29uLnNpZGVFZmZlY3RzID09PSBmYWxzZSAmJiBzaWRlRWZmZWN0RW50cnlQb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHBhY2thZ2VKc29uLnNpZGVFZmZlY3RzID09PSB0cnVlKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgJ1VuZXhwZWN0ZWQgYHNpZGVFZmZlY3RzYCBmaWVsZCBpbiBgcGFja2FnZS5qc29uYC4gJyArXG4gICAgICAgICAgJ1NpZGUgZWZmZWN0cyBzaG91bGQgYmUgZmluZS1ncmFpbmVkIGFuZCBtYXJrZWQgdmlhIHRoZSBCYXplbCBgc2lkZV9lZmZlY3RfZW50cnlfcG9pbnRzYCBvcHRpb24uJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2lkZUVmZmVjdHMgPSBwYWNrYWdlSnNvbi5zaWRlRWZmZWN0cyBhcyB1bmRlZmluZWQgfCBmYWxzZSB8IHN0cmluZ1tdO1xuICAgIGNvbnN0IG5lZWRlZFNpZGVFZmZlY3RzID0gc2lkZUVmZmVjdEVudHJ5UG9pbnRzLm1hcChcbiAgICAgIChlbnRyeVBvaW50TW9kdWxlKSA9PiBgLi8ke21ldGFkYXRhLmVudHJ5UG9pbnRzW2VudHJ5UG9pbnRNb2R1bGVdLmZlc20yMDIyUmVsYXRpdmVQYXRofWAsXG4gICAgKTtcbiAgICBjb25zdCBtaXNzaW5nU2lkZUVmZmVjdHMgPSBuZWVkZWRTaWRlRWZmZWN0cy5maWx0ZXIoXG4gICAgICAocCkgPT5cbiAgICAgICAgLy8gSXQncyBtaXNzaW5nLCBpZiB0aGUgd2hvbGUgcGFja2FnZSBpcyBtYXJrZWQgYXMgaGF2aW5nIG5vIHNpZGUgZWZmZWN0cy5cbiAgICAgICAgc2lkZUVmZmVjdHMgPT09IGZhbHNlIHx8XG4gICAgICAgIC8vIEFsdGVybmF0aXZlbHksIGl0J3MgbWlzc2luZyBpZiB0aGUgZXhwbGljaXQgbGlzdCBkb2Vzbid0IGNvbnRhaW4gdGhlIHBhdHRlcm4uXG4gICAgICAgICEoc2lkZUVmZmVjdHMgPz8gW10pLmluY2x1ZGVzKHApLFxuICAgICk7XG5cbiAgICBpZiAobWlzc2luZ1NpZGVFZmZlY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAnTWlzc2luZyBzaWRlIGVmZmVjdHMgaW4gYHBhY2thZ2UuanNvbmAgYHNpZGVFZmZlY3RzYCBmaWVsZC4gJyArXG4gICAgICAgICAgJ1BsZWFzZSBhZGQgdGhlIGZvbGxvd2luZyBzaWRlIGVmZmVjdCBmaWxlIHBhdHRlcm5zOlxcbicgK1xuICAgICAgICAgIG1pc3NpbmdTaWRlRWZmZWN0cy5qb2luKCdcXG4gLSAnKSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gRmluZCBwb3RlbnRpYWwgc2lkZS1lZmZlY3RzIHRoYXQgcmVmZXIgdG8gb3VyIEZFU00gYnVuZGxlcywgYnV0IGFyZW4ndCBwYXJ0XG4gICAgLy8gb2YgdGhlIGBuZ19wYWNrYWdlYCBrbm93biBlbnRyeSBwb2ludHMuXG4gICAgY29uc3QgdW5leHBlY3RlZEV4dHJhID1cbiAgICAgIHNpZGVFZmZlY3RzICE9PSBmYWxzZVxuICAgICAgICA/IChzaWRlRWZmZWN0cyA/PyBbXSkuZmlsdGVyKFxuICAgICAgICAgICAgKHApID0+IHAuaW5jbHVkZXMoJ2Zlc20yMDIyJykgJiYgIW5lZWRlZFNpZGVFZmZlY3RzLmluY2x1ZGVzKHApLFxuICAgICAgICAgIClcbiAgICAgICAgOiBbXTtcbiAgICBpZiAodW5leHBlY3RlZEV4dHJhLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAnVW5leHBlY3RlZCBzaWRlIGVmZmVjdHMgaW4gYHBhY2thZ2UuanNvbmAgYHNpZGVFZmZlY3RzYCBmaWVsZCB0aGF0IGlzIG5vdCBrbm93biB0byBgbmdfcGFja2FnZWAuICcgK1xuICAgICAgICAgICdQbGVhc2UgYWRkIHRoZSBzaWRlIGVmZmVjdCBlbnRyeSBwb2ludCB0byB0aGUgQmF6ZWwgYHNpZGVfZWZmZWN0X2VudHJ5X3BvaW50c2Agb3B0aW9uLiAnICtcbiAgICAgICAgICAnVW5leHBlY3RlZCBwYXR0ZXJuczpcXG4nICtcbiAgICAgICAgICB1bmV4cGVjdGVkRXh0cmEuam9pbignXFxuIC0gJyksXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIGEgc3VicGF0aCBleHBvcnQgbWFwcGluZyBpbnRvIHRoZSBzcGVjaWZpZWQgYHBhY2thZ2UuanNvbmAgb2JqZWN0LlxuICAgKiBAdGhyb3dzIEFuIGVycm9yIGlmIHRoZSBtYXBwaW5nIGlzIGFscmVhZHkgZGVmaW5lZCBhbmQgd291bGQgY29uZmxpY3QuXG4gICAqL1xuICBmdW5jdGlvbiBpbnNlcnRFeHBvcnRNYXBwaW5nT3JFcnJvcihcbiAgICBwYWNrYWdlSnNvbjogUGFja2FnZUpzb24sXG4gICAgc3VicGF0aDogc3RyaW5nLFxuICAgIG1hcHBpbmc6IENvbmRpdGlvbmFsRXhwb3J0LFxuICApIHtcbiAgICBpZiAocGFja2FnZUpzb24uZXhwb3J0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYWNrYWdlSnNvbi5leHBvcnRzID0ge307XG4gICAgfVxuICAgIGlmIChwYWNrYWdlSnNvbi5leHBvcnRzW3N1YnBhdGhdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhY2thZ2VKc29uLmV4cG9ydHNbc3VicGF0aF0gPSB7fTtcbiAgICB9XG5cbiAgICBjb25zdCBzdWJwYXRoRXhwb3J0ID0gcGFja2FnZUpzb24uZXhwb3J0c1tzdWJwYXRoXTtcblxuICAgIC8vIEdvIHRocm91Z2ggYWxsIGNvbmRpdGlvbnMgdGhhdCBzaG91bGQgYmUgaW5zZXJ0ZWQuIElmIHRoZSBjb25kaXRpb24gaXMgYWxyZWFkeVxuICAgIC8vIG1hbnVhbGx5IHNldCBvZiB0aGUgc3VicGF0aCBleHBvcnQsIHdlIHRocm93IGFuIGVycm9yLiBJbiBnZW5lcmFsLCB3ZSBhbGxvdyBmb3JcbiAgICAvLyBhZGRpdGlvbmFsIGNvbmRpdGlvbnMgdG8gYmUgc2V0LiBUaGVzZSB3aWxsIGFsd2F5cyBwcmVjZWRlIHRoZSBnZW5lcmF0ZWQgb25lcy5cbiAgICBmb3IgKGNvbnN0IGNvbmRpdGlvbk5hbWUgb2YgT2JqZWN0LmtleXMobWFwcGluZykgYXMgW2tleW9mIENvbmRpdGlvbmFsRXhwb3J0XSkge1xuICAgICAgaWYgKHN1YnBhdGhFeHBvcnRbY29uZGl0aW9uTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBgRm91bmQgYSBjb25mbGljdGluZyBleHBvcnQgY29uZGl0aW9uIGZvciBcIiR7c3VicGF0aH1cIi4gVGhlIFwiJHtjb25kaXRpb25OYW1lfVwiIGAgK1xuICAgICAgICAgICAgYGNvbmRpdGlvbiB3b3VsZCBiZSBvdmVycmlkZGVuIGJ5IHRoZSBwYWNrYWdlci4gUGxlYXNlIHVuc2V0IGl0LmAsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vICoqTm90ZSoqOiBUaGUgb3JkZXIgb2YgdGhlIGNvbmRpdGlvbnMgaXMgcHJlc2VydmVkIGV2ZW4gdGhvdWdoIHdlIGFyZSBzZXR0aW5nXG4gICAgICAvLyB0aGUgY29uZGl0aW9ucyBvbmNlIGF0IGEgdGltZSAodGhlIGxhdGVzdCBhc3NpZ25tZW50IHdpbGwgYmUgYXQgdGhlIGVuZCkuXG4gICAgICBzdWJwYXRoRXhwb3J0W2NvbmRpdGlvbk5hbWVdID0gbWFwcGluZ1tjb25kaXRpb25OYW1lXTtcbiAgICB9XG4gIH1cblxuICAvKiogV2hldGhlciB0aGUgcGFja2FnZSBleHBsaWNpdGx5IHNldHMgYW55IG9mIHRoZSBmb3JtYXQgcHJvcGVydGllcyAobGlrZSBgbWFpbmApLiAqL1xuICBmdW5jdGlvbiBoYXNFeHBsaWNpdEZvcm1hdFByb3BlcnRpZXMocGFyc2VkUGFja2FnZTogUmVhZG9ubHk8UGFja2FnZUpzb24+KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHBhcnNlZFBhY2thZ2UpLnNvbWUoKGZpZWxkTmFtZTogc3RyaW5nKSA9PlxuICAgICAga25vd25Gb3JtYXRQYWNrYWdlSnNvbkZvcm1hdEZpZWxkcy5pbmNsdWRlcyhmaWVsZE5hbWUgYXMgS25vd25QYWNrYWdlSnNvbkZvcm1hdEZpZWxkcyksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemVzIHRoZSBzcGVjaWZpZWQgcGF0aCBieSByZXBsYWNpbmcgYmFja3NsYXNoIHNlcGFyYXRvcnMgd2l0aCBQb3NpeFxuICAgKiBmb3J3YXJkIHNsYXNoIHNlcGFyYXRvcnMuXG4gICAqL1xuICBmdW5jdGlvbiBub3JtYWxpemVQYXRoKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgcmVzdWx0ID0gcGF0aC5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG4gICAgcmV0dXJuIHJlc3VsdC5zdGFydHNXaXRoKCcuJykgPyByZXN1bHQgOiBgLi8ke3Jlc3VsdH1gO1xuICB9XG59XG4iXX0=