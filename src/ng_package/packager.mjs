/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
import * as fs from 'fs';
import * as path from 'path';
import { analyzeFileAndEnsureNoCrossImports } from './cross_entry_points_imports';
/**
 * List of known `package.json` fields which provide information about
 * supported package formats and their associated entry paths.
 */
const knownFormatPackageJsonFormatFields = ['main', 'esm2022', 'esm', 'typings', 'module'];
// Main entry-point.
main(process.argv.slice(2));
function main(args) {
    // This utility expects all of its arguments to be specified in a params file generated by
    // bazel (see https://docs.bazel.build/versions/master/skylark/lib/Args.html#use_param_file).
    const paramFilePath = args[0];
    // Bazel params may be surrounded with quotes
    function unquoteParameter(s) {
        return s.replace(/^'(.*)'$/, '$1');
    }
    // Parameters are specified in the file one per line.
    const params = fs.readFileSync(paramFilePath, 'utf-8').split('\n').map(unquoteParameter);
    const [
    // Output directory for the npm package.
    outputDirExecPath, 
    // The package segment of the ng_package rule's label (e.g. 'package/common').
    owningPackageName, 
    // JSON data capturing metadata of the package being built. See `PackageMetadata`.
    metadataArg, 
    // Path to the package's README.md.
    readmeMd, 
    // List of rolled-up flat ES2022 modules
    fesm2022Arg, 
    // List of individual ES2022 modules
    esm2022Arg, 
    // List of static files that should be copied into the package.
    staticFilesArg, 
    // List of all type definitions that need to packaged into the ng_package.
    typeDefinitionsArg,] = params;
    const fesm2022 = JSON.parse(fesm2022Arg);
    const esm2022 = JSON.parse(esm2022Arg);
    const typeDefinitions = JSON.parse(typeDefinitionsArg);
    const staticFiles = JSON.parse(staticFilesArg);
    const metadata = JSON.parse(metadataArg);
    if (readmeMd) {
        copyFile(readmeMd, 'README.md');
    }
    /**
     * Writes a file with the specified content into the package output.
     * @param outputRelativePath Relative path in the output directory where the
     *   file is written to.
     * @param fileContent Content of the file.
     */
    function writeFile(outputRelativePath, fileContent) {
        const outputPath = path.join(outputDirExecPath, outputRelativePath);
        // Always ensure that the target directory exists.
        fs.mkdirSync(path.dirname(outputPath), { recursive: true });
        fs.writeFileSync(outputPath, fileContent);
    }
    /**
     * Copies a file into the package output to the specified location.
     * @param inputPath File that should be copied.
     * @param outputRelativePath Relative path in the output directory where the
     *   file is written to.
     */
    function copyFile(inputPath, outputRelativePath) {
        const fileContent = fs.readFileSync(inputPath, 'utf8');
        writeFile(outputRelativePath, fileContent);
    }
    /**
     * Gets the relative path for the given file within the owning package. This
     * assumes the file is contained in the owning package.
     *
     * e.g. consider the owning package is `packages/core` and the input file
     * is `packages/core/testing/index.d.ts`. This function would return the
     * relative path as followed: `testing/index.d.ts`.
     */
    function getOwningPackageRelativePath(file) {
        return path.relative(owningPackageName, file.shortPath);
    }
    /** Writes an ESM file into the `esm2022` output directory. */
    function writeEsm2022File(file) {
        // Note: files which do not belong to the owning package of this `ng_package` are omitted.
        // this prevents us from accidentally bringing in transitive node module dependencies.
        const packageRelativePath = getOwningPackageRelativePath(file);
        if (!packageRelativePath.startsWith('..')) {
            copyFile(file.path, getEsm2022OutputRelativePath(file));
        }
    }
    /** Gets the output-relative path where the given flat ESM file should be written to. */
    function getFlatEsmOutputRelativePath(file) {
        // Flat ESM files should be put into their owning package relative sub-path. e.g. if
        // there is a bundle in `packages/animations/fesm2022/browser/testing.mjs` then we
        // want the bundle to be stored in `fesm2022/browser/testing.mjs`. Same thing applies
        // for the `fesm2022` bundles. The directory name for `fesm` is already declared as
        // part of the Bazel action generating these files. See `ng_package.bzl`.
        return getOwningPackageRelativePath(file);
    }
    /** Gets the output-relative path where a non-flat ESM2022 file should be written to. */
    function getEsm2022OutputRelativePath(file) {
        // Path computed relative to the current package in bazel-bin. e.g. a ES2022 output file
        // in `bazel-out/<..>/packages/core/src/di.mjs` should be stored in `esm2022/src/di.mjs`.
        return path.join('esm2022', getOwningPackageRelativePath(file));
    }
    /** Gets the output-relative path where the typing file is being written to. */
    function getTypingOutputRelativePath(file) {
        // Type definitions are intended to be copied into the package output while preserving the
        // sub-path from the owning package. e.g. a file like `packages/animations/browser/__index.d.ts`
        // will end up being written to `<pkg-out>/browser/index.d.ts`. Note that types are bundled
        // as a separate action in the `ng_package` Starlark rule and prefixed with `__` to avoid
        // conflicts with source `index.d.ts` files. We remove this prefix here.
        return getOwningPackageRelativePath(file).replace(/__index\.d\.ts$/, 'index.d.ts');
    }
    /**
     * Gets the entry-point sub-path from the package root. e.g. if the package name
     * is `@angular/cdk`, then for `@angular/cdk/a11y` just `a11y` would be returned.
     */
    function getEntryPointSubpath(moduleName) {
        return moduleName.slice(`${metadata.npmPackageName}/`.length);
    }
    /**
     * Gets whether the given module name resolves to a secondary entry-point.
     * e.g. if the package name is `@angular/cdk`, then for `@angular/cdk/a11y`
     * this would return `true`.
     */
    function isSecondaryEntryPoint(moduleName) {
        return getEntryPointSubpath(moduleName) !== '';
    }
    const crossEntryPointFailures = [];
    esm2022.forEach((file) => {
        crossEntryPointFailures.push(...analyzeFileAndEnsureNoCrossImports(file, metadata));
        writeEsm2022File(file);
    });
    if (crossEntryPointFailures.length) {
        console.error(crossEntryPointFailures);
        process.exit(1);
    }
    // Copy all FESM files into the package output.
    fesm2022.forEach((f) => copyFile(f.path, getFlatEsmOutputRelativePath(f)));
    // Copy all type definitions into the package, preserving the sub-path from the
    // owning package. e.g. a file like `packages/animations/browser/__index.d.ts` will
    // end up in `browser/index.d.ts`
    typeDefinitions.forEach((f) => copyFile(f.path, getTypingOutputRelativePath(f)));
    for (const file of staticFiles) {
        // We copy all files into the package output while preserving the sub-path from
        // the owning package. e.g. `packages/core/package.json` ends up `<pkg-out>/package.json`.
        const outputRelativePath = getOwningPackageRelativePath(file);
        let content = fs.readFileSync(file.path, 'utf8');
        // Check and modify package.json files as necessary for publishing
        if (path.basename(file.path) === 'package.json') {
            const isPrimaryPackageJson = outputRelativePath === 'package.json';
            const packageJson = JSON.parse(content);
            const packageName = packageJson['name'];
            // Prevent non-primary `package.json` files which would throw-off resolution.
            // Resolution in the package should only be based on the top-level `package.json`.
            if (!isPrimaryPackageJson) {
                throw Error(`Found a nested "package.json" file in the package output: ${file.shortPath}.\n` +
                    `All information of the package should reside in the primary package file.`);
            }
            // Check if the `name` field of the `package.json` files are matching with
            // name of the NPM package. This is an additional safety check.
            if (packageName !== metadata.npmPackageName) {
                throw Error(`Primary "package.json" has mismatching package name. Expected the ` +
                    `package to be named "${metadata.npmPackageName}", but is set to: ${packageName}.`);
            }
            let newPackageJson = insertFormatFieldsIntoPackageJson(outputRelativePath, packageJson, false);
            newPackageJson = updatePrimaryPackageJson(newPackageJson);
            // Update the content with the new `package.json` file content.
            content = JSON.stringify(newPackageJson, null, 2);
        }
        writeFile(outputRelativePath, content);
    }
    /**
     * Inserts or edits properties into the package.json file(s) in the package so that
     * they point to all the right generated artifacts.
     *
     * @param packageJsonOutRelativePath Path where the `package.json` is stored in
     *   the package output.
     * @param parsedPackage Parsed package.json content
     * @param isGeneratedPackageJson Whether the passed package.json has been generated.
     */
    function insertFormatFieldsIntoPackageJson(packageJsonOutRelativePath, parsedPackage, isGeneratedPackageJson) {
        const packageJson = { ...parsedPackage };
        const packageName = packageJson['name'];
        const entryPointInfo = metadata.entryPoints[packageName];
        const packageJsonContainingDir = path.dirname(packageJsonOutRelativePath);
        // If a package json file has been discovered that does not match any
        // entry-point in the metadata, we report a warning as most likely the target
        // is configured incorrectly (e.g. missing `module_name` attribute).
        if (!entryPointInfo) {
            // Ideally we should throw here, as we got an entry point that doesn't
            // have flat module metadata / bundle index, so it may have been an
            // ng_module that's missing a module_name attribute.
            // However, @angular/compiler can't be an ng_module, as it's the internals
            // of the ngc compiler, yet we want to build an ng_package for it.
            // So ignore package.json files when we are missing data.
            console.error('WARNING: no module metadata for package', packageName);
            console.error('   Not updating the package.json file to point to it');
            console.error('   The ng_module for this package is possibly missing the module_name attribute ');
            return packageJson;
        }
        // If we guessed the index paths for a module, and it contains an explicit `package.json`
        // file that already sets format properties, we skip automatic insertion of format
        // properties but report a warning in case properties have been set by accident.
        if (entryPointInfo.guessedPaths &&
            !isGeneratedPackageJson &&
            hasExplicitFormatProperties(packageJson)) {
            console.error('WARNING: `package.json` explicitly sets format properties (like `main`).');
            console.error('    Skipping automatic insertion of format properties as explicit ' +
                'format properties are set.');
            console.error('    Ignore this warning if explicit properties are set intentionally.');
            return packageJson;
        }
        const fesm2022RelativeOutPath = getFlatEsmOutputRelativePath(entryPointInfo.fesm2022Bundle);
        const typingsRelativeOutPath = getTypingOutputRelativePath(entryPointInfo.typings);
        packageJson.module = normalizePath(path.relative(packageJsonContainingDir, fesm2022RelativeOutPath));
        packageJson.typings = normalizePath(path.relative(packageJsonContainingDir, typingsRelativeOutPath));
        return packageJson;
    }
    /**
     * Updates the primary `package.json` file of the NPM package to specify
     * the module conditional exports and the ESM module type.
     */
    function updatePrimaryPackageJson(packageJson) {
        if (packageJson.type !== undefined) {
            throw Error('The primary "package.json" file of the package sets the "type" field ' +
                'that is controlled by the packager. Please unset it.');
        }
        const newPackageJson = { ...packageJson };
        newPackageJson.type = 'module';
        // The `package.json` file is made publicly accessible for tools that
        // might want to query information from the Angular NPM package.
        insertExportMappingOrError(newPackageJson, './package.json', { default: './package.json' });
        // Capture all entry-points in the `exports` field using the subpath export declarations:
        // https://nodejs.org/api/packages.html#packages_subpath_exports.
        for (const [moduleName, entryPoint] of Object.entries(metadata.entryPoints)) {
            const subpath = isSecondaryEntryPoint(moduleName)
                ? `./${getEntryPointSubpath(moduleName)}`
                : '.';
            const esmIndexOutRelativePath = getEsm2022OutputRelativePath(entryPoint.index);
            const fesm2022OutRelativePath = getFlatEsmOutputRelativePath(entryPoint.fesm2022Bundle);
            const typesOutRelativePath = getTypingOutputRelativePath(entryPoint.typings);
            // Insert the export mapping for the entry-point. We set `default` to the FESM 2022
            // output, and also set the `types` condition which will be respected by TS 4.5.
            // https://github.com/microsoft/TypeScript/pull/45884.
            insertExportMappingOrError(newPackageJson, subpath, {
                types: normalizePath(typesOutRelativePath),
                esm2022: normalizePath(esmIndexOutRelativePath),
                esm: normalizePath(esmIndexOutRelativePath),
                // Note: The default conditions needs to be the last one.
                default: normalizePath(fesm2022OutRelativePath),
            });
        }
        return newPackageJson;
    }
    /**
     * Inserts a subpath export mapping into the specified `package.json` object.
     * @throws An error if the mapping is already defined and would conflict.
     */
    function insertExportMappingOrError(packageJson, subpath, mapping) {
        if (packageJson.exports === undefined) {
            packageJson.exports = {};
        }
        if (packageJson.exports[subpath] === undefined) {
            packageJson.exports[subpath] = {};
        }
        const subpathExport = packageJson.exports[subpath];
        // Go through all conditions that should be inserted. If the condition is already
        // manually set of the subpath export, we throw an error. In general, we allow for
        // additional conditions to be set. These will always precede the generated ones.
        for (const conditionName of Object.keys(mapping)) {
            if (subpathExport[conditionName] !== undefined) {
                throw Error(`Found a conflicting export condition for "${subpath}". The "${conditionName}" ` +
                    `condition would be overridden by the packager. Please unset it.`);
            }
            // **Note**: The order of the conditions is preserved even though we are setting
            // the conditions once at a time (the latest assignment will be at the end).
            subpathExport[conditionName] = mapping[conditionName];
        }
    }
    /** Whether the package explicitly sets any of the format properties (like `main`). */
    function hasExplicitFormatProperties(parsedPackage) {
        return Object.keys(parsedPackage).some((fieldName) => knownFormatPackageJsonFormatFields.includes(fieldName));
    }
    /**
     * Normalizes the specified path by replacing backslash separators with Posix
     * forward slash separators.
     */
    function normalizePath(path) {
        const result = path.replace(/\\/g, '/');
        return result.startsWith('.') ? result : `./${result}`;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFja2FnZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9iYXplbC9zcmMvbmdfcGFja2FnZS9wYWNrYWdlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFFSCxPQUFPLEtBQUssRUFBRSxNQUFNLElBQUksQ0FBQztBQUN6QixPQUFPLEtBQUssSUFBSSxNQUFNLE1BQU0sQ0FBQztBQUc3QixPQUFPLEVBQUMsa0NBQWtDLEVBQUMsTUFBTSw4QkFBOEIsQ0FBQztBQUVoRjs7O0dBR0c7QUFDSCxNQUFNLGtDQUFrQyxHQUFHLENBQUMsTUFBTSxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLFFBQVEsQ0FBVSxDQUFDO0FBeUJwRyxvQkFBb0I7QUFDcEIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFFNUIsU0FBUyxJQUFJLENBQUMsSUFBYztJQUMxQiwwRkFBMEY7SUFDMUYsNkZBQTZGO0lBQzdGLE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUU5Qiw2Q0FBNkM7SUFDN0MsU0FBUyxnQkFBZ0IsQ0FBQyxDQUFTO1FBQ2pDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVELHFEQUFxRDtJQUNyRCxNQUFNLE1BQU0sR0FBRyxFQUFFLENBQUMsWUFBWSxDQUFDLGFBQWEsRUFBRSxPQUFPLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLENBQUM7SUFFekYsTUFBTTtJQUNKLHdDQUF3QztJQUN4QyxpQkFBaUI7SUFFakIsOEVBQThFO0lBQzlFLGlCQUFpQjtJQUVqQixrRkFBa0Y7SUFDbEYsV0FBVztJQUVYLG1DQUFtQztJQUNuQyxRQUFR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bkQsaUZBQWlGO1FBQ2pGLGtGQUFrRjtRQUNsRixpRkFBaUY7UUFDakYsS0FBSyxNQUFNLGFBQWEsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBOEIsRUFBRSxDQUFDO1lBQzlFLElBQUksYUFBYSxDQUFDLGFBQWEsQ0FBQyxLQUFLLFNBQVMsRUFBRSxDQUFDO2dCQUMvQyxNQUFNLEtBQUssQ0FDVCw2Q0FBNkMsT0FBTyxXQUFXLGFBQWEsSUFBSTtvQkFDOUUsaUVBQWlFLENBQ3BFLENBQUM7WUFDSixDQUFDO1lBRUQsZ0ZBQWdGO1lBQ2hGLDRFQUE0RTtZQUM1RSxhQUFhLENBQUMsYUFBYSxDQUFDLEdBQUcsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQ3hELENBQUM7SUFDSCxDQUFDO0lBRUQsc0ZBQXNGO0lBQ3RGLFNBQVMsMkJBQTJCLENBQUMsYUFBb0M7UUFDdkUsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQWlCLEVBQUUsRUFBRSxDQUMzRCxrQ0FBa0MsQ0FBQyxRQUFRLENBQUMsU0FBeUMsQ0FBQyxDQUN2RixDQUFDO0lBQ0osQ0FBQztJQUVEOzs7T0FHRztJQUNILFNBQVMsYUFBYSxDQUFDLElBQVk7UUFDakMsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDeEMsT0FBTyxNQUFNLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssTUFBTSxFQUFFLENBQUM7SUFDekQsQ0FBQztBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5kZXYvbGljZW5zZVxuICovXG5cbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5cbmltcG9ydCB7QmF6ZWxGaWxlSW5mbywgUGFja2FnZU1ldGFkYXRhfSBmcm9tICcuL2FwaSc7XG5pbXBvcnQge2FuYWx5emVGaWxlQW5kRW5zdXJlTm9Dcm9zc0ltcG9ydHN9IGZyb20gJy4vY3Jvc3NfZW50cnlfcG9pbnRzX2ltcG9ydHMnO1xuXG4vKipcbiAqIExpc3Qgb2Yga25vd24gYHBhY2thZ2UuanNvbmAgZmllbGRzIHdoaWNoIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXRcbiAqIHN1cHBvcnRlZCBwYWNrYWdlIGZvcm1hdHMgYW5kIHRoZWlyIGFzc29jaWF0ZWQgZW50cnkgcGF0aHMuXG4gKi9cbmNvbnN0IGtub3duRm9ybWF0UGFja2FnZUpzb25Gb3JtYXRGaWVsZHMgPSBbJ21haW4nLCAnZXNtMjAyMicsICdlc20nLCAndHlwaW5ncycsICdtb2R1bGUnXSBhcyBjb25zdDtcblxuLyoqIFVuaW9uIHR5cGUgbWF0Y2hpbmcga25vd24gYHBhY2thZ2UuanNvbmAgZm9ybWF0IGZpZWxkcy4gKi9cbnR5cGUgS25vd25QYWNrYWdlSnNvbkZvcm1hdEZpZWxkcyA9ICh0eXBlb2Yga25vd25Gb3JtYXRQYWNrYWdlSnNvbkZvcm1hdEZpZWxkcylbbnVtYmVyXTtcblxuLyoqXG4gKiBUeXBlIGRlc2NyaWJpbmcgdGhlIGNvbmRpdGlvbmFsIGV4cG9ydHMgZGVzY3JpcHRvciBmb3IgYW4gZW50cnktcG9pbnQuXG4gKiBodHRwczovL25vZGVqcy5vcmcvYXBpL3BhY2thZ2VzLmh0bWwjcGFja2FnZXNfY29uZGl0aW9uYWxfZXhwb3J0c1xuICovXG50eXBlIENvbmRpdGlvbmFsRXhwb3J0ID0ge1xuICB0eXBlcz86IHN0cmluZztcbiAgZXNtMjAyMj86IHN0cmluZztcbiAgZXNtPzogc3RyaW5nO1xuICBkZWZhdWx0Pzogc3RyaW5nO1xufTtcblxuLyoqIFR5cGUgZGVzY3JpYmluZyBhIGBwYWNrYWdlLmpzb25gIHRoZSBwYWNrYWdlciBkZWFscyB3aXRoLiAqL1xudHlwZSBQYWNrYWdlSnNvbiA9IHtcbiAgW2tleSBpbiBLbm93blBhY2thZ2VKc29uRm9ybWF0RmllbGRzXT86IHN0cmluZztcbn0gJiB7XG4gIG5hbWU6IHN0cmluZztcbiAgdHlwZT86IHN0cmluZztcbiAgZXhwb3J0cz86IFJlY29yZDxzdHJpbmcsIENvbmRpdGlvbmFsRXhwb3J0Pjtcbn07XG5cbi8vIE1haW4gZW50cnktcG9pbnQuXG5tYWluKHByb2Nlc3MuYXJndi5zbGljZSgyKSk7XG5cbmZ1bmN0aW9uIG1haW4oYXJnczogc3RyaW5nW10pOiB2b2lkIHtcbiAgLy8gVGhpcyB1dGlsaXR5IGV4cGVjdHMgYWxsIG9mIGl0cyBhcmd1bWVudHMgdG8gYmUgc3BlY2lmaWVkIGluIGEgcGFyYW1zIGZpbGUgZ2VuZXJhdGVkIGJ5XG4gIC8vIGJhemVsIChzZWUgaHR0cHM6Ly9kb2NzLmJhemVsLmJ1aWxkL3ZlcnNpb25zL21hc3Rlci9za3lsYXJrL2xpYi9BcmdzLmh0bWwjdXNlX3BhcmFtX2ZpbGUpLlxuICBjb25zdCBwYXJhbUZpbGVQYXRoID0gYXJnc1swXTtcblxuICAvLyBCYXplbCBwYXJhbXMgbWF5IGJlIHN1cnJvdW5kZWQgd2l0aCBxdW90ZXNcbiAgZnVuY3Rpb24gdW5xdW90ZVBhcmFtZXRlcihzOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKC9eJyguKiknJC8sICckMScpO1xuICB9XG5cbiAgLy8gUGFyYW1ldGVycyBhcmUgc3BlY2lmaWVkIGluIHRoZSBmaWxlIG9uZSBwZXIgbGluZS5cbiAgY29uc3QgcGFyYW1zID0gZnMucmVhZEZpbGVTeW5jKHBhcmFtRmlsZVBhdGgsICd1dGYtOCcpLnNwbGl0KCdcXG4nKS5tYXAodW5xdW90ZVBhcmFtZXRlcik7XG5cbiAgY29uc3QgW1xuICAgIC8vIE91dHB1dCBkaXJlY3RvcnkgZm9yIHRoZSBucG0gcGFja2FnZS5cbiAgICBvdXRwdXREaXJFeGVjUGF0aCxcblxuICAgIC8vIFRoZSBwYWNrYWdlIHNlZ21lbnQgb2YgdGhlIG5nX3BhY2thZ2UgcnVsZSdzIGxhYmVsIChlLmcuICdwYWNrYWdlL2NvbW1vbicpLlxuICAgIG93bmluZ1BhY2thZ2VOYW1lLFxuXG4gICAgLy8gSlNPTiBkYXRhIGNhcHR1cmluZyBtZXRhZGF0YSBvZiB0aGUgcGFja2FnZSBiZWluZyBidWlsdC4gU2VlIGBQYWNrYWdlTWV0YWRhdGFgLlxuICAgIG1ldGFkYXRhQXJnLFxuXG4gICAgLy8gUGF0aCB0byB0aGUgcGFja2FnZSdzIFJFQURNRS5tZC5cbiAgICByZWFkbWVNZCxcblxuICAgIC8vIExpc3Qgb2Ygcm9sbGVkLXVwIGZsYXQgRVMyMDIyIG1vZHVsZXNcbiAgICBmZXNtMjAyMkFyZyxcblxuICAgIC8vIExpc3Qgb2YgaW5kaXZpZHVhbCBFUzIwMjIgbW9kdWxlc1xuICAgIGVzbTIwMjJBcmcsXG5cbiAgICAvLyBMaXN0IG9mIHN0YXRpYyBmaWxlcyB0aGF0IHNob3VsZCBiZSBjb3BpZWQgaW50byB0aGUgcGFja2FnZS5cbiAgICBzdGF0aWNGaWxlc0FyZyxcblxuICAgIC8vIExpc3Qgb2YgYWxsIHR5cGUgZGVmaW5pdGlvbnMgdGhhdCBuZWVkIHRvIHBhY2thZ2VkIGludG8gdGhlIG5nX3BhY2thZ2UuXG4gICAgdHlwZURlZmluaXRpb25zQXJnLFxuICBdID0gcGFyYW1zO1xuXG4gIGNvbnN0IGZlc20yMDIyID0gSlNPTi5wYXJzZShmZXNtMjAyMkFyZykgYXMgQmF6ZWxGaWxlSW5mb1tdO1xuICBjb25zdCBlc20yMDIyID0gSlNPTi5wYXJzZShlc20yMDIyQXJnKSBhcyBCYXplbEZpbGVJbmZvW107XG4gIGNvbnN0IHR5cGVEZWZpbml0aW9ucyA9IEpTT04ucGFyc2UodHlwZURlZmluaXRpb25zQXJnKSBhcyBCYXplbEZpbGVJbmZvW107XG4gIGNvbnN0IHN0YXRpY0ZpbGVzID0gSlNPTi5wYXJzZShzdGF0aWNGaWxlc0FyZykgYXMgQmF6ZWxGaWxlSW5mb1tdO1xuICBjb25zdCBtZXRhZGF0YSA9IEpTT04ucGFyc2UobWV0YWRhdGFBcmcpIGFzIFBhY2thZ2VNZXRhZGF0YTtcblxuICBpZiAocmVhZG1lTWQpIHtcbiAgICBjb3B5RmlsZShyZWFkbWVNZCwgJ1JFQURNRS5tZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlcyBhIGZpbGUgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbnRlbnQgaW50byB0aGUgcGFja2FnZSBvdXRwdXQuXG4gICAqIEBwYXJhbSBvdXRwdXRSZWxhdGl2ZVBhdGggUmVsYXRpdmUgcGF0aCBpbiB0aGUgb3V0cHV0IGRpcmVjdG9yeSB3aGVyZSB0aGVcbiAgICogICBmaWxlIGlzIHdyaXR0ZW4gdG8uXG4gICAqIEBwYXJhbSBmaWxlQ29udGVudCBDb250ZW50IG9mIHRoZSBmaWxlLlxuICAgKi9cbiAgZnVuY3Rpb24gd3JpdGVGaWxlKG91dHB1dFJlbGF0aXZlUGF0aDogc3RyaW5nLCBmaWxlQ29udGVudDogc3RyaW5nIHwgQnVmZmVyKSB7XG4gICAgY29uc3Qgb3V0cHV0UGF0aCA9IHBhdGguam9pbihvdXRwdXREaXJFeGVjUGF0aCwgb3V0cHV0UmVsYXRpdmVQYXRoKTtcblxuICAgIC8vIEFsd2F5cyBlbnN1cmUgdGhhdCB0aGUgdGFyZ2V0IGRpcmVjdG9yeSBleGlzdHMuXG4gICAgZnMubWtkaXJTeW5jKHBhdGguZGlybmFtZShvdXRwdXRQYXRoKSwge3JlY3Vyc2l2ZTogdHJ1ZX0pO1xuICAgIGZzLndyaXRlRmlsZVN5bmMob3V0cHV0UGF0aCwgZmlsZUNvbnRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvcGllcyBhIGZpbGUgaW50byB0aGUgcGFja2FnZSBvdXRwdXQgdG8gdGhlIHNwZWNpZmllZCBsb2NhdGlvbi5cbiAgICogQHBhcmFtIGlucHV0UGF0aCBGaWxlIHRoYXQgc2hvdWxkIGJlIGNvcGllZC5cbiAgICogQHBhcmFtIG91dHB1dFJlbGF0aXZlUGF0aCBSZWxhdGl2ZSBwYXRoIGluIHRoZSBvdXRwdXQgZGlyZWN0b3J5IHdoZXJlIHRoZVxuICAgKiAgIGZpbGUgaXMgd3JpdHRlbiB0by5cbiAgICovXG4gIGZ1bmN0aW9uIGNvcHlGaWxlKGlucHV0UGF0aDogc3RyaW5nLCBvdXRwdXRSZWxhdGl2ZVBhdGg6IHN0cmluZykge1xuICAgIGNvbnN0IGZpbGVDb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKGlucHV0UGF0aCwgJ3V0ZjgnKTtcbiAgICB3cml0ZUZpbGUob3V0cHV0UmVsYXRpdmVQYXRoLCBmaWxlQ29udGVudCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgcmVsYXRpdmUgcGF0aCBmb3IgdGhlIGdpdmVuIGZpbGUgd2l0aGluIHRoZSBvd25pbmcgcGFja2FnZS4gVGhpc1xuICAgKiBhc3N1bWVzIHRoZSBmaWxlIGlzIGNvbnRhaW5lZCBpbiB0aGUgb3duaW5nIHBhY2thZ2UuXG4gICAqXG4gICAqIGUuZy4gY29uc2lkZXIgdGhlIG93bmluZyBwYWNrYWdlIGlzIGBwYWNrYWdlcy9jb3JlYCBhbmQgdGhlIGlucHV0IGZpbGVcbiAgICogaXMgYHBhY2thZ2VzL2NvcmUvdGVzdGluZy9pbmRleC5kLnRzYC4gVGhpcyBmdW5jdGlvbiB3b3VsZCByZXR1cm4gdGhlXG4gICAqIHJlbGF0aXZlIHBhdGggYXMgZm9sbG93ZWQ6IGB0ZXN0aW5nL2luZGV4LmQudHNgLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0T3duaW5nUGFja2FnZVJlbGF0aXZlUGF0aChmaWxlOiBCYXplbEZpbGVJbmZvKTogc3RyaW5nIHtcbiAgICByZXR1cm4gcGF0aC5yZWxhdGl2ZShvd25pbmdQYWNrYWdlTmFtZSwgZmlsZS5zaG9ydFBhdGgpO1xuICB9XG5cbiAgLyoqIFdyaXRlcyBhbiBFU00gZmlsZSBpbnRvIHRoZSBgZXNtMjAyMmAgb3V0cHV0IGRpcmVjdG9yeS4gKi9cbiAgZnVuY3Rpb24gd3JpdGVFc20yMDIyRmlsZShmaWxlOiBCYXplbEZpbGVJbmZvKSB7XG4gICAgLy8gTm90ZTogZmlsZXMgd2hpY2ggZG8gbm90IGJlbG9uZyB0byB0aGUgb3duaW5nIHBhY2thZ2Ugb2YgdGhpcyBgbmdfcGFja2FnZWAgYXJlIG9taXR0ZWQuXG4gICAgLy8gdGhpcyBwcmV2ZW50cyB1cyBmcm9tIGFjY2lkZW50YWxseSBicmluZ2luZyBpbiB0cmFuc2l0aXZlIG5vZGUgbW9kdWxlIGRlcGVuZGVuY2llcy5cbiAgICBjb25zdCBwYWNrYWdlUmVsYXRpdmVQYXRoID0gZ2V0T3duaW5nUGFja2FnZVJlbGF0aXZlUGF0aChmaWxlKTtcbiAgICBpZiAoIXBhY2thZ2VSZWxhdGl2ZVBhdGguc3RhcnRzV2l0aCgnLi4nKSkge1xuICAgICAgY29weUZpbGUoZmlsZS5wYXRoLCBnZXRFc20yMDIyT3V0cHV0UmVsYXRpdmVQYXRoKGZpbGUpKTtcbiAgICB9XG4gIH1cblxuICAvKiogR2V0cyB0aGUgb3V0cHV0LXJlbGF0aXZlIHBhdGggd2hlcmUgdGhlIGdpdmVuIGZsYXQgRVNNIGZpbGUgc2hvdWxkIGJlIHdyaXR0ZW4gdG8uICovXG4gIGZ1bmN0aW9uIGdldEZsYXRFc21PdXRwdXRSZWxhdGl2ZVBhdGgoZmlsZTogQmF6ZWxGaWxlSW5mbykge1xuICAgIC8vIEZsYXQgRVNNIGZpbGVzIHNob3VsZCBiZSBwdXQgaW50byB0aGVpciBvd25pbmcgcGFja2FnZSByZWxhdGl2ZSBzdWItcGF0aC4gZS5nLiBpZlxuICAgIC8vIHRoZXJlIGlzIGEgYnVuZGxlIGluIGBwYWNrYWdlcy9hbmltYXRpb25zL2Zlc20yMDIyL2Jyb3dzZXIvdGVzdGluZy5tanNgIHRoZW4gd2VcbiAgICAvLyB3YW50IHRoZSBidW5kbGUgdG8gYmUgc3RvcmVkIGluIGBmZXNtMjAyMi9icm93c2VyL3Rlc3RpbmcubWpzYC4gU2FtZSB0aGluZyBhcHBsaWVzXG4gICAgLy8gZm9yIHRoZSBgZmVzbTIwMjJgIGJ1bmRsZXMuIFRoZSBkaXJlY3RvcnkgbmFtZSBmb3IgYGZlc21gIGlzIGFscmVhZHkgZGVjbGFyZWQgYXNcbiAgICAvLyBwYXJ0IG9mIHRoZSBCYXplbCBhY3Rpb24gZ2VuZXJhdGluZyB0aGVzZSBmaWxlcy4gU2VlIGBuZ19wYWNrYWdlLmJ6bGAuXG4gICAgcmV0dXJuIGdldE93bmluZ1BhY2thZ2VSZWxhdGl2ZVBhdGgoZmlsZSk7XG4gIH1cblxuICAvKiogR2V0cyB0aGUgb3V0cHV0LXJlbGF0aXZlIHBhdGggd2hlcmUgYSBub24tZmxhdCBFU00yMDIyIGZpbGUgc2hvdWxkIGJlIHdyaXR0ZW4gdG8uICovXG4gIGZ1bmN0aW9uIGdldEVzbTIwMjJPdXRwdXRSZWxhdGl2ZVBhdGgoZmlsZTogQmF6ZWxGaWxlSW5mbykge1xuICAgIC8vIFBhdGggY29tcHV0ZWQgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcGFja2FnZSBpbiBiYXplbC1iaW4uIGUuZy4gYSBFUzIwMjIgb3V0cHV0IGZpbGVcbiAgICAvLyBpbiBgYmF6ZWwtb3V0LzwuLj4vcGFja2FnZXMvY29yZS9zcmMvZGkubWpzYCBzaG91bGQgYmUgc3RvcmVkIGluIGBlc20yMDIyL3NyYy9kaS5tanNgLlxuICAgIHJldHVybiBwYXRoLmpvaW4oJ2VzbTIwMjInLCBnZXRPd25pbmdQYWNrYWdlUmVsYXRpdmVQYXRoKGZpbGUpKTtcbiAgfVxuXG4gIC8qKiBHZXRzIHRoZSBvdXRwdXQtcmVsYXRpdmUgcGF0aCB3aGVyZSB0aGUgdHlwaW5nIGZpbGUgaXMgYmVpbmcgd3JpdHRlbiB0by4gKi9cbiAgZnVuY3Rpb24gZ2V0VHlwaW5nT3V0cHV0UmVsYXRpdmVQYXRoKGZpbGU6IEJhemVsRmlsZUluZm8pIHtcbiAgICAvLyBUeXBlIGRlZmluaXRpb25zIGFyZSBpbnRlbmRlZCB0byBiZSBjb3BpZWQgaW50byB0aGUgcGFja2FnZSBvdXRwdXQgd2hpbGUgcHJlc2VydmluZyB0aGVcbiAgICAvLyBzdWItcGF0aCBmcm9tIHRoZSBvd25pbmcgcGFja2FnZS4gZS5nLiBhIGZpbGUgbGlrZSBgcGFja2FnZXMvYW5pbWF0aW9ucy9icm93c2VyL19faW5kZXguZC50c2BcbiAgICAvLyB3aWxsIGVuZCB1cCBiZWluZyB3cml0dGVuIHRvIGA8cGtnLW91dD4vYnJvd3Nlci9pbmRleC5kLnRzYC4gTm90ZSB0aGF0IHR5cGVzIGFyZSBidW5kbGVkXG4gICAgLy8gYXMgYSBzZXBhcmF0ZSBhY3Rpb24gaW4gdGhlIGBuZ19wYWNrYWdlYCBTdGFybGFyayBydWxlIGFuZCBwcmVmaXhlZCB3aXRoIGBfX2AgdG8gYXZvaWRcbiAgICAvLyBjb25mbGljdHMgd2l0aCBzb3VyY2UgYGluZGV4LmQudHNgIGZpbGVzLiBXZSByZW1vdmUgdGhpcyBwcmVmaXggaGVyZS5cbiAgICByZXR1cm4gZ2V0T3duaW5nUGFja2FnZVJlbGF0aXZlUGF0aChmaWxlKS5yZXBsYWNlKC9fX2luZGV4XFwuZFxcLnRzJC8sICdpbmRleC5kLnRzJyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgZW50cnktcG9pbnQgc3ViLXBhdGggZnJvbSB0aGUgcGFja2FnZSByb290LiBlLmcuIGlmIHRoZSBwYWNrYWdlIG5hbWVcbiAgICogaXMgYEBhbmd1bGFyL2Nka2AsIHRoZW4gZm9yIGBAYW5ndWxhci9jZGsvYTExeWAganVzdCBgYTExeWAgd291bGQgYmUgcmV0dXJuZWQuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRFbnRyeVBvaW50U3VicGF0aChtb2R1bGVOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBtb2R1bGVOYW1lLnNsaWNlKGAke21ldGFkYXRhLm5wbVBhY2thZ2VOYW1lfS9gLmxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB3aGV0aGVyIHRoZSBnaXZlbiBtb2R1bGUgbmFtZSByZXNvbHZlcyB0byBhIHNlY29uZGFyeSBlbnRyeS1wb2ludC5cbiAgICogZS5nLiBpZiB0aGUgcGFja2FnZSBuYW1lIGlzIGBAYW5ndWxhci9jZGtgLCB0aGVuIGZvciBgQGFuZ3VsYXIvY2RrL2ExMXlgXG4gICAqIHRoaXMgd291bGQgcmV0dXJuIGB0cnVlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGlzU2Vjb25kYXJ5RW50cnlQb2ludChtb2R1bGVOYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZ2V0RW50cnlQb2ludFN1YnBhdGgobW9kdWxlTmFtZSkgIT09ICcnO1xuICB9XG5cbiAgY29uc3QgY3Jvc3NFbnRyeVBvaW50RmFpbHVyZXM6IHN0cmluZ1tdID0gW107XG5cbiAgZXNtMjAyMi5mb3JFYWNoKChmaWxlKSA9PiB7XG4gICAgY3Jvc3NFbnRyeVBvaW50RmFpbHVyZXMucHVzaCguLi5hbmFseXplRmlsZUFuZEVuc3VyZU5vQ3Jvc3NJbXBvcnRzKGZpbGUsIG1ldGFkYXRhKSk7XG4gICAgd3JpdGVFc20yMDIyRmlsZShmaWxlKTtcbiAgfSk7XG5cbiAgaWYgKGNyb3NzRW50cnlQb2ludEZhaWx1cmVzLmxlbmd0aCkge1xuICAgIGNvbnNvbGUuZXJyb3IoY3Jvc3NFbnRyeVBvaW50RmFpbHVyZXMpO1xuICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgfVxuXG4gIC8vIENvcHkgYWxsIEZFU00gZmlsZXMgaW50byB0aGUgcGFja2FnZSBvdXRwdXQuXG4gIGZlc20yMDIyLmZvckVhY2goKGYpID0+IGNvcHlGaWxlKGYucGF0aCwgZ2V0RmxhdEVzbU91dHB1dFJlbGF0aXZlUGF0aChmKSkpO1xuXG4gIC8vIENvcHkgYWxsIHR5cGUgZGVmaW5pdGlvbnMgaW50byB0aGUgcGFja2FnZSwgcHJlc2VydmluZyB0aGUgc3ViLXBhdGggZnJvbSB0aGVcbiAgLy8gb3duaW5nIHBhY2thZ2UuIGUuZy4gYSBmaWxlIGxpa2UgYHBhY2thZ2VzL2FuaW1hdGlvbnMvYnJvd3Nlci9fX2luZGV4LmQudHNgIHdpbGxcbiAgLy8gZW5kIHVwIGluIGBicm93c2VyL2luZGV4LmQudHNgXG4gIHR5cGVEZWZpbml0aW9ucy5mb3JFYWNoKChmKSA9PiBjb3B5RmlsZShmLnBhdGgsIGdldFR5cGluZ091dHB1dFJlbGF0aXZlUGF0aChmKSkpO1xuXG4gIGZvciAoY29uc3QgZmlsZSBvZiBzdGF0aWNGaWxlcykge1xuICAgIC8vIFdlIGNvcHkgYWxsIGZpbGVzIGludG8gdGhlIHBhY2thZ2Ugb3V0cHV0IHdoaWxlIHByZXNlcnZpbmcgdGhlIHN1Yi1wYXRoIGZyb21cbiAgICAvLyB0aGUgb3duaW5nIHBhY2thZ2UuIGUuZy4gYHBhY2thZ2VzL2NvcmUvcGFja2FnZS5qc29uYCBlbmRzIHVwIGA8cGtnLW91dD4vcGFja2FnZS5qc29uYC5cbiAgICBjb25zdCBvdXRwdXRSZWxhdGl2ZVBhdGggPSBnZXRPd25pbmdQYWNrYWdlUmVsYXRpdmVQYXRoKGZpbGUpO1xuICAgIGxldCBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKGZpbGUucGF0aCwgJ3V0ZjgnKTtcblxuICAgIC8vIENoZWNrIGFuZCBtb2RpZnkgcGFja2FnZS5qc29uIGZpbGVzIGFzIG5lY2Vzc2FyeSBmb3IgcHVibGlzaGluZ1xuICAgIGlmIChwYXRoLmJhc2VuYW1lKGZpbGUucGF0aCkgPT09ICdwYWNrYWdlLmpzb24nKSB7XG4gICAgICBjb25zdCBpc1ByaW1hcnlQYWNrYWdlSnNvbiA9IG91dHB1dFJlbGF0aXZlUGF0aCA9PT0gJ3BhY2thZ2UuanNvbic7XG4gICAgICBjb25zdCBwYWNrYWdlSnNvbiA9IEpTT04ucGFyc2UoY29udGVudCkgYXMgUGFja2FnZUpzb247XG4gICAgICBjb25zdCBwYWNrYWdlTmFtZSA9IHBhY2thZ2VKc29uWyduYW1lJ107XG5cbiAgICAgIC8vIFByZXZlbnQgbm9uLXByaW1hcnkgYHBhY2thZ2UuanNvbmAgZmlsZXMgd2hpY2ggd291bGQgdGhyb3ctb2ZmIHJlc29sdXRpb24uXG4gICAgICAvLyBSZXNvbHV0aW9uIGluIHRoZSBwYWNrYWdlIHNob3VsZCBvbmx5IGJlIGJhc2VkIG9uIHRoZSB0b3AtbGV2ZWwgYHBhY2thZ2UuanNvbmAuXG4gICAgICBpZiAoIWlzUHJpbWFyeVBhY2thZ2VKc29uKSB7XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIGBGb3VuZCBhIG5lc3RlZCBcInBhY2thZ2UuanNvblwiIGZpbGUgaW4gdGhlIHBhY2thZ2Ugb3V0cHV0OiAke2ZpbGUuc2hvcnRQYXRofS5cXG5gICtcbiAgICAgICAgICAgIGBBbGwgaW5mb3JtYXRpb24gb2YgdGhlIHBhY2thZ2Ugc2hvdWxkIHJlc2lkZSBpbiB0aGUgcHJpbWFyeSBwYWNrYWdlIGZpbGUuYCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGBuYW1lYCBmaWVsZCBvZiB0aGUgYHBhY2thZ2UuanNvbmAgZmlsZXMgYXJlIG1hdGNoaW5nIHdpdGhcbiAgICAgIC8vIG5hbWUgb2YgdGhlIE5QTSBwYWNrYWdlLiBUaGlzIGlzIGFuIGFkZGl0aW9uYWwgc2FmZXR5IGNoZWNrLlxuICAgICAgaWYgKHBhY2thZ2VOYW1lICE9PSBtZXRhZGF0YS5ucG1QYWNrYWdlTmFtZSkge1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBgUHJpbWFyeSBcInBhY2thZ2UuanNvblwiIGhhcyBtaXNtYXRjaGluZyBwYWNrYWdlIG5hbWUuIEV4cGVjdGVkIHRoZSBgICtcbiAgICAgICAgICAgIGBwYWNrYWdlIHRvIGJlIG5hbWVkIFwiJHttZXRhZGF0YS5ucG1QYWNrYWdlTmFtZX1cIiwgYnV0IGlzIHNldCB0bzogJHtwYWNrYWdlTmFtZX0uYCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgbGV0IG5ld1BhY2thZ2VKc29uID0gaW5zZXJ0Rm9ybWF0RmllbGRzSW50b1BhY2thZ2VKc29uKFxuICAgICAgICBvdXRwdXRSZWxhdGl2ZVBhdGgsXG4gICAgICAgIHBhY2thZ2VKc29uLFxuICAgICAgICBmYWxzZSxcbiAgICAgICk7XG5cbiAgICAgIG5ld1BhY2thZ2VKc29uID0gdXBkYXRlUHJpbWFyeVBhY2thZ2VKc29uKG5ld1BhY2thZ2VKc29uKTtcblxuICAgICAgLy8gVXBkYXRlIHRoZSBjb250ZW50IHdpdGggdGhlIG5ldyBgcGFja2FnZS5qc29uYCBmaWxlIGNvbnRlbnQuXG4gICAgICBjb250ZW50ID0gSlNPTi5zdHJpbmdpZnkobmV3UGFja2FnZUpzb24sIG51bGwsIDIpO1xuICAgIH1cblxuICAgIHdyaXRlRmlsZShvdXRwdXRSZWxhdGl2ZVBhdGgsIGNvbnRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgb3IgZWRpdHMgcHJvcGVydGllcyBpbnRvIHRoZSBwYWNrYWdlLmpzb24gZmlsZShzKSBpbiB0aGUgcGFja2FnZSBzbyB0aGF0XG4gICAqIHRoZXkgcG9pbnQgdG8gYWxsIHRoZSByaWdodCBnZW5lcmF0ZWQgYXJ0aWZhY3RzLlxuICAgKlxuICAgKiBAcGFyYW0gcGFja2FnZUpzb25PdXRSZWxhdGl2ZVBhdGggUGF0aCB3aGVyZSB0aGUgYHBhY2thZ2UuanNvbmAgaXMgc3RvcmVkIGluXG4gICAqICAgdGhlIHBhY2thZ2Ugb3V0cHV0LlxuICAgKiBAcGFyYW0gcGFyc2VkUGFja2FnZSBQYXJzZWQgcGFja2FnZS5qc29uIGNvbnRlbnRcbiAgICogQHBhcmFtIGlzR2VuZXJhdGVkUGFja2FnZUpzb24gV2hldGhlciB0aGUgcGFzc2VkIHBhY2thZ2UuanNvbiBoYXMgYmVlbiBnZW5lcmF0ZWQuXG4gICAqL1xuICBmdW5jdGlvbiBpbnNlcnRGb3JtYXRGaWVsZHNJbnRvUGFja2FnZUpzb24oXG4gICAgcGFja2FnZUpzb25PdXRSZWxhdGl2ZVBhdGg6IHN0cmluZyxcbiAgICBwYXJzZWRQYWNrYWdlOiBSZWFkb25seTxQYWNrYWdlSnNvbj4sXG4gICAgaXNHZW5lcmF0ZWRQYWNrYWdlSnNvbjogYm9vbGVhbixcbiAgKTogUGFja2FnZUpzb24ge1xuICAgIGNvbnN0IHBhY2thZ2VKc29uOiBQYWNrYWdlSnNvbiA9IHsuLi5wYXJzZWRQYWNrYWdlfTtcbiAgICBjb25zdCBwYWNrYWdlTmFtZSA9IHBhY2thZ2VKc29uWyduYW1lJ107XG4gICAgY29uc3QgZW50cnlQb2ludEluZm8gPSBtZXRhZGF0YS5lbnRyeVBvaW50c1twYWNrYWdlTmFtZV07XG4gICAgY29uc3QgcGFja2FnZUpzb25Db250YWluaW5nRGlyID0gcGF0aC5kaXJuYW1lKHBhY2thZ2VKc29uT3V0UmVsYXRpdmVQYXRoKTtcblxuICAgIC8vIElmIGEgcGFja2FnZSBqc29uIGZpbGUgaGFzIGJlZW4gZGlzY292ZXJlZCB0aGF0IGRvZXMgbm90IG1hdGNoIGFueVxuICAgIC8vIGVudHJ5LXBvaW50IGluIHRoZSBtZXRhZGF0YSwgd2UgcmVwb3J0IGEgd2FybmluZyBhcyBtb3N0IGxpa2VseSB0aGUgdGFyZ2V0XG4gICAgLy8gaXMgY29uZmlndXJlZCBpbmNvcnJlY3RseSAoZS5nLiBtaXNzaW5nIGBtb2R1bGVfbmFtZWAgYXR0cmlidXRlKS5cbiAgICBpZiAoIWVudHJ5UG9pbnRJbmZvKSB7XG4gICAgICAvLyBJZGVhbGx5IHdlIHNob3VsZCB0aHJvdyBoZXJlLCBhcyB3ZSBnb3QgYW4gZW50cnkgcG9pbnQgdGhhdCBkb2Vzbid0XG4gICAgICAvLyBoYXZlIGZsYXQgbW9kdWxlIG1ldGFkYXRhIC8gYnVuZGxlIGluZGV4LCBzbyBpdCBtYXkgaGF2ZSBiZWVuIGFuXG4gICAgICAvLyBuZ19tb2R1bGUgdGhhdCdzIG1pc3NpbmcgYSBtb2R1bGVfbmFtZSBhdHRyaWJ1dGUuXG4gICAgICAvLyBIb3dldmVyLCBAYW5ndWxhci9jb21waWxlciBjYW4ndCBiZSBhbiBuZ19tb2R1bGUsIGFzIGl0J3MgdGhlIGludGVybmFsc1xuICAgICAgLy8gb2YgdGhlIG5nYyBjb21waWxlciwgeWV0IHdlIHdhbnQgdG8gYnVpbGQgYW4gbmdfcGFja2FnZSBmb3IgaXQuXG4gICAgICAvLyBTbyBpZ25vcmUgcGFja2FnZS5qc29uIGZpbGVzIHdoZW4gd2UgYXJlIG1pc3NpbmcgZGF0YS5cbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1dBUk5JTkc6IG5vIG1vZHVsZSBtZXRhZGF0YSBmb3IgcGFja2FnZScsIHBhY2thZ2VOYW1lKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyAgIE5vdCB1cGRhdGluZyB0aGUgcGFja2FnZS5qc29uIGZpbGUgdG8gcG9pbnQgdG8gaXQnKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICcgICBUaGUgbmdfbW9kdWxlIGZvciB0aGlzIHBhY2thZ2UgaXMgcG9zc2libHkgbWlzc2luZyB0aGUgbW9kdWxlX25hbWUgYXR0cmlidXRlICcsXG4gICAgICApO1xuICAgICAgcmV0dXJuIHBhY2thZ2VKc29uO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGd1ZXNzZWQgdGhlIGluZGV4IHBhdGhzIGZvciBhIG1vZHVsZSwgYW5kIGl0IGNvbnRhaW5zIGFuIGV4cGxpY2l0IGBwYWNrYWdlLmpzb25gXG4gICAgLy8gZmlsZSB0aGF0IGFscmVhZHkgc2V0cyBmb3JtYXQgcHJvcGVydGllcywgd2Ugc2tpcCBhdXRvbWF0aWMgaW5zZXJ0aW9uIG9mIGZvcm1hdFxuICAgIC8vIHByb3BlcnRpZXMgYnV0IHJlcG9ydCBhIHdhcm5pbmcgaW4gY2FzZSBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBzZXQgYnkgYWNjaWRlbnQuXG4gICAgaWYgKFxuICAgICAgZW50cnlQb2ludEluZm8uZ3Vlc3NlZFBhdGhzICYmXG4gICAgICAhaXNHZW5lcmF0ZWRQYWNrYWdlSnNvbiAmJlxuICAgICAgaGFzRXhwbGljaXRGb3JtYXRQcm9wZXJ0aWVzKHBhY2thZ2VKc29uKVxuICAgICkge1xuICAgICAgY29uc29sZS5lcnJvcignV0FSTklORzogYHBhY2thZ2UuanNvbmAgZXhwbGljaXRseSBzZXRzIGZvcm1hdCBwcm9wZXJ0aWVzIChsaWtlIGBtYWluYCkuJyk7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAnICAgIFNraXBwaW5nIGF1dG9tYXRpYyBpbnNlcnRpb24gb2YgZm9ybWF0IHByb3BlcnRpZXMgYXMgZXhwbGljaXQgJyArXG4gICAgICAgICAgJ2Zvcm1hdCBwcm9wZXJ0aWVzIGFyZSBzZXQuJyxcbiAgICAgICk7XG4gICAgICBjb25zb2xlLmVycm9yKCcgICAgSWdub3JlIHRoaXMgd2FybmluZyBpZiBleHBsaWNpdCBwcm9wZXJ0aWVzIGFyZSBzZXQgaW50ZW50aW9uYWxseS4nKTtcbiAgICAgIHJldHVybiBwYWNrYWdlSnNvbjtcbiAgICB9XG5cbiAgICBjb25zdCBmZXNtMjAyMlJlbGF0aXZlT3V0UGF0aCA9IGdldEZsYXRFc21PdXRwdXRSZWxhdGl2ZVBhdGgoZW50cnlQb2ludEluZm8uZmVzbTIwMjJCdW5kbGUpO1xuICAgIGNvbnN0IHR5cGluZ3NSZWxhdGl2ZU91dFBhdGggPSBnZXRUeXBpbmdPdXRwdXRSZWxhdGl2ZVBhdGgoZW50cnlQb2ludEluZm8udHlwaW5ncyk7XG5cbiAgICBwYWNrYWdlSnNvbi5tb2R1bGUgPSBub3JtYWxpemVQYXRoKFxuICAgICAgcGF0aC5yZWxhdGl2ZShwYWNrYWdlSnNvbkNvbnRhaW5pbmdEaXIsIGZlc20yMDIyUmVsYXRpdmVPdXRQYXRoKSxcbiAgICApO1xuICAgIHBhY2thZ2VKc29uLnR5cGluZ3MgPSBub3JtYWxpemVQYXRoKFxuICAgICAgcGF0aC5yZWxhdGl2ZShwYWNrYWdlSnNvbkNvbnRhaW5pbmdEaXIsIHR5cGluZ3NSZWxhdGl2ZU91dFBhdGgpLFxuICAgICk7XG5cbiAgICByZXR1cm4gcGFja2FnZUpzb247XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcHJpbWFyeSBgcGFja2FnZS5qc29uYCBmaWxlIG9mIHRoZSBOUE0gcGFja2FnZSB0byBzcGVjaWZ5XG4gICAqIHRoZSBtb2R1bGUgY29uZGl0aW9uYWwgZXhwb3J0cyBhbmQgdGhlIEVTTSBtb2R1bGUgdHlwZS5cbiAgICovXG4gIGZ1bmN0aW9uIHVwZGF0ZVByaW1hcnlQYWNrYWdlSnNvbihwYWNrYWdlSnNvbjogUmVhZG9ubHk8UGFja2FnZUpzb24+KTogUGFja2FnZUpzb24ge1xuICAgIGlmIChwYWNrYWdlSnNvbi50eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAnVGhlIHByaW1hcnkgXCJwYWNrYWdlLmpzb25cIiBmaWxlIG9mIHRoZSBwYWNrYWdlIHNldHMgdGhlIFwidHlwZVwiIGZpZWxkICcgK1xuICAgICAgICAgICd0aGF0IGlzIGNvbnRyb2xsZWQgYnkgdGhlIHBhY2thZ2VyLiBQbGVhc2UgdW5zZXQgaXQuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgbmV3UGFja2FnZUpzb246IFBhY2thZ2VKc29uID0gey4uLnBhY2thZ2VKc29ufTtcblxuICAgIG5ld1BhY2thZ2VKc29uLnR5cGUgPSAnbW9kdWxlJztcblxuICAgIC8vIFRoZSBgcGFja2FnZS5qc29uYCBmaWxlIGlzIG1hZGUgcHVibGljbHkgYWNjZXNzaWJsZSBmb3IgdG9vbHMgdGhhdFxuICAgIC8vIG1pZ2h0IHdhbnQgdG8gcXVlcnkgaW5mb3JtYXRpb24gZnJvbSB0aGUgQW5ndWxhciBOUE0gcGFja2FnZS5cbiAgICBpbnNlcnRFeHBvcnRNYXBwaW5nT3JFcnJvcihuZXdQYWNrYWdlSnNvbiwgJy4vcGFja2FnZS5qc29uJywge2RlZmF1bHQ6ICcuL3BhY2thZ2UuanNvbid9KTtcblxuICAgIC8vIENhcHR1cmUgYWxsIGVudHJ5LXBvaW50cyBpbiB0aGUgYGV4cG9ydHNgIGZpZWxkIHVzaW5nIHRoZSBzdWJwYXRoIGV4cG9ydCBkZWNsYXJhdGlvbnM6XG4gICAgLy8gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9wYWNrYWdlcy5odG1sI3BhY2thZ2VzX3N1YnBhdGhfZXhwb3J0cy5cbiAgICBmb3IgKGNvbnN0IFttb2R1bGVOYW1lLCBlbnRyeVBvaW50XSBvZiBPYmplY3QuZW50cmllcyhtZXRhZGF0YS5lbnRyeVBvaW50cykpIHtcbiAgICAgIGNvbnN0IHN1YnBhdGggPSBpc1NlY29uZGFyeUVudHJ5UG9pbnQobW9kdWxlTmFtZSlcbiAgICAgICAgPyBgLi8ke2dldEVudHJ5UG9pbnRTdWJwYXRoKG1vZHVsZU5hbWUpfWBcbiAgICAgICAgOiAnLic7XG4gICAgICBjb25zdCBlc21JbmRleE91dFJlbGF0aXZlUGF0aCA9IGdldEVzbTIwMjJPdXRwdXRSZWxhdGl2ZVBhdGgoZW50cnlQb2ludC5pbmRleCk7XG4gICAgICBjb25zdCBmZXNtMjAyMk91dFJlbGF0aXZlUGF0aCA9IGdldEZsYXRFc21PdXRwdXRSZWxhdGl2ZVBhdGgoZW50cnlQb2ludC5mZXNtMjAyMkJ1bmRsZSk7XG4gICAgICBjb25zdCB0eXBlc091dFJlbGF0aXZlUGF0aCA9IGdldFR5cGluZ091dHB1dFJlbGF0aXZlUGF0aChlbnRyeVBvaW50LnR5cGluZ3MpO1xuXG4gICAgICAvLyBJbnNlcnQgdGhlIGV4cG9ydCBtYXBwaW5nIGZvciB0aGUgZW50cnktcG9pbnQuIFdlIHNldCBgZGVmYXVsdGAgdG8gdGhlIEZFU00gMjAyMlxuICAgICAgLy8gb3V0cHV0LCBhbmQgYWxzbyBzZXQgdGhlIGB0eXBlc2AgY29uZGl0aW9uIHdoaWNoIHdpbGwgYmUgcmVzcGVjdGVkIGJ5IFRTIDQuNS5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9wdWxsLzQ1ODg0LlxuICAgICAgaW5zZXJ0RXhwb3J0TWFwcGluZ09yRXJyb3IobmV3UGFja2FnZUpzb24sIHN1YnBhdGgsIHtcbiAgICAgICAgdHlwZXM6IG5vcm1hbGl6ZVBhdGgodHlwZXNPdXRSZWxhdGl2ZVBhdGgpLFxuICAgICAgICBlc20yMDIyOiBub3JtYWxpemVQYXRoKGVzbUluZGV4T3V0UmVsYXRpdmVQYXRoKSxcbiAgICAgICAgZXNtOiBub3JtYWxpemVQYXRoKGVzbUluZGV4T3V0UmVsYXRpdmVQYXRoKSxcbiAgICAgICAgLy8gTm90ZTogVGhlIGRlZmF1bHQgY29uZGl0aW9ucyBuZWVkcyB0byBiZSB0aGUgbGFzdCBvbmUuXG4gICAgICAgIGRlZmF1bHQ6IG5vcm1hbGl6ZVBhdGgoZmVzbTIwMjJPdXRSZWxhdGl2ZVBhdGgpLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1BhY2thZ2VKc29uO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgYSBzdWJwYXRoIGV4cG9ydCBtYXBwaW5nIGludG8gdGhlIHNwZWNpZmllZCBgcGFja2FnZS5qc29uYCBvYmplY3QuXG4gICAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIG1hcHBpbmcgaXMgYWxyZWFkeSBkZWZpbmVkIGFuZCB3b3VsZCBjb25mbGljdC5cbiAgICovXG4gIGZ1bmN0aW9uIGluc2VydEV4cG9ydE1hcHBpbmdPckVycm9yKFxuICAgIHBhY2thZ2VKc29uOiBQYWNrYWdlSnNvbixcbiAgICBzdWJwYXRoOiBzdHJpbmcsXG4gICAgbWFwcGluZzogQ29uZGl0aW9uYWxFeHBvcnQsXG4gICkge1xuICAgIGlmIChwYWNrYWdlSnNvbi5leHBvcnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhY2thZ2VKc29uLmV4cG9ydHMgPSB7fTtcbiAgICB9XG4gICAgaWYgKHBhY2thZ2VKc29uLmV4cG9ydHNbc3VicGF0aF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcGFja2FnZUpzb24uZXhwb3J0c1tzdWJwYXRoXSA9IHt9O1xuICAgIH1cblxuICAgIGNvbnN0IHN1YnBhdGhFeHBvcnQgPSBwYWNrYWdlSnNvbi5leHBvcnRzW3N1YnBhdGhdO1xuXG4gICAgLy8gR28gdGhyb3VnaCBhbGwgY29uZGl0aW9ucyB0aGF0IHNob3VsZCBiZSBpbnNlcnRlZC4gSWYgdGhlIGNvbmRpdGlvbiBpcyBhbHJlYWR5XG4gICAgLy8gbWFudWFsbHkgc2V0IG9mIHRoZSBzdWJwYXRoIGV4cG9ydCwgd2UgdGhyb3cgYW4gZXJyb3IuIEluIGdlbmVyYWwsIHdlIGFsbG93IGZvclxuICAgIC8vIGFkZGl0aW9uYWwgY29uZGl0aW9ucyB0byBiZSBzZXQuIFRoZXNlIHdpbGwgYWx3YXlzIHByZWNlZGUgdGhlIGdlbmVyYXRlZCBvbmVzLlxuICAgIGZvciAoY29uc3QgY29uZGl0aW9uTmFtZSBvZiBPYmplY3Qua2V5cyhtYXBwaW5nKSBhcyBba2V5b2YgQ29uZGl0aW9uYWxFeHBvcnRdKSB7XG4gICAgICBpZiAoc3VicGF0aEV4cG9ydFtjb25kaXRpb25OYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIGBGb3VuZCBhIGNvbmZsaWN0aW5nIGV4cG9ydCBjb25kaXRpb24gZm9yIFwiJHtzdWJwYXRofVwiLiBUaGUgXCIke2NvbmRpdGlvbk5hbWV9XCIgYCArXG4gICAgICAgICAgICBgY29uZGl0aW9uIHdvdWxkIGJlIG92ZXJyaWRkZW4gYnkgdGhlIHBhY2thZ2VyLiBQbGVhc2UgdW5zZXQgaXQuYCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gKipOb3RlKio6IFRoZSBvcmRlciBvZiB0aGUgY29uZGl0aW9ucyBpcyBwcmVzZXJ2ZWQgZXZlbiB0aG91Z2ggd2UgYXJlIHNldHRpbmdcbiAgICAgIC8vIHRoZSBjb25kaXRpb25zIG9uY2UgYXQgYSB0aW1lICh0aGUgbGF0ZXN0IGFzc2lnbm1lbnQgd2lsbCBiZSBhdCB0aGUgZW5kKS5cbiAgICAgIHN1YnBhdGhFeHBvcnRbY29uZGl0aW9uTmFtZV0gPSBtYXBwaW5nW2NvbmRpdGlvbk5hbWVdO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBXaGV0aGVyIHRoZSBwYWNrYWdlIGV4cGxpY2l0bHkgc2V0cyBhbnkgb2YgdGhlIGZvcm1hdCBwcm9wZXJ0aWVzIChsaWtlIGBtYWluYCkuICovXG4gIGZ1bmN0aW9uIGhhc0V4cGxpY2l0Rm9ybWF0UHJvcGVydGllcyhwYXJzZWRQYWNrYWdlOiBSZWFkb25seTxQYWNrYWdlSnNvbj4pOiBib29sZWFuIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocGFyc2VkUGFja2FnZSkuc29tZSgoZmllbGROYW1lOiBzdHJpbmcpID0+XG4gICAgICBrbm93bkZvcm1hdFBhY2thZ2VKc29uRm9ybWF0RmllbGRzLmluY2x1ZGVzKGZpZWxkTmFtZSBhcyBLbm93blBhY2thZ2VKc29uRm9ybWF0RmllbGRzKSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZXMgdGhlIHNwZWNpZmllZCBwYXRoIGJ5IHJlcGxhY2luZyBiYWNrc2xhc2ggc2VwYXJhdG9ycyB3aXRoIFBvc2l4XG4gICAqIGZvcndhcmQgc2xhc2ggc2VwYXJhdG9ycy5cbiAgICovXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVBhdGgocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCByZXN1bHQgPSBwYXRoLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcbiAgICByZXR1cm4gcmVzdWx0LnN0YXJ0c1dpdGgoJy4nKSA/IHJlc3VsdCA6IGAuLyR7cmVzdWx0fWA7XG4gIH1cbn1cbiJdfQ==