/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
import * as fs from 'fs';
import * as path from 'path';
import { globSync } from 'tinyglobby';
import { analyzeFileAndEnsureNoCrossImports } from './cross_entry_points_imports';
/**
 * List of known `package.json` fields which provide information about
 * supported package formats and their associated entry paths.
 */
const knownFormatPackageJsonFormatFields = ['main', 'typings', 'module'];
// Main entry-point.
main(process.argv.slice(2));
function main(args) {
    // This utility expects all of its arguments to be specified in a params file generated by
    // bazel (see https://docs.bazel.build/versions/master/skylark/lib/Args.html#use_param_file).
    const paramFilePath = args[0];
    // Bazel params may be surrounded with quotes
    function unquoteParameter(s) {
        return s.replace(/^'(.*)'$/, '$1');
    }
    // Parameters are specified in the file one per line.
    const params = fs.readFileSync(paramFilePath, 'utf-8').split('\n').map(unquoteParameter);
    const [
    // Output directory for the npm package.
    outputDirExecPath, 
    // The package segment of the ng_package rule's label (e.g. 'package/common').
    owningPackageName, 
    // JSON data capturing metadata of the package being built. See `PackageMetadata`.
    metadataArg, 
    // Path to the package's README.md.
    readmeMd, 
    // Path to the package's LICENSE file.
    licenseFile, 
    // List of individual ES2022 modules
    esm2022Arg, 
    // List of static files that should be copied into the package.
    staticFilesArg, 
    // List of side-effectful entry-points
    sideEffectEntryPointsArg,] = params;
    const esm2022 = JSON.parse(esm2022Arg);
    const staticFiles = JSON.parse(staticFilesArg);
    const metadata = JSON.parse(metadataArg);
    const sideEffectEntryPoints = JSON.parse(sideEffectEntryPointsArg);
    if (readmeMd) {
        copyFile(readmeMd, 'README.md');
    }
    if (licenseFile) {
        copyFile(licenseFile, 'LICENSE');
    }
    /**
     * Writes a file with the specified content into the package output.
     * @param outputRelativePath Relative path in the output directory where the
     *   file is written to.
     * @param fileContent Content of the file.
     */
    function writeFile(outputRelativePath, fileContent) {
        const outputPath = path.join(outputDirExecPath, outputRelativePath);
        // Always ensure that the target directory exists.
        fs.mkdirSync(path.dirname(outputPath), { recursive: true });
        fs.writeFileSync(outputPath, fileContent);
    }
    /**
     * Copies a file into the package output to the specified location.
     * @param inputPath File that should be copied.
     * @param outputRelativePath Relative path in the output directory where the
     *   file is written to.
     */
    function copyFile(inputPath, outputRelativePath) {
        const fileContent = fs.readFileSync(inputPath, 'utf8');
        writeFile(outputRelativePath, fileContent);
    }
    /**
     * Gets the relative path for the given file within the owning package. This
     * assumes the file is contained in the owning package.
     *
     * e.g. consider the owning package is `packages/core` and the input file
     * is `packages/core/testing/index.d.ts`. This function would return the
     * relative path as followed: `testing/index.d.ts`.
     */
    function getOwningPackageRelativePath(file) {
        return path.relative(owningPackageName, file.shortPath);
    }
    /**
     * Gets the entry-point sub-path from the package root. e.g. if the package name
     * is `@angular/cdk`, then for `@angular/cdk/a11y` just `a11y` would be returned.
     */
    function getEntryPointSubpath(moduleName) {
        return moduleName.slice(`${metadata.npmPackageName}/`.length);
    }
    /**
     * Gets whether the given module name resolves to a secondary entry-point.
     * e.g. if the package name is `@angular/cdk`, then for `@angular/cdk/a11y`
     * this would return `true`.
     */
    function isSecondaryEntryPoint(moduleName) {
        return getEntryPointSubpath(moduleName) !== '';
    }
    const crossEntryPointFailures = esm2022.flatMap((file) => analyzeFileAndEnsureNoCrossImports(file, metadata));
    if (crossEntryPointFailures.length) {
        console.error(crossEntryPointFailures);
        process.exit(1);
    }
    // Copy all FESM files (and their potential shared chunks) into the package output.
    const fesmFiles = globSync('**/*', { cwd: metadata.fesmBundlesOut.path });
    fesmFiles.forEach((f) => copyFile(path.join(metadata.fesmBundlesOut.path, f), path.join('fesm2022', f)));
    // Copy all dts files (and their potential shared chunks) into the package output.
    const dtsFiles = globSync('**/*', { cwd: metadata.dtsBundlesOut.path });
    dtsFiles.forEach((f) => 
    // TODO(devversion): Put all types under `/types/` folder. Breaking change in v20.
    copyFile(path.join(metadata.dtsBundlesOut.path, f), f));
    for (const file of staticFiles) {
        // We copy all files into the package output while preserving the sub-path from
        // the owning package. e.g. `packages/core/package.json` ends up `<pkg-out>/package.json`.
        const outputRelativePath = getOwningPackageRelativePath(file);
        let content = fs.readFileSync(file.path, 'utf8');
        // Check and modify package.json files as necessary for publishing
        if (path.basename(file.path) === 'package.json') {
            const isPrimaryPackageJson = outputRelativePath === 'package.json';
            const packageJson = JSON.parse(content);
            const packageName = packageJson['name'];
            // Prevent non-primary `package.json` files which would throw-off resolution.
            // Resolution in the package should only be based on the top-level `package.json`.
            if (!isPrimaryPackageJson) {
                throw Error(`Found a nested "package.json" file in the package output: ${file.shortPath}.\n` +
                    `All information of the package should reside in the primary package file.`);
            }
            // Check if the `name` field of the `package.json` files are matching with
            // name of the NPM package. This is an additional safety check.
            if (packageName !== metadata.npmPackageName) {
                throw Error(`Primary "package.json" has mismatching package name. Expected the ` +
                    `package to be named "${metadata.npmPackageName}", but is set to: ${packageName}.`);
            }
            let newPackageJson = insertFormatFieldsIntoPackageJson(outputRelativePath, packageJson, false);
            newPackageJson = updatePrimaryPackageJson(newPackageJson);
            // Update the content with the new `package.json` file content.
            content = JSON.stringify(newPackageJson, null, 2);
        }
        writeFile(outputRelativePath, content);
    }
    /**
     * Inserts or edits properties into the package.json file(s) in the package so that
     * they point to all the right generated artifacts.
     *
     * @param packageJsonOutRelativePath Path where the `package.json` is stored in
     *   the package output.
     * @param parsedPackage Parsed package.json content
     * @param isGeneratedPackageJson Whether the passed package.json has been generated.
     */
    function insertFormatFieldsIntoPackageJson(packageJsonOutRelativePath, parsedPackage, isGeneratedPackageJson) {
        const packageJson = { ...parsedPackage };
        const packageName = packageJson['name'];
        const entryPointInfo = metadata.entryPoints[packageName];
        const packageJsonContainingDir = path.dirname(packageJsonOutRelativePath);
        // If a package json file has been discovered that does not match any
        // entry-point in the metadata, we report a warning as most likely the target
        // is configured incorrectly (e.g. missing `module_name` attribute).
        if (!entryPointInfo) {
            // Ideally we should throw here, as we got an entry point that doesn't
            // have flat module metadata / bundle index, so it may have been an
            // ng_module that's missing a module_name attribute.
            // However, @angular/compiler can't be an ng_module, as it's the internals
            // of the ngc compiler, yet we want to build an ng_package for it.
            // So ignore package.json files when we are missing data.
            console.error('WARNING: no module metadata for package', packageName);
            console.error('   Not updating the package.json file to point to it');
            console.error('   The ng_module for this package is possibly missing the module_name attribute ');
            return packageJson;
        }
        // If we guessed the index paths for a module, and it contains an explicit `package.json`
        // file that already sets format properties, we skip automatic insertion of format
        // properties but report a warning in case properties have been set by accident.
        if (entryPointInfo.guessedPaths &&
            !isGeneratedPackageJson &&
            hasExplicitFormatProperties(packageJson)) {
            console.error('WARNING: `package.json` explicitly sets format properties (like `main`).');
            console.error('    Skipping automatic insertion of format properties as explicit ' +
                'format properties are set.');
            console.error('    Ignore this warning if explicit properties are set intentionally.');
            return packageJson;
        }
        const fesm2022RelativeOutPath = entryPointInfo.fesm2022RelativePath;
        const typingsRelativeOutPath = entryPointInfo.dtsBundleRelativePath;
        packageJson.module = normalizePath(path.relative(packageJsonContainingDir, fesm2022RelativeOutPath));
        packageJson.typings = normalizePath(path.relative(packageJsonContainingDir, typingsRelativeOutPath));
        return packageJson;
    }
    /**
     * Updates the primary `package.json` file of the NPM package to specify
     * the module conditional exports and the ESM module type.
     */
    function updatePrimaryPackageJson(packageJson) {
        if (packageJson.type !== undefined && packageJson.type !== 'module') {
            throw Error('The primary "package.json" file of the package sets the "type" field ' +
                'that is controlled by the packager. Please unset it or set `type` to `module`.');
        }
        const newPackageJson = { ...packageJson };
        newPackageJson.type = 'module';
        // The `package.json` file is made publicly accessible for tools that
        // might want to query information from the Angular NPM package.
        insertExportMappingOrError(newPackageJson, './package.json', { default: './package.json' });
        // Capture all entry-points in the `exports` field using the subpath export declarations:
        // https://nodejs.org/api/packages.html#packages_subpath_exports.
        for (const [moduleName, entryPoint] of Object.entries(metadata.entryPoints)) {
            const subpath = isSecondaryEntryPoint(moduleName)
                ? `./${getEntryPointSubpath(moduleName)}`
                : '.';
            const fesm2022OutRelativePath = entryPoint.fesm2022RelativePath;
            const typesOutRelativePath = entryPoint.dtsBundleRelativePath;
            // Insert the export mapping for the entry-point. We set `default` to the FESM 2022
            // output, and also set the `types` condition which will be respected by TS 4.5.
            // https://github.com/microsoft/TypeScript/pull/45884.
            insertExportMappingOrError(newPackageJson, subpath, {
                types: normalizePath(typesOutRelativePath),
                // Note: The default conditions needs to be the last one.
                default: normalizePath(fesm2022OutRelativePath),
            });
        }
        checkPackageJsonSideEffects(packageJson);
        return newPackageJson;
    }
    function checkPackageJsonSideEffects(packageJson) {
        // Convenience if there are no side effects, and it's explicitly marked.
        // This is okay and we don't ask the developer to drop the explicit field.
        if (packageJson.sideEffects === false && sideEffectEntryPoints.length === 0) {
            return;
        }
        if (packageJson.sideEffects === true) {
            throw Error('Unexpected `sideEffects` field in `package.json`. ' +
                'Side effects should be fine-grained and marked via the Bazel `side_effect_entry_points` option.');
        }
        const sideEffects = packageJson.sideEffects;
        const neededSideEffects = sideEffectEntryPoints.map((entryPointModule) => `./${metadata.entryPoints[entryPointModule].fesm2022RelativePath}`);
        const missingSideEffects = neededSideEffects.filter((p) => 
        // It's missing, if the whole package is marked as having no side effects.
        sideEffects === false ||
            // Alternatively, it's missing if the explicit list doesn't contain the pattern.
            !(sideEffects ?? []).includes(p));
        if (missingSideEffects.length > 0) {
            throw Error('Missing side effects in `package.json` `sideEffects` field. ' +
                'Please add the following side effect file patterns:\n' +
                missingSideEffects.join('\n - '));
        }
        // Find potential side-effects that refer to our FESM bundles, but aren't part
        // of the `ng_package` known entry points.
        const unexpectedExtra = sideEffects !== false
            ? (sideEffects ?? []).filter((p) => p.includes('fesm2022') && !neededSideEffects.includes(p))
            : [];
        if (unexpectedExtra.length > 0) {
            throw Error('Unexpected side effects in `package.json` `sideEffects` field that is not known to `ng_package`. ' +
                'Please add the side effect entry point to the Bazel `side_effect_entry_points` option. ' +
                'Unexpected patterns:\n' +
                unexpectedExtra.join('\n - '));
        }
    }
    /**
     * Inserts a subpath export mapping into the specified `package.json` object.
     * @throws An error if the mapping is already defined and would conflict.
     */
    function insertExportMappingOrError(packageJson, subpath, mapping) {
        if (packageJson.exports === undefined) {
            packageJson.exports = {};
        }
        if (packageJson.exports[subpath] === undefined) {
            packageJson.exports[subpath] = {};
        }
        const subpathExport = packageJson.exports[subpath];
        // Go through all conditions that should be inserted. If the condition is already
        // manually set of the subpath export, we throw an error. In general, we allow for
        // additional conditions to be set. These will always precede the generated ones.
        for (const conditionName of Object.keys(mapping)) {
            if (subpathExport[conditionName] !== undefined) {
                throw Error(`Found a conflicting export condition for "${subpath}". The "${conditionName}" ` +
                    `condition would be overridden by the packager. Please unset it.`);
            }
            // **Note**: The order of the conditions is preserved even though we are setting
            // the conditions once at a time (the latest assignment will be at the end).
            subpathExport[conditionName] = mapping[conditionName];
        }
    }
    /** Whether the package explicitly sets any of the format properties (like `main`). */
    function hasExplicitFormatProperties(parsedPackage) {
        return Object.keys(parsedPackage).some((fieldName) => knownFormatPackageJsonFormatFields.includes(fieldName));
    }
    /**
     * Normalizes the specified path by replacing backslash separators with Posix
     * forward slash separators.
     */
    function normalizePath(path) {
        const result = path.replace(/\\/g, '/');
        return result.startsWith('.') ? result : `./${result}`;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFja2FnZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9iYXplbC9zcmMvbmdfcGFja2FnZS9wYWNrYWdlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFFSCxPQUFPLEtBQUssRUFBRSxNQUFNLElBQUksQ0FBQztBQUN6QixPQUFPLEtBQUssSUFBSSxNQUFNLE1BQU0sQ0FBQztBQUM3QixPQUFPLEVBQUMsUUFBUSxFQUFDLE1BQU0sWUFBWSxDQUFDO0FBR3BDLE9BQU8sRUFBQyxrQ0FBa0MsRUFBQyxNQUFNLDhCQUE4QixDQUFDO0FBRWhGOzs7R0FHRztBQUNILE1BQU0sa0NBQWtDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsU0FBUyxFQUFFLFFBQVEsQ0FBVSxDQUFDO0FBd0JsRixvQkFBb0I7QUFDcEIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFFNUIsU0FBUyxJQUFJLENBQUMsSUFBYztJQUMxQiwwRkFBMEY7SUFDMUYsNkZBQTZGO0lBQzdGLE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUU5Qiw2Q0FBNkM7SUFDN0MsU0FBUyxnQkFBZ0IsQ0FBQyxDQUFTO1FBQ2pDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVELHFEQUFxRDtJQUNyRCxNQUFNLE1BQU0sR0FBRyxFQUFFLENBQUMsWUFBWSxDQUFDLGFBQWEsRUFBRSxPQUFPLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLENBQUM7SUFFekYsTUFBTTtJQUNKLHdDQUF3QztJQUN4QyxpQkFBaUI7SUFFakIsOEVBQThFO0lBQzlFLGlCQUFpQjtJQUVqQixrRkFBa0Y7SUFDbEYsV0FBVztJ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LE1BQU0sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsU0FBaUIsRUFBRSxFQUFFLENBQzNELGtDQUFrQyxDQUFDLFFBQVEsQ0FBQyxTQUF5QyxDQUFDLENBQ3ZGLENBQUM7SUFDSixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsU0FBUyxhQUFhLENBQUMsSUFBWTtRQUNqQyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztRQUN4QyxPQUFPLE1BQU0sQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxNQUFNLEVBQUUsQ0FBQztJQUN6RCxDQUFDO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmRldi9saWNlbnNlXG4gKi9cblxuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7Z2xvYlN5bmN9IGZyb20gJ3RpbnlnbG9iYnknO1xuXG5pbXBvcnQge0JhemVsRmlsZUluZm8sIFBhY2thZ2VNZXRhZGF0YX0gZnJvbSAnLi9hcGknO1xuaW1wb3J0IHthbmFseXplRmlsZUFuZEVuc3VyZU5vQ3Jvc3NJbXBvcnRzfSBmcm9tICcuL2Nyb3NzX2VudHJ5X3BvaW50c19pbXBvcnRzJztcblxuLyoqXG4gKiBMaXN0IG9mIGtub3duIGBwYWNrYWdlLmpzb25gIGZpZWxkcyB3aGljaCBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0XG4gKiBzdXBwb3J0ZWQgcGFja2FnZSBmb3JtYXRzIGFuZCB0aGVpciBhc3NvY2lhdGVkIGVudHJ5IHBhdGhzLlxuICovXG5jb25zdCBrbm93bkZvcm1hdFBhY2thZ2VKc29uRm9ybWF0RmllbGRzID0gWydtYWluJywgJ3R5cGluZ3MnLCAnbW9kdWxlJ10gYXMgY29uc3Q7XG5cbi8qKiBVbmlvbiB0eXBlIG1hdGNoaW5nIGtub3duIGBwYWNrYWdlLmpzb25gIGZvcm1hdCBmaWVsZHMuICovXG50eXBlIEtub3duUGFja2FnZUpzb25Gb3JtYXRGaWVsZHMgPSAodHlwZW9mIGtub3duRm9ybWF0UGFja2FnZUpzb25Gb3JtYXRGaWVsZHMpW251bWJlcl07XG5cbi8qKlxuICogVHlwZSBkZXNjcmliaW5nIHRoZSBjb25kaXRpb25hbCBleHBvcnRzIGRlc2NyaXB0b3IgZm9yIGFuIGVudHJ5LXBvaW50LlxuICogaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9wYWNrYWdlcy5odG1sI3BhY2thZ2VzX2NvbmRpdGlvbmFsX2V4cG9ydHNcbiAqL1xudHlwZSBDb25kaXRpb25hbEV4cG9ydCA9IHtcbiAgdHlwZXM/OiBzdHJpbmc7XG4gIGRlZmF1bHQ/OiBzdHJpbmc7XG59O1xuXG4vKiogVHlwZSBkZXNjcmliaW5nIGEgYHBhY2thZ2UuanNvbmAgdGhlIHBhY2thZ2VyIGRlYWxzIHdpdGguICovXG50eXBlIFBhY2thZ2VKc29uID0ge1xuICBba2V5IGluIEtub3duUGFja2FnZUpzb25Gb3JtYXRGaWVsZHNdPzogc3RyaW5nO1xufSAmIHtcbiAgbmFtZTogc3RyaW5nO1xuICB0eXBlPzogc3RyaW5nO1xuICBzaWRlRWZmZWN0cz86IHN0cmluZ1tdIHwgYm9vbGVhbjtcbiAgZXhwb3J0cz86IFJlY29yZDxzdHJpbmcsIENvbmRpdGlvbmFsRXhwb3J0Pjtcbn07XG5cbi8vIE1haW4gZW50cnktcG9pbnQuXG5tYWluKHByb2Nlc3MuYXJndi5zbGljZSgyKSk7XG5cbmZ1bmN0aW9uIG1haW4oYXJnczogc3RyaW5nW10pOiB2b2lkIHtcbiAgLy8gVGhpcyB1dGlsaXR5IGV4cGVjdHMgYWxsIG9mIGl0cyBhcmd1bWVudHMgdG8gYmUgc3BlY2lmaWVkIGluIGEgcGFyYW1zIGZpbGUgZ2VuZXJhdGVkIGJ5XG4gIC8vIGJhemVsIChzZWUgaHR0cHM6Ly9kb2NzLmJhemVsLmJ1aWxkL3ZlcnNpb25zL21hc3Rlci9za3lsYXJrL2xpYi9BcmdzLmh0bWwjdXNlX3BhcmFtX2ZpbGUpLlxuICBjb25zdCBwYXJhbUZpbGVQYXRoID0gYXJnc1swXTtcblxuICAvLyBCYXplbCBwYXJhbXMgbWF5IGJlIHN1cnJvdW5kZWQgd2l0aCBxdW90ZXNcbiAgZnVuY3Rpb24gdW5xdW90ZVBhcmFtZXRlcihzOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKC9eJyguKiknJC8sICckMScpO1xuICB9XG5cbiAgLy8gUGFyYW1ldGVycyBhcmUgc3BlY2lmaWVkIGluIHRoZSBmaWxlIG9uZSBwZXIgbGluZS5cbiAgY29uc3QgcGFyYW1zID0gZnMucmVhZEZpbGVTeW5jKHBhcmFtRmlsZVBhdGgsICd1dGYtOCcpLnNwbGl0KCdcXG4nKS5tYXAodW5xdW90ZVBhcmFtZXRlcik7XG5cbiAgY29uc3QgW1xuICAgIC8vIE91dHB1dCBkaXJlY3RvcnkgZm9yIHRoZSBucG0gcGFja2FnZS5cbiAgICBvdXRwdXREaXJFeGVjUGF0aCxcblxuICAgIC8vIFRoZSBwYWNrYWdlIHNlZ21lbnQgb2YgdGhlIG5nX3BhY2thZ2UgcnVsZSdzIGxhYmVsIChlLmcuICdwYWNrYWdlL2NvbW1vbicpLlxuICAgIG93bmluZ1BhY2thZ2VOYW1lLFxuXG4gICAgLy8gSlNPTiBkYXRhIGNhcHR1cmluZyBtZXRhZGF0YSBvZiB0aGUgcGFja2FnZSBiZWluZyBidWlsdC4gU2VlIGBQYWNrYWdlTWV0YWRhdGFgLlxuICAgIG1ldGFkYXRhQXJnLFxuXG4gICAgLy8gUGF0aCB0byB0aGUgcGFja2FnZSdzIFJFQURNRS5tZC5cbiAgICByZWFkbWVNZCxcblxuICAgIC8vIFBhdGggdG8gdGhlIHBhY2thZ2UncyBMSUNFTlNFIGZpbGUuXG4gICAgbGljZW5zZUZpbGUsXG5cbiAgICAvLyBMaXN0IG9mIGluZGl2aWR1YWwgRVMyMDIyIG1vZHVsZXNcbiAgICBlc20yMDIyQXJnLFxuXG4gICAgLy8gTGlzdCBvZiBzdGF0aWMgZmlsZXMgdGhhdCBzaG91bGQgYmUgY29waWVkIGludG8gdGhlIHBhY2thZ2UuXG4gICAgc3RhdGljRmlsZXNBcmcsXG5cbiAgICAvLyBMaXN0IG9mIHNpZGUtZWZmZWN0ZnVsIGVudHJ5LXBvaW50c1xuICAgIHNpZGVFZmZlY3RFbnRyeVBvaW50c0FyZyxcbiAgXSA9IHBhcmFtcztcblxuICBjb25zdCBlc20yMDIyID0gSlNPTi5wYXJzZShlc20yMDIyQXJnKSBhcyBCYXplbEZpbGVJbmZvW107XG4gIGNvbnN0IHN0YXRpY0ZpbGVzID0gSlNPTi5wYXJzZShzdGF0aWNGaWxlc0FyZykgYXMgQmF6ZWxGaWxlSW5mb1tdO1xuICBjb25zdCBtZXRhZGF0YSA9IEpTT04ucGFyc2UobWV0YWRhdGFBcmcpIGFzIFBhY2thZ2VNZXRhZGF0YTtcbiAgY29uc3Qgc2lkZUVmZmVjdEVudHJ5UG9pbnRzID0gSlNPTi5wYXJzZShzaWRlRWZmZWN0RW50cnlQb2ludHNBcmcpIGFzIHN0cmluZ1tdO1xuXG4gIGlmIChyZWFkbWVNZCkge1xuICAgIGNvcHlGaWxlKHJlYWRtZU1kLCAnUkVBRE1FLm1kJyk7XG4gIH1cblxuICBpZiAobGljZW5zZUZpbGUpIHtcbiAgICBjb3B5RmlsZShsaWNlbnNlRmlsZSwgJ0xJQ0VOU0UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZXMgYSBmaWxlIHdpdGggdGhlIHNwZWNpZmllZCBjb250ZW50IGludG8gdGhlIHBhY2thZ2Ugb3V0cHV0LlxuICAgKiBAcGFyYW0gb3V0cHV0UmVsYXRpdmVQYXRoIFJlbGF0aXZlIHBhdGggaW4gdGhlIG91dHB1dCBkaXJlY3Rvcnkgd2hlcmUgdGhlXG4gICAqICAgZmlsZSBpcyB3cml0dGVuIHRvLlxuICAgKiBAcGFyYW0gZmlsZUNvbnRlbnQgQ29udGVudCBvZiB0aGUgZmlsZS5cbiAgICovXG4gIGZ1bmN0aW9uIHdyaXRlRmlsZShvdXRwdXRSZWxhdGl2ZVBhdGg6IHN0cmluZywgZmlsZUNvbnRlbnQ6IHN0cmluZyB8IEJ1ZmZlcikge1xuICAgIGNvbnN0IG91dHB1dFBhdGggPSBwYXRoLmpvaW4ob3V0cHV0RGlyRXhlY1BhdGgsIG91dHB1dFJlbGF0aXZlUGF0aCk7XG5cbiAgICAvLyBBbHdheXMgZW5zdXJlIHRoYXQgdGhlIHRhcmdldCBkaXJlY3RvcnkgZXhpc3RzLlxuICAgIGZzLm1rZGlyU3luYyhwYXRoLmRpcm5hbWUob3V0cHV0UGF0aCksIHtyZWN1cnNpdmU6IHRydWV9KTtcbiAgICBmcy53cml0ZUZpbGVTeW5jKG91dHB1dFBhdGgsIGZpbGVDb250ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3BpZXMgYSBmaWxlIGludG8gdGhlIHBhY2thZ2Ugb3V0cHV0IHRvIHRoZSBzcGVjaWZpZWQgbG9jYXRpb24uXG4gICAqIEBwYXJhbSBpbnB1dFBhdGggRmlsZSB0aGF0IHNob3VsZCBiZSBjb3BpZWQuXG4gICAqIEBwYXJhbSBvdXRwdXRSZWxhdGl2ZVBhdGggUmVsYXRpdmUgcGF0aCBpbiB0aGUgb3V0cHV0IGRpcmVjdG9yeSB3aGVyZSB0aGVcbiAgICogICBmaWxlIGlzIHdyaXR0ZW4gdG8uXG4gICAqL1xuICBmdW5jdGlvbiBjb3B5RmlsZShpbnB1dFBhdGg6IHN0cmluZywgb3V0cHV0UmVsYXRpdmVQYXRoOiBzdHJpbmcpIHtcbiAgICBjb25zdCBmaWxlQ29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhpbnB1dFBhdGgsICd1dGY4Jyk7XG4gICAgd3JpdGVGaWxlKG91dHB1dFJlbGF0aXZlUGF0aCwgZmlsZUNvbnRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHJlbGF0aXZlIHBhdGggZm9yIHRoZSBnaXZlbiBmaWxlIHdpdGhpbiB0aGUgb3duaW5nIHBhY2thZ2UuIFRoaXNcbiAgICogYXNzdW1lcyB0aGUgZmlsZSBpcyBjb250YWluZWQgaW4gdGhlIG93bmluZyBwYWNrYWdlLlxuICAgKlxuICAgKiBlLmcuIGNvbnNpZGVyIHRoZSBvd25pbmcgcGFja2FnZSBpcyBgcGFja2FnZXMvY29yZWAgYW5kIHRoZSBpbnB1dCBmaWxlXG4gICAqIGlzIGBwYWNrYWdlcy9jb3JlL3Rlc3RpbmcvaW5kZXguZC50c2AuIFRoaXMgZnVuY3Rpb24gd291bGQgcmV0dXJuIHRoZVxuICAgKiByZWxhdGl2ZSBwYXRoIGFzIGZvbGxvd2VkOiBgdGVzdGluZy9pbmRleC5kLnRzYC5cbiAgICovXG4gIGZ1bmN0aW9uIGdldE93bmluZ1BhY2thZ2VSZWxhdGl2ZVBhdGgoZmlsZTogQmF6ZWxGaWxlSW5mbyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHBhdGgucmVsYXRpdmUob3duaW5nUGFja2FnZU5hbWUsIGZpbGUuc2hvcnRQYXRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBlbnRyeS1wb2ludCBzdWItcGF0aCBmcm9tIHRoZSBwYWNrYWdlIHJvb3QuIGUuZy4gaWYgdGhlIHBhY2thZ2UgbmFtZVxuICAgKiBpcyBgQGFuZ3VsYXIvY2RrYCwgdGhlbiBmb3IgYEBhbmd1bGFyL2Nkay9hMTF5YCBqdXN0IGBhMTF5YCB3b3VsZCBiZSByZXR1cm5lZC5cbiAgICovXG4gIGZ1bmN0aW9uIGdldEVudHJ5UG9pbnRTdWJwYXRoKG1vZHVsZU5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIG1vZHVsZU5hbWUuc2xpY2UoYCR7bWV0YWRhdGEubnBtUGFja2FnZU5hbWV9L2AubGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHdoZXRoZXIgdGhlIGdpdmVuIG1vZHVsZSBuYW1lIHJlc29sdmVzIHRvIGEgc2Vjb25kYXJ5IGVudHJ5LXBvaW50LlxuICAgKiBlLmcuIGlmIHRoZSBwYWNrYWdlIG5hbWUgaXMgYEBhbmd1bGFyL2Nka2AsIHRoZW4gZm9yIGBAYW5ndWxhci9jZGsvYTExeWBcbiAgICogdGhpcyB3b3VsZCByZXR1cm4gYHRydWVgLlxuICAgKi9cbiAgZnVuY3Rpb24gaXNTZWNvbmRhcnlFbnRyeVBvaW50KG1vZHVsZU5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBnZXRFbnRyeVBvaW50U3VicGF0aChtb2R1bGVOYW1lKSAhPT0gJyc7XG4gIH1cblxuICBjb25zdCBjcm9zc0VudHJ5UG9pbnRGYWlsdXJlcyA9IGVzbTIwMjIuZmxhdE1hcCgoZmlsZSkgPT5cbiAgICBhbmFseXplRmlsZUFuZEVuc3VyZU5vQ3Jvc3NJbXBvcnRzKGZpbGUsIG1ldGFkYXRhKSxcbiAgKTtcblxuICBpZiAoY3Jvc3NFbnRyeVBvaW50RmFpbHVyZXMubGVuZ3RoKSB7XG4gICAgY29uc29sZS5lcnJvcihjcm9zc0VudHJ5UG9pbnRGYWlsdXJlcyk7XG4gICAgcHJvY2Vzcy5leGl0KDEpO1xuICB9XG5cbiAgLy8gQ29weSBhbGwgRkVTTSBmaWxlcyAoYW5kIHRoZWlyIHBvdGVudGlhbCBzaGFyZWQgY2h1bmtzKSBpbnRvIHRoZSBwYWNrYWdlIG91dHB1dC5cbiAgY29uc3QgZmVzbUZpbGVzID0gZ2xvYlN5bmMoJyoqLyonLCB7Y3dkOiBtZXRhZGF0YS5mZXNtQnVuZGxlc091dC5wYXRofSk7XG4gIGZlc21GaWxlcy5mb3JFYWNoKChmKSA9PlxuICAgIGNvcHlGaWxlKHBhdGguam9pbihtZXRhZGF0YS5mZXNtQnVuZGxlc091dC5wYXRoLCBmKSwgcGF0aC5qb2luKCdmZXNtMjAyMicsIGYpKSxcbiAgKTtcblxuICAvLyBDb3B5IGFsbCBkdHMgZmlsZXMgKGFuZCB0aGVpciBwb3RlbnRpYWwgc2hhcmVkIGNodW5rcykgaW50byB0aGUgcGFja2FnZSBvdXRwdXQuXG4gIGNvbnN0IGR0c0ZpbGVzID0gZ2xvYlN5bmMoJyoqLyonLCB7Y3dkOiBtZXRhZGF0YS5kdHNCdW5kbGVzT3V0LnBhdGh9KTtcbiAgZHRzRmlsZXMuZm9yRWFjaCgoZikgPT5cbiAgICAvLyBUT0RPKGRldnZlcnNpb24pOiBQdXQgYWxsIHR5cGVzIHVuZGVyIGAvdHlwZXMvYCBmb2xkZXIuIEJyZWFraW5nIGNoYW5nZSBpbiB2MjAuXG4gICAgY29weUZpbGUocGF0aC5qb2luKG1ldGFkYXRhLmR0c0J1bmRsZXNPdXQucGF0aCwgZiksIGYpLFxuICApO1xuXG4gIGZvciAoY29uc3QgZmlsZSBvZiBzdGF0aWNGaWxlcykge1xuICAgIC8vIFdlIGNvcHkgYWxsIGZpbGVzIGludG8gdGhlIHBhY2thZ2Ugb3V0cHV0IHdoaWxlIHByZXNlcnZpbmcgdGhlIHN1Yi1wYXRoIGZyb21cbiAgICAvLyB0aGUgb3duaW5nIHBhY2thZ2UuIGUuZy4gYHBhY2thZ2VzL2NvcmUvcGFja2FnZS5qc29uYCBlbmRzIHVwIGA8cGtnLW91dD4vcGFja2FnZS5qc29uYC5cbiAgICBjb25zdCBvdXRwdXRSZWxhdGl2ZVBhdGggPSBnZXRPd25pbmdQYWNrYWdlUmVsYXRpdmVQYXRoKGZpbGUpO1xuICAgIGxldCBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKGZpbGUucGF0aCwgJ3V0ZjgnKTtcblxuICAgIC8vIENoZWNrIGFuZCBtb2RpZnkgcGFja2FnZS5qc29uIGZpbGVzIGFzIG5lY2Vzc2FyeSBmb3IgcHVibGlzaGluZ1xuICAgIGlmIChwYXRoLmJhc2VuYW1lKGZpbGUucGF0aCkgPT09ICdwYWNrYWdlLmpzb24nKSB7XG4gICAgICBjb25zdCBpc1ByaW1hcnlQYWNrYWdlSnNvbiA9IG91dHB1dFJlbGF0aXZlUGF0aCA9PT0gJ3BhY2thZ2UuanNvbic7XG4gICAgICBjb25zdCBwYWNrYWdlSnNvbiA9IEpTT04ucGFyc2UoY29udGVudCkgYXMgUGFja2FnZUpzb247XG4gICAgICBjb25zdCBwYWNrYWdlTmFtZSA9IHBhY2thZ2VKc29uWyduYW1lJ107XG5cbiAgICAgIC8vIFByZXZlbnQgbm9uLXByaW1hcnkgYHBhY2thZ2UuanNvbmAgZmlsZXMgd2hpY2ggd291bGQgdGhyb3ctb2ZmIHJlc29sdXRpb24uXG4gICAgICAvLyBSZXNvbHV0aW9uIGluIHRoZSBwYWNrYWdlIHNob3VsZCBvbmx5IGJlIGJhc2VkIG9uIHRoZSB0b3AtbGV2ZWwgYHBhY2thZ2UuanNvbmAuXG4gICAgICBpZiAoIWlzUHJpbWFyeVBhY2thZ2VKc29uKSB7XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIGBGb3VuZCBhIG5lc3RlZCBcInBhY2thZ2UuanNvblwiIGZpbGUgaW4gdGhlIHBhY2thZ2Ugb3V0cHV0OiAke2ZpbGUuc2hvcnRQYXRofS5cXG5gICtcbiAgICAgICAgICAgIGBBbGwgaW5mb3JtYXRpb24gb2YgdGhlIHBhY2thZ2Ugc2hvdWxkIHJlc2lkZSBpbiB0aGUgcHJpbWFyeSBwYWNrYWdlIGZpbGUuYCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGBuYW1lYCBmaWVsZCBvZiB0aGUgYHBhY2thZ2UuanNvbmAgZmlsZXMgYXJlIG1hdGNoaW5nIHdpdGhcbiAgICAgIC8vIG5hbWUgb2YgdGhlIE5QTSBwYWNrYWdlLiBUaGlzIGlzIGFuIGFkZGl0aW9uYWwgc2FmZXR5IGNoZWNrLlxuICAgICAgaWYgKHBhY2thZ2VOYW1lICE9PSBtZXRhZGF0YS5ucG1QYWNrYWdlTmFtZSkge1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBgUHJpbWFyeSBcInBhY2thZ2UuanNvblwiIGhhcyBtaXNtYXRjaGluZyBwYWNrYWdlIG5hbWUuIEV4cGVjdGVkIHRoZSBgICtcbiAgICAgICAgICAgIGBwYWNrYWdlIHRvIGJlIG5hbWVkIFwiJHttZXRhZGF0YS5ucG1QYWNrYWdlTmFtZX1cIiwgYnV0IGlzIHNldCB0bzogJHtwYWNrYWdlTmFtZX0uYCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgbGV0IG5ld1BhY2thZ2VKc29uID0gaW5zZXJ0Rm9ybWF0RmllbGRzSW50b1BhY2thZ2VKc29uKFxuICAgICAgICBvdXRwdXRSZWxhdGl2ZVBhdGgsXG4gICAgICAgIHBhY2thZ2VKc29uLFxuICAgICAgICBmYWxzZSxcbiAgICAgICk7XG5cbiAgICAgIG5ld1BhY2thZ2VKc29uID0gdXBkYXRlUHJpbWFyeVBhY2thZ2VKc29uKG5ld1BhY2thZ2VKc29uKTtcblxuICAgICAgLy8gVXBkYXRlIHRoZSBjb250ZW50IHdpdGggdGhlIG5ldyBgcGFja2FnZS5qc29uYCBmaWxlIGNvbnRlbnQuXG4gICAgICBjb250ZW50ID0gSlNPTi5zdHJpbmdpZnkobmV3UGFja2FnZUpzb24sIG51bGwsIDIpO1xuICAgIH1cblxuICAgIHdyaXRlRmlsZShvdXRwdXRSZWxhdGl2ZVBhdGgsIGNvbnRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgb3IgZWRpdHMgcHJvcGVydGllcyBpbnRvIHRoZSBwYWNrYWdlLmpzb24gZmlsZShzKSBpbiB0aGUgcGFja2FnZSBzbyB0aGF0XG4gICAqIHRoZXkgcG9pbnQgdG8gYWxsIHRoZSByaWdodCBnZW5lcmF0ZWQgYXJ0aWZhY3RzLlxuICAgKlxuICAgKiBAcGFyYW0gcGFja2FnZUpzb25PdXRSZWxhdGl2ZVBhdGggUGF0aCB3aGVyZSB0aGUgYHBhY2thZ2UuanNvbmAgaXMgc3RvcmVkIGluXG4gICAqICAgdGhlIHBhY2thZ2Ugb3V0cHV0LlxuICAgKiBAcGFyYW0gcGFyc2VkUGFja2FnZSBQYXJzZWQgcGFja2FnZS5qc29uIGNvbnRlbnRcbiAgICogQHBhcmFtIGlzR2VuZXJhdGVkUGFja2FnZUpzb24gV2hldGhlciB0aGUgcGFzc2VkIHBhY2thZ2UuanNvbiBoYXMgYmVlbiBnZW5lcmF0ZWQuXG4gICAqL1xuICBmdW5jdGlvbiBpbnNlcnRGb3JtYXRGaWVsZHNJbnRvUGFja2FnZUpzb24oXG4gICAgcGFja2FnZUpzb25PdXRSZWxhdGl2ZVBhdGg6IHN0cmluZyxcbiAgICBwYXJzZWRQYWNrYWdlOiBSZWFkb25seTxQYWNrYWdlSnNvbj4sXG4gICAgaXNHZW5lcmF0ZWRQYWNrYWdlSnNvbjogYm9vbGVhbixcbiAgKTogUGFja2FnZUpzb24ge1xuICAgIGNvbnN0IHBhY2thZ2VKc29uOiBQYWNrYWdlSnNvbiA9IHsuLi5wYXJzZWRQYWNrYWdlfTtcbiAgICBjb25zdCBwYWNrYWdlTmFtZSA9IHBhY2thZ2VKc29uWyduYW1lJ107XG4gICAgY29uc3QgZW50cnlQb2ludEluZm8gPSBtZXRhZGF0YS5lbnRyeVBvaW50c1twYWNrYWdlTmFtZV07XG4gICAgY29uc3QgcGFja2FnZUpzb25Db250YWluaW5nRGlyID0gcGF0aC5kaXJuYW1lKHBhY2thZ2VKc29uT3V0UmVsYXRpdmVQYXRoKTtcblxuICAgIC8vIElmIGEgcGFja2FnZSBqc29uIGZpbGUgaGFzIGJlZW4gZGlzY292ZXJlZCB0aGF0IGRvZXMgbm90IG1hdGNoIGFueVxuICAgIC8vIGVudHJ5LXBvaW50IGluIHRoZSBtZXRhZGF0YSwgd2UgcmVwb3J0IGEgd2FybmluZyBhcyBtb3N0IGxpa2VseSB0aGUgdGFyZ2V0XG4gICAgLy8gaXMgY29uZmlndXJlZCBpbmNvcnJlY3RseSAoZS5nLiBtaXNzaW5nIGBtb2R1bGVfbmFtZWAgYXR0cmlidXRlKS5cbiAgICBpZiAoIWVudHJ5UG9pbnRJbmZvKSB7XG4gICAgICAvLyBJZGVhbGx5IHdlIHNob3VsZCB0aHJvdyBoZXJlLCBhcyB3ZSBnb3QgYW4gZW50cnkgcG9pbnQgdGhhdCBkb2Vzbid0XG4gICAgICAvLyBoYXZlIGZsYXQgbW9kdWxlIG1ldGFkYXRhIC8gYnVuZGxlIGluZGV4LCBzbyBpdCBtYXkgaGF2ZSBiZWVuIGFuXG4gICAgICAvLyBuZ19tb2R1bGUgdGhhdCdzIG1pc3NpbmcgYSBtb2R1bGVfbmFtZSBhdHRyaWJ1dGUuXG4gICAgICAvLyBIb3dldmVyLCBAYW5ndWxhci9jb21waWxlciBjYW4ndCBiZSBhbiBuZ19tb2R1bGUsIGFzIGl0J3MgdGhlIGludGVybmFsc1xuICAgICAgLy8gb2YgdGhlIG5nYyBjb21waWxlciwgeWV0IHdlIHdhbnQgdG8gYnVpbGQgYW4gbmdfcGFja2FnZSBmb3IgaXQuXG4gICAgICAvLyBTbyBpZ25vcmUgcGFja2FnZS5qc29uIGZpbGVzIHdoZW4gd2UgYXJlIG1pc3NpbmcgZGF0YS5cbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1dBUk5JTkc6IG5vIG1vZHVsZSBtZXRhZGF0YSBmb3IgcGFja2FnZScsIHBhY2thZ2VOYW1lKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyAgIE5vdCB1cGRhdGluZyB0aGUgcGFja2FnZS5qc29uIGZpbGUgdG8gcG9pbnQgdG8gaXQnKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICcgICBUaGUgbmdfbW9kdWxlIGZvciB0aGlzIHBhY2thZ2UgaXMgcG9zc2libHkgbWlzc2luZyB0aGUgbW9kdWxlX25hbWUgYXR0cmlidXRlICcsXG4gICAgICApO1xuICAgICAgcmV0dXJuIHBhY2thZ2VKc29uO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGd1ZXNzZWQgdGhlIGluZGV4IHBhdGhzIGZvciBhIG1vZHVsZSwgYW5kIGl0IGNvbnRhaW5zIGFuIGV4cGxpY2l0IGBwYWNrYWdlLmpzb25gXG4gICAgLy8gZmlsZSB0aGF0IGFscmVhZHkgc2V0cyBmb3JtYXQgcHJvcGVydGllcywgd2Ugc2tpcCBhdXRvbWF0aWMgaW5zZXJ0aW9uIG9mIGZvcm1hdFxuICAgIC8vIHByb3BlcnRpZXMgYnV0IHJlcG9ydCBhIHdhcm5pbmcgaW4gY2FzZSBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBzZXQgYnkgYWNjaWRlbnQuXG4gICAgaWYgKFxuICAgICAgZW50cnlQb2ludEluZm8uZ3Vlc3NlZFBhdGhzICYmXG4gICAgICAhaXNHZW5lcmF0ZWRQYWNrYWdlSnNvbiAmJlxuICAgICAgaGFzRXhwbGljaXRGb3JtYXRQcm9wZXJ0aWVzKHBhY2thZ2VKc29uKVxuICAgICkge1xuICAgICAgY29uc29sZS5lcnJvcignV0FSTklORzogYHBhY2thZ2UuanNvbmAgZXhwbGljaXRseSBzZXRzIGZvcm1hdCBwcm9wZXJ0aWVzIChsaWtlIGBtYWluYCkuJyk7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAnICAgIFNraXBwaW5nIGF1dG9tYXRpYyBpbnNlcnRpb24gb2YgZm9ybWF0IHByb3BlcnRpZXMgYXMgZXhwbGljaXQgJyArXG4gICAgICAgICAgJ2Zvcm1hdCBwcm9wZXJ0aWVzIGFyZSBzZXQuJyxcbiAgICAgICk7XG4gICAgICBjb25zb2xlLmVycm9yKCcgICAgSWdub3JlIHRoaXMgd2FybmluZyBpZiBleHBsaWNpdCBwcm9wZXJ0aWVzIGFyZSBzZXQgaW50ZW50aW9uYWxseS4nKTtcbiAgICAgIHJldHVybiBwYWNrYWdlSnNvbjtcbiAgICB9XG5cbiAgICBjb25zdCBmZXNtMjAyMlJlbGF0aXZlT3V0UGF0aCA9IGVudHJ5UG9pbnRJbmZvLmZlc20yMDIyUmVsYXRpdmVQYXRoO1xuICAgIGNvbnN0IHR5cGluZ3NSZWxhdGl2ZU91dFBhdGggPSBlbnRyeVBvaW50SW5mby5kdHNCdW5kbGVSZWxhdGl2ZVBhdGg7XG5cbiAgICBwYWNrYWdlSnNvbi5tb2R1bGUgPSBub3JtYWxpemVQYXRoKFxuICAgICAgcGF0aC5yZWxhdGl2ZShwYWNrYWdlSnNvbkNvbnRhaW5pbmdEaXIsIGZlc20yMDIyUmVsYXRpdmVPdXRQYXRoKSxcbiAgICApO1xuICAgIHBhY2thZ2VKc29uLnR5cGluZ3MgPSBub3JtYWxpemVQYXRoKFxuICAgICAgcGF0aC5yZWxhdGl2ZShwYWNrYWdlSnNvbkNvbnRhaW5pbmdEaXIsIHR5cGluZ3NSZWxhdGl2ZU91dFBhdGgpLFxuICAgICk7XG5cbiAgICByZXR1cm4gcGFja2FnZUpzb247XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcHJpbWFyeSBgcGFja2FnZS5qc29uYCBmaWxlIG9mIHRoZSBOUE0gcGFja2FnZSB0byBzcGVjaWZ5XG4gICAqIHRoZSBtb2R1bGUgY29uZGl0aW9uYWwgZXhwb3J0cyBhbmQgdGhlIEVTTSBtb2R1bGUgdHlwZS5cbiAgICovXG4gIGZ1bmN0aW9uIHVwZGF0ZVByaW1hcnlQYWNrYWdlSnNvbihwYWNrYWdlSnNvbjogUmVhZG9ubHk8UGFja2FnZUpzb24+KTogUGFja2FnZUpzb24ge1xuICAgIGlmIChwYWNrYWdlSnNvbi50eXBlICE9PSB1bmRlZmluZWQgJiYgcGFja2FnZUpzb24udHlwZSAhPT0gJ21vZHVsZScpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAnVGhlIHByaW1hcnkgXCJwYWNrYWdlLmpzb25cIiBmaWxlIG9mIHRoZSBwYWNrYWdlIHNldHMgdGhlIFwidHlwZVwiIGZpZWxkICcgK1xuICAgICAgICAgICd0aGF0IGlzIGNvbnRyb2xsZWQgYnkgdGhlIHBhY2thZ2VyLiBQbGVhc2UgdW5zZXQgaXQgb3Igc2V0IGB0eXBlYCB0byBgbW9kdWxlYC4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdQYWNrYWdlSnNvbjogUGFja2FnZUpzb24gPSB7Li4ucGFja2FnZUpzb259O1xuXG4gICAgbmV3UGFja2FnZUpzb24udHlwZSA9ICdtb2R1bGUnO1xuXG4gICAgLy8gVGhlIGBwYWNrYWdlLmpzb25gIGZpbGUgaXMgbWFkZSBwdWJsaWNseSBhY2Nlc3NpYmxlIGZvciB0b29scyB0aGF0XG4gICAgLy8gbWlnaHQgd2FudCB0byBxdWVyeSBpbmZvcm1hdGlvbiBmcm9tIHRoZSBBbmd1bGFyIE5QTSBwYWNrYWdlLlxuICAgIGluc2VydEV4cG9ydE1hcHBpbmdPckVycm9yKG5ld1BhY2thZ2VKc29uLCAnLi9wYWNrYWdlLmpzb24nLCB7ZGVmYXVsdDogJy4vcGFja2FnZS5qc29uJ30pO1xuXG4gICAgLy8gQ2FwdHVyZSBhbGwgZW50cnktcG9pbnRzIGluIHRoZSBgZXhwb3J0c2AgZmllbGQgdXNpbmcgdGhlIHN1YnBhdGggZXhwb3J0IGRlY2xhcmF0aW9uczpcbiAgICAvLyBodHRwczovL25vZGVqcy5vcmcvYXBpL3BhY2thZ2VzLmh0bWwjcGFja2FnZXNfc3VicGF0aF9leHBvcnRzLlxuICAgIGZvciAoY29uc3QgW21vZHVsZU5hbWUsIGVudHJ5UG9pbnRdIG9mIE9iamVjdC5lbnRyaWVzKG1ldGFkYXRhLmVudHJ5UG9pbnRzKSkge1xuICAgICAgY29uc3Qgc3VicGF0aCA9IGlzU2Vjb25kYXJ5RW50cnlQb2ludChtb2R1bGVOYW1lKVxuICAgICAgICA/IGAuLyR7Z2V0RW50cnlQb2ludFN1YnBhdGgobW9kdWxlTmFtZSl9YFxuICAgICAgICA6ICcuJztcbiAgICAgIGNvbnN0IGZlc20yMDIyT3V0UmVsYXRpdmVQYXRoID0gZW50cnlQb2ludC5mZXNtMjAyMlJlbGF0aXZlUGF0aDtcbiAgICAgIGNvbnN0IHR5cGVzT3V0UmVsYXRpdmVQYXRoID0gZW50cnlQb2ludC5kdHNCdW5kbGVSZWxhdGl2ZVBhdGg7XG5cbiAgICAgIC8vIEluc2VydCB0aGUgZXhwb3J0IG1hcHBpbmcgZm9yIHRoZSBlbnRyeS1wb2ludC4gV2Ugc2V0IGBkZWZhdWx0YCB0byB0aGUgRkVTTSAyMDIyXG4gICAgICAvLyBvdXRwdXQsIGFuZCBhbHNvIHNldCB0aGUgYHR5cGVzYCBjb25kaXRpb24gd2hpY2ggd2lsbCBiZSByZXNwZWN0ZWQgYnkgVFMgNC41LlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L3B1bGwvNDU4ODQuXG4gICAgICBpbnNlcnRFeHBvcnRNYXBwaW5nT3JFcnJvcihuZXdQYWNrYWdlSnNvbiwgc3VicGF0aCwge1xuICAgICAgICB0eXBlczogbm9ybWFsaXplUGF0aCh0eXBlc091dFJlbGF0aXZlUGF0aCksXG4gICAgICAgIC8vIE5vdGU6IFRoZSBkZWZhdWx0IGNvbmRpdGlvbnMgbmVlZHMgdG8gYmUgdGhlIGxhc3Qgb25lLlxuICAgICAgICBkZWZhdWx0OiBub3JtYWxpemVQYXRoKGZlc20yMDIyT3V0UmVsYXRpdmVQYXRoKSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNoZWNrUGFja2FnZUpzb25TaWRlRWZmZWN0cyhwYWNrYWdlSnNvbik7XG5cbiAgICByZXR1cm4gbmV3UGFja2FnZUpzb247XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1BhY2thZ2VKc29uU2lkZUVmZmVjdHMocGFja2FnZUpzb246IFBhY2thZ2VKc29uKTogdm9pZCB7XG4gICAgLy8gQ29udmVuaWVuY2UgaWYgdGhlcmUgYXJlIG5vIHNpZGUgZWZmZWN0cywgYW5kIGl0J3MgZXhwbGljaXRseSBtYXJrZWQuXG4gICAgLy8gVGhpcyBpcyBva2F5IGFuZCB3ZSBkb24ndCBhc2sgdGhlIGRldmVsb3BlciB0byBkcm9wIHRoZSBleHBsaWNpdCBmaWVsZC5cbiAgICBpZiAocGFja2FnZUpzb24uc2lkZUVmZmVjdHMgPT09IGZhbHNlICYmIHNpZGVFZmZlY3RFbnRyeVBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocGFja2FnZUpzb24uc2lkZUVmZmVjdHMgPT09IHRydWUpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAnVW5leHBlY3RlZCBgc2lkZUVmZmVjdHNgIGZpZWxkIGluIGBwYWNrYWdlLmpzb25gLiAnICtcbiAgICAgICAgICAnU2lkZSBlZmZlY3RzIHNob3VsZCBiZSBmaW5lLWdyYWluZWQgYW5kIG1hcmtlZCB2aWEgdGhlIEJhemVsIGBzaWRlX2VmZmVjdF9lbnRyeV9wb2ludHNgIG9wdGlvbi4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBzaWRlRWZmZWN0cyA9IHBhY2thZ2VKc29uLnNpZGVFZmZlY3RzIGFzIHVuZGVmaW5lZCB8IGZhbHNlIHwgc3RyaW5nW107XG4gICAgY29uc3QgbmVlZGVkU2lkZUVmZmVjdHMgPSBzaWRlRWZmZWN0RW50cnlQb2ludHMubWFwKFxuICAgICAgKGVudHJ5UG9pbnRNb2R1bGUpID0+IGAuLyR7bWV0YWRhdGEuZW50cnlQb2ludHNbZW50cnlQb2ludE1vZHVsZV0uZmVzbTIwMjJSZWxhdGl2ZVBhdGh9YCxcbiAgICApO1xuICAgIGNvbnN0IG1pc3NpbmdTaWRlRWZmZWN0cyA9IG5lZWRlZFNpZGVFZmZlY3RzLmZpbHRlcihcbiAgICAgIChwKSA9PlxuICAgICAgICAvLyBJdCdzIG1pc3NpbmcsIGlmIHRoZSB3aG9sZSBwYWNrYWdlIGlzIG1hcmtlZCBhcyBoYXZpbmcgbm8gc2lkZSBlZmZlY3RzLlxuICAgICAgICBzaWRlRWZmZWN0cyA9PT0gZmFsc2UgfHxcbiAgICAgICAgLy8gQWx0ZXJuYXRpdmVseSwgaXQncyBtaXNzaW5nIGlmIHRoZSBleHBsaWNpdCBsaXN0IGRvZXNuJ3QgY29udGFpbiB0aGUgcGF0dGVybi5cbiAgICAgICAgIShzaWRlRWZmZWN0cyA/PyBbXSkuaW5jbHVkZXMocCksXG4gICAgKTtcblxuICAgIGlmIChtaXNzaW5nU2lkZUVmZmVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICdNaXNzaW5nIHNpZGUgZWZmZWN0cyBpbiBgcGFja2FnZS5qc29uYCBgc2lkZUVmZmVjdHNgIGZpZWxkLiAnICtcbiAgICAgICAgICAnUGxlYXNlIGFkZCB0aGUgZm9sbG93aW5nIHNpZGUgZWZmZWN0IGZpbGUgcGF0dGVybnM6XFxuJyArXG4gICAgICAgICAgbWlzc2luZ1NpZGVFZmZlY3RzLmpvaW4oJ1xcbiAtICcpLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIHBvdGVudGlhbCBzaWRlLWVmZmVjdHMgdGhhdCByZWZlciB0byBvdXIgRkVTTSBidW5kbGVzLCBidXQgYXJlbid0IHBhcnRcbiAgICAvLyBvZiB0aGUgYG5nX3BhY2thZ2VgIGtub3duIGVudHJ5IHBvaW50cy5cbiAgICBjb25zdCB1bmV4cGVjdGVkRXh0cmEgPVxuICAgICAgc2lkZUVmZmVjdHMgIT09IGZhbHNlXG4gICAgICAgID8gKHNpZGVFZmZlY3RzID8/IFtdKS5maWx0ZXIoXG4gICAgICAgICAgICAocCkgPT4gcC5pbmNsdWRlcygnZmVzbTIwMjInKSAmJiAhbmVlZGVkU2lkZUVmZmVjdHMuaW5jbHVkZXMocCksXG4gICAgICAgICAgKVxuICAgICAgICA6IFtdO1xuICAgIGlmICh1bmV4cGVjdGVkRXh0cmEubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICdVbmV4cGVjdGVkIHNpZGUgZWZmZWN0cyBpbiBgcGFja2FnZS5qc29uYCBgc2lkZUVmZmVjdHNgIGZpZWxkIHRoYXQgaXMgbm90IGtub3duIHRvIGBuZ19wYWNrYWdlYC4gJyArXG4gICAgICAgICAgJ1BsZWFzZSBhZGQgdGhlIHNpZGUgZWZmZWN0IGVudHJ5IHBvaW50IHRvIHRoZSBCYXplbCBgc2lkZV9lZmZlY3RfZW50cnlfcG9pbnRzYCBvcHRpb24uICcgK1xuICAgICAgICAgICdVbmV4cGVjdGVkIHBhdHRlcm5zOlxcbicgK1xuICAgICAgICAgIHVuZXhwZWN0ZWRFeHRyYS5qb2luKCdcXG4gLSAnKSxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgYSBzdWJwYXRoIGV4cG9ydCBtYXBwaW5nIGludG8gdGhlIHNwZWNpZmllZCBgcGFja2FnZS5qc29uYCBvYmplY3QuXG4gICAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIG1hcHBpbmcgaXMgYWxyZWFkeSBkZWZpbmVkIGFuZCB3b3VsZCBjb25mbGljdC5cbiAgICovXG4gIGZ1bmN0aW9uIGluc2VydEV4cG9ydE1hcHBpbmdPckVycm9yKFxuICAgIHBhY2thZ2VKc29uOiBQYWNrYWdlSnNvbixcbiAgICBzdWJwYXRoOiBzdHJpbmcsXG4gICAgbWFwcGluZzogQ29uZGl0aW9uYWxFeHBvcnQsXG4gICkge1xuICAgIGlmIChwYWNrYWdlSnNvbi5leHBvcnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhY2thZ2VKc29uLmV4cG9ydHMgPSB7fTtcbiAgICB9XG4gICAgaWYgKHBhY2thZ2VKc29uLmV4cG9ydHNbc3VicGF0aF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcGFja2FnZUpzb24uZXhwb3J0c1tzdWJwYXRoXSA9IHt9O1xuICAgIH1cblxuICAgIGNvbnN0IHN1YnBhdGhFeHBvcnQgPSBwYWNrYWdlSnNvbi5leHBvcnRzW3N1YnBhdGhdO1xuXG4gICAgLy8gR28gdGhyb3VnaCBhbGwgY29uZGl0aW9ucyB0aGF0IHNob3VsZCBiZSBpbnNlcnRlZC4gSWYgdGhlIGNvbmRpdGlvbiBpcyBhbHJlYWR5XG4gICAgLy8gbWFudWFsbHkgc2V0IG9mIHRoZSBzdWJwYXRoIGV4cG9ydCwgd2UgdGhyb3cgYW4gZXJyb3IuIEluIGdlbmVyYWwsIHdlIGFsbG93IGZvclxuICAgIC8vIGFkZGl0aW9uYWwgY29uZGl0aW9ucyB0byBiZSBzZXQuIFRoZXNlIHdpbGwgYWx3YXlzIHByZWNlZGUgdGhlIGdlbmVyYXRlZCBvbmVzLlxuICAgIGZvciAoY29uc3QgY29uZGl0aW9uTmFtZSBvZiBPYmplY3Qua2V5cyhtYXBwaW5nKSBhcyBba2V5b2YgQ29uZGl0aW9uYWxFeHBvcnRdKSB7XG4gICAgICBpZiAoc3VicGF0aEV4cG9ydFtjb25kaXRpb25OYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIGBGb3VuZCBhIGNvbmZsaWN0aW5nIGV4cG9ydCBjb25kaXRpb24gZm9yIFwiJHtzdWJwYXRofVwiLiBUaGUgXCIke2NvbmRpdGlvbk5hbWV9XCIgYCArXG4gICAgICAgICAgICBgY29uZGl0aW9uIHdvdWxkIGJlIG92ZXJyaWRkZW4gYnkgdGhlIHBhY2thZ2VyLiBQbGVhc2UgdW5zZXQgaXQuYCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gKipOb3RlKio6IFRoZSBvcmRlciBvZiB0aGUgY29uZGl0aW9ucyBpcyBwcmVzZXJ2ZWQgZXZlbiB0aG91Z2ggd2UgYXJlIHNldHRpbmdcbiAgICAgIC8vIHRoZSBjb25kaXRpb25zIG9uY2UgYXQgYSB0aW1lICh0aGUgbGF0ZXN0IGFzc2lnbm1lbnQgd2lsbCBiZSBhdCB0aGUgZW5kKS5cbiAgICAgIHN1YnBhdGhFeHBvcnRbY29uZGl0aW9uTmFtZV0gPSBtYXBwaW5nW2NvbmRpdGlvbk5hbWVdO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBXaGV0aGVyIHRoZSBwYWNrYWdlIGV4cGxpY2l0bHkgc2V0cyBhbnkgb2YgdGhlIGZvcm1hdCBwcm9wZXJ0aWVzIChsaWtlIGBtYWluYCkuICovXG4gIGZ1bmN0aW9uIGhhc0V4cGxpY2l0Rm9ybWF0UHJvcGVydGllcyhwYXJzZWRQYWNrYWdlOiBSZWFkb25seTxQYWNrYWdlSnNvbj4pOiBib29sZWFuIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocGFyc2VkUGFja2FnZSkuc29tZSgoZmllbGROYW1lOiBzdHJpbmcpID0+XG4gICAgICBrbm93bkZvcm1hdFBhY2thZ2VKc29uRm9ybWF0RmllbGRzLmluY2x1ZGVzKGZpZWxkTmFtZSBhcyBLbm93blBhY2thZ2VKc29uRm9ybWF0RmllbGRzKSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZXMgdGhlIHNwZWNpZmllZCBwYXRoIGJ5IHJlcGxhY2luZyBiYWNrc2xhc2ggc2VwYXJhdG9ycyB3aXRoIFBvc2l4XG4gICAqIGZvcndhcmQgc2xhc2ggc2VwYXJhdG9ycy5cbiAgICovXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVBhdGgocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCByZXN1bHQgPSBwYXRoLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcbiAgICByZXR1cm4gcmVzdWx0LnN0YXJ0c1dpdGgoJy4nKSA/IHJlc3VsdCA6IGAuLyR7cmVzdWx0fWA7XG4gIH1cbn1cbiJdfQ==