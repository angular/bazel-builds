/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import * as fs from 'fs';
import * as path from 'path';
import * as shx from 'shelljs';
function main(args) {
    // Exit immediately when encountering an error.
    shx.set('-e');
    // Keep track of whether an error has occured so that we can return an appropriate exit code.
    let errorHasOccured = false;
    // This utility expects all of its arguments to be specified in a params file generated by
    // bazel (see https://docs.bazel.build/versions/master/skylark/lib/Args.html#use_param_file).
    const paramFilePath = args[0];
    // Bazel params may be surrounded with quotes
    function unquoteParameter(s) {
        return s.replace(/^'(.*)'$/, '$1');
    }
    // Parameters are specified in the file one per line.
    const params = fs.readFileSync(paramFilePath, 'utf-8').split('\n').map(unquoteParameter);
    const [
    // Output directory for the npm package.
    out, 
    // The package segment of the ng_package rule's label (e.g. 'package/common').
    srcDir, 
    // The bazel-bin dir joined with the srcDir (e.g. 'bazel-bin/package.common').
    // This is the intended output location for package artifacts.
    binDir, 
    // The bazel-genfiles dir joined with the srcDir (e.g. 'bazel-bin/package.common').
    genfilesDir, 
    // JSON data mapping each entry point to the generated bundle index and
    // flat module metadata, for example
    // {"@angular/core": {
    //     "index": "bazel-bin/packages/core/core.js",
    //     "typings": "bazel-bin/packages/core/core.d.ts",
    //     "metadata": "bazel-bin/packages/core/core.metadata.json"
    //  },
    // ...
    // }
    modulesManifestArg, 
    // Path to the package's README.md.
    readmeMd, 
    // List of rolled-up flat ES2015 modules
    fesm2015Arg, 
    // List of individual ES2015 modules
    esm2015Arg, 
    // List of all UMD bundles generated by rollup.
    bundlesArg, 
    // List of all files in the ng_package rule's srcs.
    srcsArg, 
    // List of all type definitions that need to packaged into the ng_package.
    typeDefinitionsArg, 
    // List of all files in the ng_package rule's data.
    dataArg, 
    // Path to the package's LICENSE.
    licenseFile, 
    // List of all dts bundles generated by the API extractor.
    dtsBundleArg, 
    // The dts bundle file suffix example: '.bundle.d.ts'
    dtsBundleFileSuffix,] = params;
    const fesm2015 = fesm2015Arg.split(',').filter(s => !!s);
    const esm2015 = esm2015Arg.split(',').filter(s => !!s);
    const bundles = bundlesArg.split(',').filter(s => !!s);
    const typeDefinitions = typeDefinitionsArg.split(',').filter(s => !!s);
    const srcs = srcsArg.split(',').filter(s => !!s);
    const dataFiles = dataArg.split(',').filter(s => !!s);
    const modulesManifest = JSON.parse(modulesManifestArg);
    const dtsBundles = dtsBundleArg.split(',').filter(s => !!s);
    /**
     * List of known `package.json` fields which provide information about
     * supported package formats and their associated entry paths.
     */
    const knownFormatPackageJsonFields = ['main', 'fesm2015', 'esm2015', 'typings', 'module', 'es2015'];
    if (readmeMd) {
        copyFile(readmeMd, out);
    }
    /**
     * Writes a file into the package based on its input path, relativizing to the package path.
     * @param inputPath Path to the file in the input tree.
     * @param fileContent Content of the file.
     */
    function writeFileFromInputPath(inputPath, fileContent) {
        // We want the relative path from the given file to its ancestor "root" directory.
        // This root depends on whether the file lives in the source tree (srcDir) as a basic file
        // input to ng_package, the bin output tree (binDir) as the output of another rule, or
        // the genfiles output tree (genfilesDir) as the output of a genrule.
        let rootDir;
        if (inputPath.includes(binDir)) {
            rootDir = binDir;
        }
        else if (inputPath.includes(genfilesDir)) {
            rootDir = genfilesDir;
        }
        else {
            rootDir = srcDir;
        }
        const outputPath = path.join(out, path.relative(rootDir, inputPath));
        // Always ensure that the target directory exists.
        shx.mkdir('-p', path.dirname(outputPath));
        fs.writeFileSync(outputPath, fileContent);
    }
    /**
     * Copies a file into the package based on its input path, relativizing to the package path.
     * @param inputPath a path relative to the binDir, typically from a file in the deps[]
     */
    function copyFileFromInputPath(inputPath) {
        writeFileFromInputPath(inputPath, fs.readFileSync(inputPath));
    }
    /**
     * Relativize the path where a file is written.
     * @param file a path containing a re-rooted segment like `.esm2015`
     * @param outDir path where we copy the file, relative to the out
     */
    function writeEsmFile(file, outDir) {
        // Path computed relative to the current package in bazel-bin. e.g. a ES2015 output file
        // in `bazel-out/<..>/packages/core/src/di.js` should be stored in `{out_dir}/src/di.js`
        // if the package target has been declared in `<..>/packages/core`.
        const packageRelativePath = path.dirname(path.relative(binDir, file));
        if (!packageRelativePath.startsWith('..')) {
            copyFile(file, path.join(out, outDir), packageRelativePath);
        }
    }
    esm2015.forEach(file => writeEsmFile(file, 'esm2015'));
    bundles.forEach(bundle => {
        copyFile(bundle, out, 'bundles');
    });
    fesm2015.forEach(file => {
        copyFile(file, out, 'fesm2015');
    });
    // Copy all type definitions into the package. This is necessary so that developers can use
    // the package with type definitions.
    typeDefinitions.forEach(f => writeFileFromInputPath(f, readTypingsAndStripAmdModule(f)));
    // Copy all `data` files into the package. These are files that aren't built by the ng_package
    // rule, but instead are just straight copied into the package, e.g. global CSS assets.
    dataFiles.forEach(f => copyFileFromInputPath(f));
    // Iterate through the entry point modules
    // We do this first because we also record new paths for the esm5 and esm2015 copies
    // of the index JS file, which we need to amend the package.json.
    Object.keys(modulesManifest).forEach(moduleName => {
        const moduleFiles = modulesManifest[moduleName];
        const relative = path.relative(binDir, moduleFiles['index']);
        moduleFiles['esm2015_index'] = path.join(binDir, 'esm2015', relative);
        // Metadata file is optional as entry-points can be built with the `ts_library`
        // rule or `ng_module` rule in Ivy mode.
        const metadataFile = moduleFiles['metadata'];
        if (!metadataFile) {
            return;
        }
        const typingsOutFile = moduleFiles['typings'];
        // We only support all modules within a package to be dts bundled
        // ie: if @angular/common/http has flat dts, so should @angular/common
        if (dtsBundles.length) {
            const metadataContent = rewireMetadata(metadataFile, typingsOutFile);
            writeFileFromInputPath(metadataFile, metadataContent);
        }
        else {
            copyFileFromInputPath(metadataFile);
        }
    });
    const licenseBanner = licenseFile ? fs.readFileSync(licenseFile, 'utf-8') : '';
    dtsBundles.forEach(bundleFile => {
        const cleanDistPath = bundleFile.replace(dtsBundleFileSuffix, '.d.ts');
        // API extractor will not dedupe license comments from various files
        // this will remove all the license comments and append the license banner.
        const content = licenseBanner + '\n' +
            readTypingsAndStripAmdModule(bundleFile)
                .replace(/(\/\*\*\s+\*\s\@license(((?!\*\/).|\s)*)\*\/)/gm, '');
        writeFileFromInputPath(cleanDistPath, content);
    });
    // Root package name (e.g. '@angular/common'), captures as we iterate through sources below.
    let rootPackageName = '';
    const packagesWithExistingPackageJson = new Set();
    for (const src of srcs) {
        if (src.includes(binDir) || src.includes(genfilesDir)) {
            errorHasOccured = true;
            console.error('The "srcs" for ng_package should not include output of other rules. Found:\n' +
                `  ${src}`);
        }
        let content = fs.readFileSync(src, 'utf-8');
        // Modify package.json files as necessary for publishing
        if (path.basename(src) === 'package.json') {
            const packageJson = JSON.parse(content);
            content = amendPackageJson(src, packageJson, false);
            const packageName = packageJson['name'];
            packagesWithExistingPackageJson.add(packageName);
            // Keep track of the root package name, e.g. "@angular/common". We assume that the
            // root name will be shortest because secondary entry-points will append to it
            // (e.g. "@angular/common/http").
            if (!rootPackageName || packageName.length < rootPackageName.length) {
                rootPackageName = packageJson['name'];
            }
        }
        writeFileFromInputPath(src, content);
    }
    // Generate extra files for secondary entry-points.
    Object.keys(modulesManifest).forEach(entryPointPackageName => {
        const entryPointName = entryPointPackageName.substr(rootPackageName.length + 1);
        if (!entryPointName)
            return;
        const metadataFilePath = modulesManifest[entryPointPackageName]['metadata'];
        if (metadataFilePath) {
            createMetadataReexportFile(entryPointName, modulesManifest[entryPointPackageName]['metadata'], entryPointPackageName);
        }
        createTypingsReexportFile(entryPointName, licenseBanner, modulesManifest[entryPointPackageName]['typings']);
        if (!packagesWithExistingPackageJson.has(entryPointPackageName)) {
            createEntryPointPackageJson(entryPointName, entryPointPackageName);
        }
    });
    return errorHasOccured ? 1 : 0;
    /**
     * Convert a binDir-relative path to srcDir-relative
     * @param from path to a file under the srcDir, like packages/core/testing/package.json
     * @param file path to a file under the binDir, like bazel-bin/core/testing/generated.js
     */
    function srcDirRelative(from, file) {
        const result = normalizeSeparators(path.relative(path.dirname(from), path.join(srcDir, path.relative(binDir, file))));
        if (result.startsWith('..'))
            return result;
        return `./${result}`;
    }
    function copyFile(file, baseDir, relative = '.') {
        const dir = path.join(baseDir, relative);
        // output file is .js if the input file is .mjs
        const outFile = path.posix.join(dir, path.basename(file.endsWith('.mjs') ? file.replace(/\.mjs$/, '.js') : file));
        shx.mkdir('-p', dir);
        shx.cp(file, outFile);
        // Double-underscore is used to escape forward slash in FESM filenames.
        // See ng_package.bzl:
        //   fesm_output_filename = entry_point.replace("/", "__")
        // We need to unescape these.
        if (outFile.indexOf('__') >= 0) {
            const outputPath = path.join(dir, ...path.basename(outFile).split('__'));
            shx.mkdir('-p', path.dirname(outputPath));
            shx.mv(path.join(dir, path.basename(file)), outputPath);
            // if we are renaming the .js file, we'll also need to update the sourceMappingURL in the file
            if (outFile.endsWith('.js')) {
                shx.chmod('+w', outputPath);
                shx.sed('-i', `${path.basename(file)}.map`, `${path.basename(outputPath)}.map`, outputPath);
            }
        }
    }
    /**
     * Inserts or edits properties into the package.json file(s) in the package so that
     * they point to all the right generated artifacts.
     *
     * @param packageJson The path to the package.json file.
     * @param parsedPackage Parsed package.json content
     * @param isGeneratedPackageJson Whether the passed package.json has been generated.
     */
    function amendPackageJson(packageJson, parsedPackage, isGeneratedPackageJson) {
        const packageName = parsedPackage['name'];
        const moduleData = modulesManifest[packageName];
        // If a package json file has been discovered that does not match any
        // module in the manifest, we report a warning as most likely the target
        // is configured incorrectly (e.g. missing `module_name` attribute).
        if (!moduleData) {
            // Ideally we should throw here, as we got an entry point that doesn't
            // have flat module metadata / bundle index, so it may have been an
            // ng_module that's missing a module_name attribute.
            // However, @angular/compiler can't be an ng_module, as it's the internals
            // of the ngc compiler, yet we want to build an ng_package for it.
            // So ignore package.json files when we are missing data.
            console.error('WARNING: no module metadata for package', packageName);
            console.error('   Not updating the package.json file to point to it');
            console.error('   The ng_module for this package is possibly missing the module_name attribute ');
            return JSON.stringify(parsedPackage, null, 2);
        }
        // If we guessed the index paths for a module, and it contains an explicit `package.json`
        // file that already sets format properties, we skip automatic insertion of format
        // properties but report a warning in case properties have been set by accident.
        if (moduleData.guessedPaths && !isGeneratedPackageJson &&
            hasExplicitFormatProperties(parsedPackage)) {
            console.error('WARNING: `package.json` explicitly sets format properties (like `main`).');
            console.error('    Skipping automatic insertion of format properties as explicit ' +
                'format properties are set.');
            console.error('    Ignore this warning if explicit properties are set intentionally.');
            return JSON.stringify(parsedPackage, null, 2);
        }
        // Derive the paths to the files from the hard-coded names we gave them.
        // TODO(alexeagle): it would be better to transfer this information from the place
        // where we created the filenames, via the modulesManifestArg
        parsedPackage['main'] = getBundleName(packageName, 'bundles');
        parsedPackage['fesm2015'] = getBundleName(packageName, 'fesm2015');
        parsedPackage['esm2015'] = srcDirRelative(packageJson, moduleData['esm2015_index']);
        parsedPackage['typings'] = srcDirRelative(packageJson, moduleData['typings']);
        // For now, we point the primary entry points at the fesm files, because of Webpack
        // performance issues with a large number of individual files.
        parsedPackage['module'] = parsedPackage['fesm2015'];
        parsedPackage['es2015'] = parsedPackage['fesm2015'];
        return JSON.stringify(parsedPackage, null, 2);
    }
    // e.g. @angular/common/http/testing -> ../../bundles/common-http-testing.umd.js
    // or   @angular/common/http/testing -> ../../fesm2015/http/testing.js
    function getBundleName(packageName, dir) {
        const parts = packageName.split('/');
        // Remove the scoped package part, like @angular if present
        const nameParts = packageName.startsWith('@') ? parts.splice(1) : parts;
        const relativePath = newArray(nameParts.length - 1, '..').join('/') || '.';
        let basename;
        if (dir === 'bundles') {
            basename = nameParts.join('-') + '.umd';
        }
        else if (nameParts.length === 1) {
            basename = nameParts[0];
        }
        else {
            basename = nameParts.slice(1).join('/');
        }
        return [relativePath, dir, basename + '.js'].join('/');
    }
    /** Whether the package explicitly sets any of the format properties (like `main`). */
    function hasExplicitFormatProperties(parsedPackage) {
        return Object.keys(parsedPackage)
            .some(propertyName => knownFormatPackageJsonFields.includes(propertyName));
    }
    /** Creates metadata re-export file for a secondary entry-point. */
    function createMetadataReexportFile(entryPointName, metadataFile, packageName) {
        const inputPath = path.join(srcDir, `${entryPointName}.metadata.json`);
        writeFileFromInputPath(inputPath, JSON.stringify({
            '__symbolic': 'module',
            'version': 3,
            'metadata': {},
            'exports': [{ 'from': `${srcDirRelative(inputPath, metadataFile.replace(/.metadata.json$/, ''))}` }],
            'flatModuleIndexRedirect': true,
            'importAs': packageName
        }) + '\n');
    }
    /**
     * Creates a typings (d.ts) re-export file for a secondary-entry point,
     * e.g., `export * from './common/common'`
     */
    function createTypingsReexportFile(entryPointName, license, typingsFile) {
        const inputPath = path.join(srcDir, `${entryPointName}.d.ts`);
        const content = `${license}
export * from '${srcDirRelative(inputPath, typingsFile.replace(/\.d\.tsx?$/, ''))}';
`;
        writeFileFromInputPath(inputPath, content);
    }
    /**
     * Creates a package.json for a secondary entry-point.
     * @param dir The directory under which the package.json should be written.
     * @param entryPointPackageName The full package name for the entry point,
     *     e.g. '@angular/common/http'.
     */
    function createEntryPointPackageJson(dir, entryPointPackageName) {
        const pkgJson = path.join(srcDir, dir, 'package.json');
        const content = amendPackageJson(pkgJson, { name: entryPointPackageName }, true);
        writeFileFromInputPath(pkgJson, content);
    }
    /**
     * Normalizes the specified path by replacing backslash separators with Posix
     * forward slash separators.
     */
    function normalizeSeparators(path) {
        return path.replace(/\\/g, '/');
    }
    /**
     * Rewires metadata to point to the flattened dts file.
     *
     * @param metadataPath the metadata file path
     * @param typingsPath the typings bundle entrypoint
     */
    function rewireMetadata(metadataPath, typingsPath) {
        const metadata = JSON.parse(fs.readFileSync(metadataPath, 'utf-8'));
        let typingsRelativePath = normalizeSeparators(path.relative(path.dirname(metadataPath), typingsPath));
        if (!typingsRelativePath.startsWith('..')) {
            typingsRelativePath = `./${typingsRelativePath}`;
        }
        typingsRelativePath = typingsRelativePath.replace('.d.ts', '');
        // the regexp here catches all relative paths such as:
        // ./src/core/foo.d.ts and ../src/core/foo.d.ts
        const relativePathRegex = /\.?\.\/[\w\.\-_\/]+/g;
        if (metadata.exports) {
            // Strip re-exports which are now self-references
            metadata.exports =
                metadata.exports.filter((e) => !e.from.match(relativePathRegex));
        }
        return JSON.stringify(metadata).replace(relativePathRegex, typingsRelativePath);
    }
    /**
     * Strip the named AMD module for compatibility with non-bazel users from typings content
     * @param filePath dts file path
     */
    function readTypingsAndStripAmdModule(filePath) {
        return fs
            .readFileSync(filePath, 'utf-8')
            // Strip the named AMD module for compatibility with non-bazel users
            .replace(/^\/\/\/ <amd-module name=.*\/>[\r\n]+/gm, '');
    }
}
if (require.main === module) {
    process.exitCode = main(process.argv.slice(2));
}
export function newArray(size, value) {
    const list = [];
    for (let i = 0; i < size; i++) {
        list.push(value);
    }
    return list;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFja2FnZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9iYXplbC9zcmMvbmdfcGFja2FnZS9wYWNrYWdlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFFSCxPQUFPLEtBQUssRUFBRSxNQUFNLElBQUksQ0FBQztBQUN6QixPQUFPLEtBQUssSUFBSSxNQUFNLE1BQU0sQ0FBQztBQUM3QixPQUFPLEtBQUssR0FBRyxNQUFNLFNBQVMsQ0FBQztBQUUvQixTQUFTLElBQUksQ0FBQyxJQUFjO0lBQzFCLCtDQUErQztJQUMvQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBRWQsNkZBQTZGO0lBQzdGLElBQUksZUFBZSxHQUFHLEtBQUssQ0FBQztJQUU1QiwwRkFBMEY7SUFDMUYsNkZBQTZGO0lBQzdGLE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUU5Qiw2Q0FBNkM7SUFDN0MsU0FBUyxnQkFBZ0IsQ0FBQyxDQUFTO1FBQ2pDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVELHFEQUFxRDtJQUNyRCxNQUFNLE1BQU0sR0FBRyxFQUFFLENBQUMsWUFBWSxDQUFDLGFBQWEsRUFBRSxPQUFPLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLENBQUM7SUFFekYsTUFBTTtJQUNGLHdDQUF3QztJQUN4QyxHQUFHO0lBRUgsOEVBQThFO0lBQzlFLE1BQU07SUFFTiw4RUFBOEU7SUFDOUUsOERBQThEO0lBQzlELE1BQU07SUFFTixtRkFBbUY7SUFDbkYsV0FBVztJQUVYLHVFQUF1RTtJQUN2RSxvQ0FBb0M7SUFDcEMsc0JBQXNCO0lBQ3RCLGtEQUFrRDtJQUNsRCxzREFBc0Q7SUFDdEQsK0RBQStEO0lB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biAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCAqIGFzIHNoeCBmcm9tICdzaGVsbGpzJztcblxuZnVuY3Rpb24gbWFpbihhcmdzOiBzdHJpbmdbXSk6IG51bWJlciB7XG4gIC8vIEV4aXQgaW1tZWRpYXRlbHkgd2hlbiBlbmNvdW50ZXJpbmcgYW4gZXJyb3IuXG4gIHNoeC5zZXQoJy1lJyk7XG5cbiAgLy8gS2VlcCB0cmFjayBvZiB3aGV0aGVyIGFuIGVycm9yIGhhcyBvY2N1cmVkIHNvIHRoYXQgd2UgY2FuIHJldHVybiBhbiBhcHByb3ByaWF0ZSBleGl0IGNvZGUuXG4gIGxldCBlcnJvckhhc09jY3VyZWQgPSBmYWxzZTtcblxuICAvLyBUaGlzIHV0aWxpdHkgZXhwZWN0cyBhbGwgb2YgaXRzIGFyZ3VtZW50cyB0byBiZSBzcGVjaWZpZWQgaW4gYSBwYXJhbXMgZmlsZSBnZW5lcmF0ZWQgYnlcbiAgLy8gYmF6ZWwgKHNlZSBodHRwczovL2RvY3MuYmF6ZWwuYnVpbGQvdmVyc2lvbnMvbWFzdGVyL3NreWxhcmsvbGliL0FyZ3MuaHRtbCN1c2VfcGFyYW1fZmlsZSkuXG4gIGNvbnN0IHBhcmFtRmlsZVBhdGggPSBhcmdzWzBdO1xuXG4gIC8vIEJhemVsIHBhcmFtcyBtYXkgYmUgc3Vycm91bmRlZCB3aXRoIHF1b3Rlc1xuICBmdW5jdGlvbiB1bnF1b3RlUGFyYW1ldGVyKHM6IHN0cmluZykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoL14nKC4qKSckLywgJyQxJyk7XG4gIH1cblxuICAvLyBQYXJhbWV0ZXJzIGFyZSBzcGVjaWZpZWQgaW4gdGhlIGZpbGUgb25lIHBlciBsaW5lLlxuICBjb25zdCBwYXJhbXMgPSBmcy5yZWFkRmlsZVN5bmMocGFyYW1GaWxlUGF0aCwgJ3V0Zi04Jykuc3BsaXQoJ1xcbicpLm1hcCh1bnF1b3RlUGFyYW1ldGVyKTtcblxuICBjb25zdCBbXG4gICAgICAvLyBPdXRwdXQgZGlyZWN0b3J5IGZvciB0aGUgbnBtIHBhY2thZ2UuXG4gICAgICBvdXQsXG5cbiAgICAgIC8vIFRoZSBwYWNrYWdlIHNlZ21lbnQgb2YgdGhlIG5nX3BhY2thZ2UgcnVsZSdzIGxhYmVsIChlLmcuICdwYWNrYWdlL2NvbW1vbicpLlxuICAgICAgc3JjRGlyLFxuXG4gICAgICAvLyBUaGUgYmF6ZWwtYmluIGRpciBqb2luZWQgd2l0aCB0aGUgc3JjRGlyIChlLmcuICdiYXplbC1iaW4vcGFja2FnZS5jb21tb24nKS5cbiAgICAgIC8vIFRoaXMgaXMgdGhlIGludGVuZGVkIG91dHB1dCBsb2NhdGlvbiBmb3IgcGFja2FnZSBhcnRpZmFjdHMuXG4gICAgICBiaW5EaXIsXG5cbiAgICAgIC8vIFRoZSBiYXplbC1nZW5maWxlcyBkaXIgam9pbmVkIHdpdGggdGhlIHNyY0RpciAoZS5nLiAnYmF6ZWwtYmluL3BhY2thZ2UuY29tbW9uJykuXG4gICAgICBnZW5maWxlc0RpcixcblxuICAgICAgLy8gSlNPTiBkYXRhIG1hcHBpbmcgZWFjaCBlbnRyeSBwb2ludCB0byB0aGUgZ2VuZXJhdGVkIGJ1bmRsZSBpbmRleCBhbmRcbiAgICAgIC8vIGZsYXQgbW9kdWxlIG1ldGFkYXRhLCBmb3IgZXhhbXBsZVxuICAgICAgLy8ge1wiQGFuZ3VsYXIvY29yZVwiOiB7XG4gICAgICAvLyAgICAgXCJpbmRleFwiOiBcImJhemVsLWJpbi9wYWNrYWdlcy9jb3JlL2NvcmUuanNcIixcbiAgICAgIC8vICAgICBcInR5cGluZ3NcIjogXCJiYXplbC1iaW4vcGFja2FnZXMvY29yZS9jb3JlLmQudHNcIixcbiAgICAgIC8vICAgICBcIm1ldGFkYXRhXCI6IFwiYmF6ZWwtYmluL3BhY2thZ2VzL2NvcmUvY29yZS5tZXRhZGF0YS5qc29uXCJcbiAgICAgIC8vICB9LFxuICAgICAgLy8gLi4uXG4gICAgICAvLyB9XG4gICAgICBtb2R1bGVzTWFuaWZlc3RBcmcsXG5cbiAgICAgIC8vIFBhdGggdG8gdGhlIHBhY2thZ2UncyBSRUFETUUubWQuXG4gICAgICByZWFkbWVNZCxcblxuICAgICAgLy8gTGlzdCBvZiByb2xsZWQtdXAgZmxhdCBFUzIwMTUgbW9kdWxlc1xuICAgICAgZmVzbTIwMTVBcmcsXG5cbiAgICAgIC8vIExpc3Qgb2YgaW5kaXZpZHVhbCBFUzIwMTUgbW9kdWxlc1xuICAgICAgZXNtMjAxNUFyZyxcblxuICAgICAgLy8gTGlzdCBvZiBhbGwgVU1EIGJ1bmRsZXMgZ2VuZXJhdGVkIGJ5IHJvbGx1cC5cbiAgICAgIGJ1bmRsZXNBcmcsXG5cbiAgICAgIC8vIExpc3Qgb2YgYWxsIGZpbGVzIGluIHRoZSBuZ19wYWNrYWdlIHJ1bGUncyBzcmNzLlxuICAgICAgc3Jjc0FyZyxcblxuICAgICAgLy8gTGlzdCBvZiBhbGwgdHlwZSBkZWZpbml0aW9ucyB0aGF0IG5lZWQgdG8gcGFja2FnZWQgaW50byB0aGUgbmdfcGFja2FnZS5cbiAgICAgIHR5cGVEZWZpbml0aW9uc0FyZyxcblxuICAgICAgLy8gTGlzdCBvZiBhbGwgZmlsZXMgaW4gdGhlIG5nX3BhY2thZ2UgcnVsZSdzIGRhdGEuXG4gICAgICBkYXRhQXJnLFxuXG4gICAgICAvLyBQYXRoIHRvIHRoZSBwYWNrYWdlJ3MgTElDRU5TRS5cbiAgICAgIGxpY2Vuc2VGaWxlLFxuXG4gICAgICAvLyBMaXN0IG9mIGFsbCBkdHMgYnVuZGxlcyBnZW5lcmF0ZWQgYnkgdGhlIEFQSSBleHRyYWN0b3IuXG4gICAgICBkdHNCdW5kbGVBcmcsXG5cbiAgICAgIC8vIFRoZSBkdHMgYnVuZGxlIGZpbGUgc3VmZml4IGV4YW1wbGU6ICcuYnVuZGxlLmQudHMnXG4gICAgICBkdHNCdW5kbGVGaWxlU3VmZml4LFxuICBdID0gcGFyYW1zO1xuXG4gIGNvbnN0IGZlc20yMDE1ID0gZmVzbTIwMTVBcmcuc3BsaXQoJywnKS5maWx0ZXIocyA9PiAhIXMpO1xuICBjb25zdCBlc20yMDE1ID0gZXNtMjAxNUFyZy5zcGxpdCgnLCcpLmZpbHRlcihzID0+ICEhcyk7XG4gIGNvbnN0IGJ1bmRsZXMgPSBidW5kbGVzQXJnLnNwbGl0KCcsJykuZmlsdGVyKHMgPT4gISFzKTtcbiAgY29uc3QgdHlwZURlZmluaXRpb25zID0gdHlwZURlZmluaXRpb25zQXJnLnNwbGl0KCcsJykuZmlsdGVyKHMgPT4gISFzKTtcbiAgY29uc3Qgc3JjcyA9IHNyY3NBcmcuc3BsaXQoJywnKS5maWx0ZXIocyA9PiAhIXMpO1xuICBjb25zdCBkYXRhRmlsZXM6IHN0cmluZ1tdID0gZGF0YUFyZy5zcGxpdCgnLCcpLmZpbHRlcihzID0+ICEhcyk7XG4gIGNvbnN0IG1vZHVsZXNNYW5pZmVzdCA9IEpTT04ucGFyc2UobW9kdWxlc01hbmlmZXN0QXJnKSBhcyBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICBjb25zdCBkdHNCdW5kbGVzOiBzdHJpbmdbXSA9IGR0c0J1bmRsZUFyZy5zcGxpdCgnLCcpLmZpbHRlcihzID0+ICEhcyk7XG5cbiAgLyoqXG4gICAqIExpc3Qgb2Yga25vd24gYHBhY2thZ2UuanNvbmAgZmllbGRzIHdoaWNoIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXRcbiAgICogc3VwcG9ydGVkIHBhY2thZ2UgZm9ybWF0cyBhbmQgdGhlaXIgYXNzb2NpYXRlZCBlbnRyeSBwYXRocy5cbiAgICovXG4gIGNvbnN0IGtub3duRm9ybWF0UGFja2FnZUpzb25GaWVsZHMgPVxuICAgICAgWydtYWluJywgJ2Zlc20yMDE1JywgJ2VzbTIwMTUnLCAndHlwaW5ncycsICdtb2R1bGUnLCAnZXMyMDE1J107XG5cbiAgaWYgKHJlYWRtZU1kKSB7XG4gICAgY29weUZpbGUocmVhZG1lTWQsIG91dCk7XG4gIH1cblxuICAvKipcbiAgICogV3JpdGVzIGEgZmlsZSBpbnRvIHRoZSBwYWNrYWdlIGJhc2VkIG9uIGl0cyBpbnB1dCBwYXRoLCByZWxhdGl2aXppbmcgdG8gdGhlIHBhY2thZ2UgcGF0aC5cbiAgICogQHBhcmFtIGlucHV0UGF0aCBQYXRoIHRvIHRoZSBmaWxlIGluIHRoZSBpbnB1dCB0cmVlLlxuICAgKiBAcGFyYW0gZmlsZUNvbnRlbnQgQ29udGVudCBvZiB0aGUgZmlsZS5cbiAgICovXG4gIGZ1bmN0aW9uIHdyaXRlRmlsZUZyb21JbnB1dFBhdGgoaW5wdXRQYXRoOiBzdHJpbmcsIGZpbGVDb250ZW50OiBzdHJpbmd8QnVmZmVyKSB7XG4gICAgLy8gV2Ugd2FudCB0aGUgcmVsYXRpdmUgcGF0aCBmcm9tIHRoZSBnaXZlbiBmaWxlIHRvIGl0cyBhbmNlc3RvciBcInJvb3RcIiBkaXJlY3RvcnkuXG4gICAgLy8gVGhpcyByb290IGRlcGVuZHMgb24gd2hldGhlciB0aGUgZmlsZSBsaXZlcyBpbiB0aGUgc291cmNlIHRyZWUgKHNyY0RpcikgYXMgYSBiYXNpYyBmaWxlXG4gICAgLy8gaW5wdXQgdG8gbmdfcGFja2FnZSwgdGhlIGJpbiBvdXRwdXQgdHJlZSAoYmluRGlyKSBhcyB0aGUgb3V0cHV0IG9mIGFub3RoZXIgcnVsZSwgb3JcbiAgICAvLyB0aGUgZ2VuZmlsZXMgb3V0cHV0IHRyZWUgKGdlbmZpbGVzRGlyKSBhcyB0aGUgb3V0cHV0IG9mIGEgZ2VucnVsZS5cbiAgICBsZXQgcm9vdERpcjogc3RyaW5nO1xuICAgIGlmIChpbnB1dFBhdGguaW5jbHVkZXMoYmluRGlyKSkge1xuICAgICAgcm9vdERpciA9IGJpbkRpcjtcbiAgICB9IGVsc2UgaWYgKGlucHV0UGF0aC5pbmNsdWRlcyhnZW5maWxlc0RpcikpIHtcbiAgICAgIHJvb3REaXIgPSBnZW5maWxlc0RpcjtcbiAgICB9IGVsc2Uge1xuICAgICAgcm9vdERpciA9IHNyY0RpcjtcbiAgICB9XG5cbiAgICBjb25zdCBvdXRwdXRQYXRoID0gcGF0aC5qb2luKG91dCwgcGF0aC5yZWxhdGl2ZShyb290RGlyLCBpbnB1dFBhdGgpKTtcblxuICAgIC8vIEFsd2F5cyBlbnN1cmUgdGhhdCB0aGUgdGFyZ2V0IGRpcmVjdG9yeSBleGlzdHMuXG4gICAgc2h4Lm1rZGlyKCctcCcsIHBhdGguZGlybmFtZShvdXRwdXRQYXRoKSk7XG4gICAgZnMud3JpdGVGaWxlU3luYyhvdXRwdXRQYXRoLCBmaWxlQ29udGVudCk7XG4gIH1cblxuICAvKipcbiAgICogQ29waWVzIGEgZmlsZSBpbnRvIHRoZSBwYWNrYWdlIGJhc2VkIG9uIGl0cyBpbnB1dCBwYXRoLCByZWxhdGl2aXppbmcgdG8gdGhlIHBhY2thZ2UgcGF0aC5cbiAgICogQHBhcmFtIGlucHV0UGF0aCBhIHBhdGggcmVsYXRpdmUgdG8gdGhlIGJpbkRpciwgdHlwaWNhbGx5IGZyb20gYSBmaWxlIGluIHRoZSBkZXBzW11cbiAgICovXG4gIGZ1bmN0aW9uIGNvcHlGaWxlRnJvbUlucHV0UGF0aChpbnB1dFBhdGg6IHN0cmluZykge1xuICAgIHdyaXRlRmlsZUZyb21JbnB1dFBhdGgoaW5wdXRQYXRoLCBmcy5yZWFkRmlsZVN5bmMoaW5wdXRQYXRoKSk7XG4gIH1cblxuICAvKipcbiAgICogUmVsYXRpdml6ZSB0aGUgcGF0aCB3aGVyZSBhIGZpbGUgaXMgd3JpdHRlbi5cbiAgICogQHBhcmFtIGZpbGUgYSBwYXRoIGNvbnRhaW5pbmcgYSByZS1yb290ZWQgc2VnbWVudCBsaWtlIGAuZXNtMjAxNWBcbiAgICogQHBhcmFtIG91dERpciBwYXRoIHdoZXJlIHdlIGNvcHkgdGhlIGZpbGUsIHJlbGF0aXZlIHRvIHRoZSBvdXRcbiAgICovXG4gIGZ1bmN0aW9uIHdyaXRlRXNtRmlsZShmaWxlOiBzdHJpbmcsIG91dERpcjogc3RyaW5nKSB7XG4gICAgLy8gUGF0aCBjb21wdXRlZCByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBwYWNrYWdlIGluIGJhemVsLWJpbi4gZS5nLiBhIEVTMjAxNSBvdXRwdXQgZmlsZVxuICAgIC8vIGluIGBiYXplbC1vdXQvPC4uPi9wYWNrYWdlcy9jb3JlL3NyYy9kaS5qc2Agc2hvdWxkIGJlIHN0b3JlZCBpbiBge291dF9kaXJ9L3NyYy9kaS5qc2BcbiAgICAvLyBpZiB0aGUgcGFja2FnZSB0YXJnZXQgaGFzIGJlZW4gZGVjbGFyZWQgaW4gYDwuLj4vcGFja2FnZXMvY29yZWAuXG4gICAgY29uc3QgcGFja2FnZVJlbGF0aXZlUGF0aCA9IHBhdGguZGlybmFtZShwYXRoLnJlbGF0aXZlKGJpbkRpciwgZmlsZSkpO1xuICAgIGlmICghcGFja2FnZVJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKCcuLicpKSB7XG4gICAgICBjb3B5RmlsZShmaWxlLCBwYXRoLmpvaW4ob3V0LCBvdXREaXIpLCBwYWNrYWdlUmVsYXRpdmVQYXRoKTtcbiAgICB9XG4gIH1cblxuICBlc20yMDE1LmZvckVhY2goZmlsZSA9PiB3cml0ZUVzbUZpbGUoZmlsZSwgJ2VzbTIwMTUnKSk7XG5cbiAgYnVuZGxlcy5mb3JFYWNoKGJ1bmRsZSA9PiB7XG4gICAgY29weUZpbGUoYnVuZGxlLCBvdXQsICdidW5kbGVzJyk7XG4gIH0pO1xuICBmZXNtMjAxNS5mb3JFYWNoKGZpbGUgPT4ge1xuICAgIGNvcHlGaWxlKGZpbGUsIG91dCwgJ2Zlc20yMDE1Jyk7XG4gIH0pO1xuXG4gIC8vIENvcHkgYWxsIHR5cGUgZGVmaW5pdGlvbnMgaW50byB0aGUgcGFja2FnZS4gVGhpcyBpcyBuZWNlc3Nhcnkgc28gdGhhdCBkZXZlbG9wZXJzIGNhbiB1c2VcbiAgLy8gdGhlIHBhY2thZ2Ugd2l0aCB0eXBlIGRlZmluaXRpb25zLlxuICB0eXBlRGVmaW5pdGlvbnMuZm9yRWFjaChmID0+IHdyaXRlRmlsZUZyb21JbnB1dFBhdGgoZiwgcmVhZFR5cGluZ3NBbmRTdHJpcEFtZE1vZHVsZShmKSkpO1xuXG4gIC8vIENvcHkgYWxsIGBkYXRhYCBmaWxlcyBpbnRvIHRoZSBwYWNrYWdlLiBUaGVzZSBhcmUgZmlsZXMgdGhhdCBhcmVuJ3QgYnVpbHQgYnkgdGhlIG5nX3BhY2thZ2VcbiAgLy8gcnVsZSwgYnV0IGluc3RlYWQgYXJlIGp1c3Qgc3RyYWlnaHQgY29waWVkIGludG8gdGhlIHBhY2thZ2UsIGUuZy4gZ2xvYmFsIENTUyBhc3NldHMuXG4gIGRhdGFGaWxlcy5mb3JFYWNoKGYgPT4gY29weUZpbGVGcm9tSW5wdXRQYXRoKGYpKTtcblxuICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIGVudHJ5IHBvaW50IG1vZHVsZXNcbiAgLy8gV2UgZG8gdGhpcyBmaXJzdCBiZWNhdXNlIHdlIGFsc28gcmVjb3JkIG5ldyBwYXRocyBmb3IgdGhlIGVzbTUgYW5kIGVzbTIwMTUgY29waWVzXG4gIC8vIG9mIHRoZSBpbmRleCBKUyBmaWxlLCB3aGljaCB3ZSBuZWVkIHRvIGFtZW5kIHRoZSBwYWNrYWdlLmpzb24uXG4gIE9iamVjdC5rZXlzKG1vZHVsZXNNYW5pZmVzdCkuZm9yRWFjaChtb2R1bGVOYW1lID0+IHtcbiAgICBjb25zdCBtb2R1bGVGaWxlcyA9IG1vZHVsZXNNYW5pZmVzdFttb2R1bGVOYW1lXTtcbiAgICBjb25zdCByZWxhdGl2ZSA9IHBhdGgucmVsYXRpdmUoYmluRGlyLCBtb2R1bGVGaWxlc1snaW5kZXgnXSk7XG5cbiAgICBtb2R1bGVGaWxlc1snZXNtMjAxNV9pbmRleCddID0gcGF0aC5qb2luKGJpbkRpciwgJ2VzbTIwMTUnLCByZWxhdGl2ZSk7XG5cbiAgICAvLyBNZXRhZGF0YSBmaWxlIGlzIG9wdGlvbmFsIGFzIGVudHJ5LXBvaW50cyBjYW4gYmUgYnVpbHQgd2l0aCB0aGUgYHRzX2xpYnJhcnlgXG4gICAgLy8gcnVsZSBvciBgbmdfbW9kdWxlYCBydWxlIGluIEl2eSBtb2RlLlxuICAgIGNvbnN0IG1ldGFkYXRhRmlsZSA9IG1vZHVsZUZpbGVzWydtZXRhZGF0YSddO1xuICAgIGlmICghbWV0YWRhdGFGaWxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdHlwaW5nc091dEZpbGUgPSBtb2R1bGVGaWxlc1sndHlwaW5ncyddO1xuICAgIC8vIFdlIG9ubHkgc3VwcG9ydCBhbGwgbW9kdWxlcyB3aXRoaW4gYSBwYWNrYWdlIHRvIGJlIGR0cyBidW5kbGVkXG4gICAgLy8gaWU6IGlmIEBhbmd1bGFyL2NvbW1vbi9odHRwIGhhcyBmbGF0IGR0cywgc28gc2hvdWxkIEBhbmd1bGFyL2NvbW1vblxuICAgIGlmIChkdHNCdW5kbGVzLmxlbmd0aCkge1xuICAgICAgY29uc3QgbWV0YWRhdGFDb250ZW50ID0gcmV3aXJlTWV0YWRhdGEobWV0YWRhdGFGaWxlLCB0eXBpbmdzT3V0RmlsZSk7XG4gICAgICB3cml0ZUZpbGVGcm9tSW5wdXRQYXRoKG1ldGFkYXRhRmlsZSwgbWV0YWRhdGFDb250ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29weUZpbGVGcm9tSW5wdXRQYXRoKG1ldGFkYXRhRmlsZSk7XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBsaWNlbnNlQmFubmVyID0gbGljZW5zZUZpbGUgPyBmcy5yZWFkRmlsZVN5bmMobGljZW5zZUZpbGUsICd1dGYtOCcpIDogJyc7XG5cbiAgZHRzQnVuZGxlcy5mb3JFYWNoKGJ1bmRsZUZpbGUgPT4ge1xuICAgIGNvbnN0IGNsZWFuRGlzdFBhdGggPSBidW5kbGVGaWxlLnJlcGxhY2UoZHRzQnVuZGxlRmlsZVN1ZmZpeCwgJy5kLnRzJyk7XG4gICAgLy8gQVBJIGV4dHJhY3RvciB3aWxsIG5vdCBkZWR1cGUgbGljZW5zZSBjb21tZW50cyBmcm9tIHZhcmlvdXMgZmlsZXNcbiAgICAvLyB0aGlzIHdpbGwgcmVtb3ZlIGFsbCB0aGUgbGljZW5zZSBjb21tZW50cyBhbmQgYXBwZW5kIHRoZSBsaWNlbnNlIGJhbm5lci5cbiAgICBjb25zdCBjb250ZW50ID0gbGljZW5zZUJhbm5lciArICdcXG4nICtcbiAgICAgICAgcmVhZFR5cGluZ3NBbmRTdHJpcEFtZE1vZHVsZShidW5kbGVGaWxlKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyhcXC9cXCpcXCpcXHMrXFwqXFxzXFxAbGljZW5zZSgoKD8hXFwqXFwvKS58XFxzKSopXFwqXFwvKS9nbSwgJycpO1xuXG4gICAgd3JpdGVGaWxlRnJvbUlucHV0UGF0aChjbGVhbkRpc3RQYXRoLCBjb250ZW50KTtcbiAgfSk7XG5cbiAgLy8gUm9vdCBwYWNrYWdlIG5hbWUgKGUuZy4gJ0Bhbmd1bGFyL2NvbW1vbicpLCBjYXB0dXJlcyBhcyB3ZSBpdGVyYXRlIHRocm91Z2ggc291cmNlcyBiZWxvdy5cbiAgbGV0IHJvb3RQYWNrYWdlTmFtZSA9ICcnO1xuICBjb25zdCBwYWNrYWdlc1dpdGhFeGlzdGluZ1BhY2thZ2VKc29uID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgZm9yIChjb25zdCBzcmMgb2Ygc3Jjcykge1xuICAgIGlmIChzcmMuaW5jbHVkZXMoYmluRGlyKSB8fCBzcmMuaW5jbHVkZXMoZ2VuZmlsZXNEaXIpKSB7XG4gICAgICBlcnJvckhhc09jY3VyZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAnVGhlIFwic3Jjc1wiIGZvciBuZ19wYWNrYWdlIHNob3VsZCBub3QgaW5jbHVkZSBvdXRwdXQgb2Ygb3RoZXIgcnVsZXMuIEZvdW5kOlxcbicgK1xuICAgICAgICAgIGAgICR7c3JjfWApO1xuICAgIH1cblxuICAgIGxldCBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKHNyYywgJ3V0Zi04Jyk7XG4gICAgLy8gTW9kaWZ5IHBhY2thZ2UuanNvbiBmaWxlcyBhcyBuZWNlc3NhcnkgZm9yIHB1Ymxpc2hpbmdcbiAgICBpZiAocGF0aC5iYXNlbmFtZShzcmMpID09PSAncGFja2FnZS5qc29uJykge1xuICAgICAgY29uc3QgcGFja2FnZUpzb24gPSBKU09OLnBhcnNlKGNvbnRlbnQpIGFzIHtba2V5OiBzdHJpbmddOiBzdHJpbmd9O1xuICAgICAgY29udGVudCA9IGFtZW5kUGFja2FnZUpzb24oc3JjLCBwYWNrYWdlSnNvbiwgZmFsc2UpO1xuXG4gICAgICBjb25zdCBwYWNrYWdlTmFtZSA9IHBhY2thZ2VKc29uWyduYW1lJ107XG4gICAgICBwYWNrYWdlc1dpdGhFeGlzdGluZ1BhY2thZ2VKc29uLmFkZChwYWNrYWdlTmFtZSk7XG5cbiAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIHJvb3QgcGFja2FnZSBuYW1lLCBlLmcuIFwiQGFuZ3VsYXIvY29tbW9uXCIuIFdlIGFzc3VtZSB0aGF0IHRoZVxuICAgICAgLy8gcm9vdCBuYW1lIHdpbGwgYmUgc2hvcnRlc3QgYmVjYXVzZSBzZWNvbmRhcnkgZW50cnktcG9pbnRzIHdpbGwgYXBwZW5kIHRvIGl0XG4gICAgICAvLyAoZS5nLiBcIkBhbmd1bGFyL2NvbW1vbi9odHRwXCIpLlxuICAgICAgaWYgKCFyb290UGFja2FnZU5hbWUgfHwgcGFja2FnZU5hbWUubGVuZ3RoIDwgcm9vdFBhY2thZ2VOYW1lLmxlbmd0aCkge1xuICAgICAgICByb290UGFja2FnZU5hbWUgPSBwYWNrYWdlSnNvblsnbmFtZSddO1xuICAgICAgfVxuICAgIH1cbiAgICB3cml0ZUZpbGVGcm9tSW5wdXRQYXRoKHNyYywgY29udGVudCk7XG4gIH1cblxuICAvLyBHZW5lcmF0ZSBleHRyYSBmaWxlcyBmb3Igc2Vjb25kYXJ5IGVudHJ5LXBvaW50cy5cbiAgT2JqZWN0LmtleXMobW9kdWxlc01hbmlmZXN0KS5mb3JFYWNoKGVudHJ5UG9pbnRQYWNrYWdlTmFtZSA9PiB7XG4gICAgY29uc3QgZW50cnlQb2ludE5hbWUgPSBlbnRyeVBvaW50UGFja2FnZU5hbWUuc3Vic3RyKHJvb3RQYWNrYWdlTmFtZS5sZW5ndGggKyAxKTtcbiAgICBpZiAoIWVudHJ5UG9pbnROYW1lKSByZXR1cm47XG5cbiAgICBjb25zdCBtZXRhZGF0YUZpbGVQYXRoID0gbW9kdWxlc01hbmlmZXN0W2VudHJ5UG9pbnRQYWNrYWdlTmFtZV1bJ21ldGFkYXRhJ107XG4gICAgaWYgKG1ldGFkYXRhRmlsZVBhdGgpIHtcbiAgICAgIGNyZWF0ZU1ldGFkYXRhUmVleHBvcnRGaWxlKFxuICAgICAgICAgIGVudHJ5UG9pbnROYW1lLCBtb2R1bGVzTWFuaWZlc3RbZW50cnlQb2ludFBhY2thZ2VOYW1lXVsnbWV0YWRhdGEnXSxcbiAgICAgICAgICBlbnRyeVBvaW50UGFja2FnZU5hbWUpO1xuICAgIH1cblxuICAgIGNyZWF0ZVR5cGluZ3NSZWV4cG9ydEZpbGUoXG4gICAgICAgIGVudHJ5UG9pbnROYW1lLCBsaWNlbnNlQmFubmVyLCBtb2R1bGVzTWFuaWZlc3RbZW50cnlQb2ludFBhY2thZ2VOYW1lXVsndHlwaW5ncyddKTtcblxuICAgIGlmICghcGFja2FnZXNXaXRoRXhpc3RpbmdQYWNrYWdlSnNvbi5oYXMoZW50cnlQb2ludFBhY2thZ2VOYW1lKSkge1xuICAgICAgY3JlYXRlRW50cnlQb2ludFBhY2thZ2VKc29uKGVudHJ5UG9pbnROYW1lLCBlbnRyeVBvaW50UGFja2FnZU5hbWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGVycm9ySGFzT2NjdXJlZCA/IDEgOiAwO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgYmluRGlyLXJlbGF0aXZlIHBhdGggdG8gc3JjRGlyLXJlbGF0aXZlXG4gICAqIEBwYXJhbSBmcm9tIHBhdGggdG8gYSBmaWxlIHVuZGVyIHRoZSBzcmNEaXIsIGxpa2UgcGFja2FnZXMvY29yZS90ZXN0aW5nL3BhY2thZ2UuanNvblxuICAgKiBAcGFyYW0gZmlsZSBwYXRoIHRvIGEgZmlsZSB1bmRlciB0aGUgYmluRGlyLCBsaWtlIGJhemVsLWJpbi9jb3JlL3Rlc3RpbmcvZ2VuZXJhdGVkLmpzXG4gICAqL1xuICBmdW5jdGlvbiBzcmNEaXJSZWxhdGl2ZShmcm9tOiBzdHJpbmcsIGZpbGU6IHN0cmluZykge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5vcm1hbGl6ZVNlcGFyYXRvcnMoXG4gICAgICAgIHBhdGgucmVsYXRpdmUocGF0aC5kaXJuYW1lKGZyb20pLCBwYXRoLmpvaW4oc3JjRGlyLCBwYXRoLnJlbGF0aXZlKGJpbkRpciwgZmlsZSkpKSk7XG4gICAgaWYgKHJlc3VsdC5zdGFydHNXaXRoKCcuLicpKSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiBgLi8ke3Jlc3VsdH1gO1xuICB9XG5cbiAgZnVuY3Rpb24gY29weUZpbGUoZmlsZTogc3RyaW5nLCBiYXNlRGlyOiBzdHJpbmcsIHJlbGF0aXZlID0gJy4nKSB7XG4gICAgY29uc3QgZGlyID0gcGF0aC5qb2luKGJhc2VEaXIsIHJlbGF0aXZlKTtcbiAgICAvLyBvdXRwdXQgZmlsZSBpcyAuanMgaWYgdGhlIGlucHV0IGZpbGUgaXMgLm1qc1xuICAgIGNvbnN0IG91dEZpbGUgPSBwYXRoLnBvc2l4LmpvaW4oXG4gICAgICAgIGRpciwgcGF0aC5iYXNlbmFtZShmaWxlLmVuZHNXaXRoKCcubWpzJykgPyBmaWxlLnJlcGxhY2UoL1xcLm1qcyQvLCAnLmpzJykgOiBmaWxlKSk7XG4gICAgc2h4Lm1rZGlyKCctcCcsIGRpcik7XG4gICAgc2h4LmNwKGZpbGUsIG91dEZpbGUpO1xuICAgIC8vIERvdWJsZS11bmRlcnNjb3JlIGlzIHVzZWQgdG8gZXNjYXBlIGZvcndhcmQgc2xhc2ggaW4gRkVTTSBmaWxlbmFtZXMuXG4gICAgLy8gU2VlIG5nX3BhY2thZ2UuYnpsOlxuICAgIC8vICAgZmVzbV9vdXRwdXRfZmlsZW5hbWUgPSBlbnRyeV9wb2ludC5yZXBsYWNlKFwiL1wiLCBcIl9fXCIpXG4gICAgLy8gV2UgbmVlZCB0byB1bmVzY2FwZSB0aGVzZS5cbiAgICBpZiAob3V0RmlsZS5pbmRleE9mKCdfXycpID49IDApIHtcbiAgICAgIGNvbnN0IG91dHB1dFBhdGggPSBwYXRoLmpvaW4oZGlyLCAuLi5wYXRoLmJhc2VuYW1lKG91dEZpbGUpLnNwbGl0KCdfXycpKTtcbiAgICAgIHNoeC5ta2RpcignLXAnLCBwYXRoLmRpcm5hbWUob3V0cHV0UGF0aCkpO1xuICAgICAgc2h4Lm12KHBhdGguam9pbihkaXIsIHBhdGguYmFzZW5hbWUoZmlsZSkpLCBvdXRwdXRQYXRoKTtcblxuICAgICAgLy8gaWYgd2UgYXJlIHJlbmFtaW5nIHRoZSAuanMgZmlsZSwgd2UnbGwgYWxzbyBuZWVkIHRvIHVwZGF0ZSB0aGUgc291cmNlTWFwcGluZ1VSTCBpbiB0aGUgZmlsZVxuICAgICAgaWYgKG91dEZpbGUuZW5kc1dpdGgoJy5qcycpKSB7XG4gICAgICAgIHNoeC5jaG1vZCgnK3cnLCBvdXRwdXRQYXRoKTtcbiAgICAgICAgc2h4LnNlZCgnLWknLCBgJHtwYXRoLmJhc2VuYW1lKGZpbGUpfS5tYXBgLCBgJHtwYXRoLmJhc2VuYW1lKG91dHB1dFBhdGgpfS5tYXBgLCBvdXRwdXRQYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0cyBvciBlZGl0cyBwcm9wZXJ0aWVzIGludG8gdGhlIHBhY2thZ2UuanNvbiBmaWxlKHMpIGluIHRoZSBwYWNrYWdlIHNvIHRoYXRcbiAgICogdGhleSBwb2ludCB0byBhbGwgdGhlIHJpZ2h0IGdlbmVyYXRlZCBhcnRpZmFjdHMuXG4gICAqXG4gICAqIEBwYXJhbSBwYWNrYWdlSnNvbiBUaGUgcGF0aCB0byB0aGUgcGFja2FnZS5qc29uIGZpbGUuXG4gICAqIEBwYXJhbSBwYXJzZWRQYWNrYWdlIFBhcnNlZCBwYWNrYWdlLmpzb24gY29udGVudFxuICAgKiBAcGFyYW0gaXNHZW5lcmF0ZWRQYWNrYWdlSnNvbiBXaGV0aGVyIHRoZSBwYXNzZWQgcGFja2FnZS5qc29uIGhhcyBiZWVuIGdlbmVyYXRlZC5cbiAgICovXG4gIGZ1bmN0aW9uIGFtZW5kUGFja2FnZUpzb24oXG4gICAgICBwYWNrYWdlSnNvbjogc3RyaW5nLCBwYXJzZWRQYWNrYWdlOiB7W2tleTogc3RyaW5nXTogc3RyaW5nfSxcbiAgICAgIGlzR2VuZXJhdGVkUGFja2FnZUpzb246IGJvb2xlYW4pIHtcbiAgICBjb25zdCBwYWNrYWdlTmFtZSA9IHBhcnNlZFBhY2thZ2VbJ25hbWUnXTtcbiAgICBjb25zdCBtb2R1bGVEYXRhID0gbW9kdWxlc01hbmlmZXN0W3BhY2thZ2VOYW1lXTtcblxuICAgIC8vIElmIGEgcGFja2FnZSBqc29uIGZpbGUgaGFzIGJlZW4gZGlzY292ZXJlZCB0aGF0IGRvZXMgbm90IG1hdGNoIGFueVxuICAgIC8vIG1vZHVsZSBpbiB0aGUgbWFuaWZlc3QsIHdlIHJlcG9ydCBhIHdhcm5pbmcgYXMgbW9zdCBsaWtlbHkgdGhlIHRhcmdldFxuICAgIC8vIGlzIGNvbmZpZ3VyZWQgaW5jb3JyZWN0bHkgKGUuZy4gbWlzc2luZyBgbW9kdWxlX25hbWVgIGF0dHJpYnV0ZSkuXG4gICAgaWYgKCFtb2R1bGVEYXRhKSB7XG4gICAgICAvLyBJZGVhbGx5IHdlIHNob3VsZCB0aHJvdyBoZXJlLCBhcyB3ZSBnb3QgYW4gZW50cnkgcG9pbnQgdGhhdCBkb2Vzbid0XG4gICAgICAvLyBoYXZlIGZsYXQgbW9kdWxlIG1ldGFkYXRhIC8gYnVuZGxlIGluZGV4LCBzbyBpdCBtYXkgaGF2ZSBiZWVuIGFuXG4gICAgICAvLyBuZ19tb2R1bGUgdGhhdCdzIG1pc3NpbmcgYSBtb2R1bGVfbmFtZSBhdHRyaWJ1dGUuXG4gICAgICAvLyBIb3dldmVyLCBAYW5ndWxhci9jb21waWxlciBjYW4ndCBiZSBhbiBuZ19tb2R1bGUsIGFzIGl0J3MgdGhlIGludGVybmFsc1xuICAgICAgLy8gb2YgdGhlIG5nYyBjb21waWxlciwgeWV0IHdlIHdhbnQgdG8gYnVpbGQgYW4gbmdfcGFja2FnZSBmb3IgaXQuXG4gICAgICAvLyBTbyBpZ25vcmUgcGFja2FnZS5qc29uIGZpbGVzIHdoZW4gd2UgYXJlIG1pc3NpbmcgZGF0YS5cbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1dBUk5JTkc6IG5vIG1vZHVsZSBtZXRhZGF0YSBmb3IgcGFja2FnZScsIHBhY2thZ2VOYW1lKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyAgIE5vdCB1cGRhdGluZyB0aGUgcGFja2FnZS5qc29uIGZpbGUgdG8gcG9pbnQgdG8gaXQnKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgJyAgIFRoZSBuZ19tb2R1bGUgZm9yIHRoaXMgcGFja2FnZSBpcyBwb3NzaWJseSBtaXNzaW5nIHRoZSBtb2R1bGVfbmFtZSBhdHRyaWJ1dGUgJyk7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGFyc2VkUGFja2FnZSwgbnVsbCwgMik7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZ3Vlc3NlZCB0aGUgaW5kZXggcGF0aHMgZm9yIGEgbW9kdWxlLCBhbmQgaXQgY29udGFpbnMgYW4gZXhwbGljaXQgYHBhY2thZ2UuanNvbmBcbiAgICAvLyBmaWxlIHRoYXQgYWxyZWFkeSBzZXRzIGZvcm1hdCBwcm9wZXJ0aWVzLCB3ZSBza2lwIGF1dG9tYXRpYyBpbnNlcnRpb24gb2YgZm9ybWF0XG4gICAgLy8gcHJvcGVydGllcyBidXQgcmVwb3J0IGEgd2FybmluZyBpbiBjYXNlIHByb3BlcnRpZXMgaGF2ZSBiZWVuIHNldCBieSBhY2NpZGVudC5cbiAgICBpZiAobW9kdWxlRGF0YS5ndWVzc2VkUGF0aHMgJiYgIWlzR2VuZXJhdGVkUGFja2FnZUpzb24gJiZcbiAgICAgICAgaGFzRXhwbGljaXRGb3JtYXRQcm9wZXJ0aWVzKHBhcnNlZFBhY2thZ2UpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdXQVJOSU5HOiBgcGFja2FnZS5qc29uYCBleHBsaWNpdGx5IHNldHMgZm9ybWF0IHByb3BlcnRpZXMgKGxpa2UgYG1haW5gKS4nKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgJyAgICBTa2lwcGluZyBhdXRvbWF0aWMgaW5zZXJ0aW9uIG9mIGZvcm1hdCBwcm9wZXJ0aWVzIGFzIGV4cGxpY2l0ICcgK1xuICAgICAgICAgICdmb3JtYXQgcHJvcGVydGllcyBhcmUgc2V0LicpO1xuICAgICAgY29uc29sZS5lcnJvcignICAgIElnbm9yZSB0aGlzIHdhcm5pbmcgaWYgZXhwbGljaXQgcHJvcGVydGllcyBhcmUgc2V0IGludGVudGlvbmFsbHkuJyk7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGFyc2VkUGFja2FnZSwgbnVsbCwgMik7XG4gICAgfVxuXG4gICAgLy8gRGVyaXZlIHRoZSBwYXRocyB0byB0aGUgZmlsZXMgZnJvbSB0aGUgaGFyZC1jb2RlZCBuYW1lcyB3ZSBnYXZlIHRoZW0uXG4gICAgLy8gVE9ETyhhbGV4ZWFnbGUpOiBpdCB3b3VsZCBiZSBiZXR0ZXIgdG8gdHJhbnNmZXIgdGhpcyBpbmZvcm1hdGlvbiBmcm9tIHRoZSBwbGFjZVxuICAgIC8vIHdoZXJlIHdlIGNyZWF0ZWQgdGhlIGZpbGVuYW1lcywgdmlhIHRoZSBtb2R1bGVzTWFuaWZlc3RBcmdcbiAgICBwYXJzZWRQYWNrYWdlWydtYWluJ10gPSBnZXRCdW5kbGVOYW1lKHBhY2thZ2VOYW1lLCAnYnVuZGxlcycpO1xuICAgIHBhcnNlZFBhY2thZ2VbJ2Zlc20yMDE1J10gPSBnZXRCdW5kbGVOYW1lKHBhY2thZ2VOYW1lLCAnZmVzbTIwMTUnKTtcblxuICAgIHBhcnNlZFBhY2thZ2VbJ2VzbTIwMTUnXSA9IHNyY0RpclJlbGF0aXZlKHBhY2thZ2VKc29uLCBtb2R1bGVEYXRhWydlc20yMDE1X2luZGV4J10pO1xuICAgIHBhcnNlZFBhY2thZ2VbJ3R5cGluZ3MnXSA9IHNyY0RpclJlbGF0aXZlKHBhY2thZ2VKc29uLCBtb2R1bGVEYXRhWyd0eXBpbmdzJ10pO1xuXG4gICAgLy8gRm9yIG5vdywgd2UgcG9pbnQgdGhlIHByaW1hcnkgZW50cnkgcG9pbnRzIGF0IHRoZSBmZXNtIGZpbGVzLCBiZWNhdXNlIG9mIFdlYnBhY2tcbiAgICAvLyBwZXJmb3JtYW5jZSBpc3N1ZXMgd2l0aCBhIGxhcmdlIG51bWJlciBvZiBpbmRpdmlkdWFsIGZpbGVzLlxuICAgIHBhcnNlZFBhY2thZ2VbJ21vZHVsZSddID0gcGFyc2VkUGFja2FnZVsnZmVzbTIwMTUnXTtcbiAgICBwYXJzZWRQYWNrYWdlWydlczIwMTUnXSA9IHBhcnNlZFBhY2thZ2VbJ2Zlc20yMDE1J107XG5cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGFyc2VkUGFja2FnZSwgbnVsbCwgMik7XG4gIH1cblxuICAvLyBlLmcuIEBhbmd1bGFyL2NvbW1vbi9odHRwL3Rlc3RpbmcgLT4gLi4vLi4vYnVuZGxlcy9jb21tb24taHR0cC10ZXN0aW5nLnVtZC5qc1xuICAvLyBvciAgIEBhbmd1bGFyL2NvbW1vbi9odHRwL3Rlc3RpbmcgLT4gLi4vLi4vZmVzbTIwMTUvaHR0cC90ZXN0aW5nLmpzXG4gIGZ1bmN0aW9uIGdldEJ1bmRsZU5hbWUocGFja2FnZU5hbWU6IHN0cmluZywgZGlyOiBzdHJpbmcpIHtcbiAgICBjb25zdCBwYXJ0cyA9IHBhY2thZ2VOYW1lLnNwbGl0KCcvJyk7XG4gICAgLy8gUmVtb3ZlIHRoZSBzY29wZWQgcGFja2FnZSBwYXJ0LCBsaWtlIEBhbmd1bGFyIGlmIHByZXNlbnRcbiAgICBjb25zdCBuYW1lUGFydHMgPSBwYWNrYWdlTmFtZS5zdGFydHNXaXRoKCdAJykgPyBwYXJ0cy5zcGxpY2UoMSkgOiBwYXJ0cztcbiAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBuZXdBcnJheShuYW1lUGFydHMubGVuZ3RoIC0gMSwgJy4uJykuam9pbignLycpIHx8ICcuJztcbiAgICBsZXQgYmFzZW5hbWU6IHN0cmluZztcbiAgICBpZiAoZGlyID09PSAnYnVuZGxlcycpIHtcbiAgICAgIGJhc2VuYW1lID0gbmFtZVBhcnRzLmpvaW4oJy0nKSArICcudW1kJztcbiAgICB9IGVsc2UgaWYgKG5hbWVQYXJ0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGJhc2VuYW1lID0gbmFtZVBhcnRzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlbmFtZSA9IG5hbWVQYXJ0cy5zbGljZSgxKS5qb2luKCcvJyk7XG4gICAgfVxuICAgIHJldHVybiBbcmVsYXRpdmVQYXRoLCBkaXIsIGJhc2VuYW1lICsgJy5qcyddLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8qKiBXaGV0aGVyIHRoZSBwYWNrYWdlIGV4cGxpY2l0bHkgc2V0cyBhbnkgb2YgdGhlIGZvcm1hdCBwcm9wZXJ0aWVzIChsaWtlIGBtYWluYCkuICovXG4gIGZ1bmN0aW9uIGhhc0V4cGxpY2l0Rm9ybWF0UHJvcGVydGllcyhwYXJzZWRQYWNrYWdlOiB7W2tleTogc3RyaW5nXTogc3RyaW5nfSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhwYXJzZWRQYWNrYWdlKVxuICAgICAgICAuc29tZShwcm9wZXJ0eU5hbWUgPT4ga25vd25Gb3JtYXRQYWNrYWdlSnNvbkZpZWxkcy5pbmNsdWRlcyhwcm9wZXJ0eU5hbWUpKTtcbiAgfVxuXG4gIC8qKiBDcmVhdGVzIG1ldGFkYXRhIHJlLWV4cG9ydCBmaWxlIGZvciBhIHNlY29uZGFyeSBlbnRyeS1wb2ludC4gKi9cbiAgZnVuY3Rpb24gY3JlYXRlTWV0YWRhdGFSZWV4cG9ydEZpbGUoXG4gICAgICBlbnRyeVBvaW50TmFtZTogc3RyaW5nLCBtZXRhZGF0YUZpbGU6IHN0cmluZywgcGFja2FnZU5hbWU6IHN0cmluZykge1xuICAgIGNvbnN0IGlucHV0UGF0aCA9IHBhdGguam9pbihzcmNEaXIsIGAke2VudHJ5UG9pbnROYW1lfS5tZXRhZGF0YS5qc29uYCk7XG4gICAgd3JpdGVGaWxlRnJvbUlucHV0UGF0aChpbnB1dFBhdGgsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICdfX3N5bWJvbGljJzogJ21vZHVsZScsXG4gICAgICAndmVyc2lvbic6IDMsXG4gICAgICAnbWV0YWRhdGEnOiB7fSxcbiAgICAgICdleHBvcnRzJzpcbiAgICAgICAgICBbeydmcm9tJzogYCR7c3JjRGlyUmVsYXRpdmUoaW5wdXRQYXRoLCBtZXRhZGF0YUZpbGUucmVwbGFjZSgvLm1ldGFkYXRhLmpzb24kLywgJycpKX1gfV0sXG4gICAgICAnZmxhdE1vZHVsZUluZGV4UmVkaXJlY3QnOiB0cnVlLFxuICAgICAgJ2ltcG9ydEFzJzogcGFja2FnZU5hbWVcbiAgICB9KSArICdcXG4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdHlwaW5ncyAoZC50cykgcmUtZXhwb3J0IGZpbGUgZm9yIGEgc2Vjb25kYXJ5LWVudHJ5IHBvaW50LFxuICAgKiBlLmcuLCBgZXhwb3J0ICogZnJvbSAnLi9jb21tb24vY29tbW9uJ2BcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZVR5cGluZ3NSZWV4cG9ydEZpbGUoZW50cnlQb2ludE5hbWU6IHN0cmluZywgbGljZW5zZTogc3RyaW5nLCB0eXBpbmdzRmlsZTogc3RyaW5nKSB7XG4gICAgY29uc3QgaW5wdXRQYXRoID0gcGF0aC5qb2luKHNyY0RpciwgYCR7ZW50cnlQb2ludE5hbWV9LmQudHNgKTtcbiAgICBjb25zdCBjb250ZW50ID0gYCR7bGljZW5zZX1cbmV4cG9ydCAqIGZyb20gJyR7c3JjRGlyUmVsYXRpdmUoaW5wdXRQYXRoLCB0eXBpbmdzRmlsZS5yZXBsYWNlKC9cXC5kXFwudHN4PyQvLCAnJykpfSc7XG5gO1xuICAgIHdyaXRlRmlsZUZyb21JbnB1dFBhdGgoaW5wdXRQYXRoLCBjb250ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcGFja2FnZS5qc29uIGZvciBhIHNlY29uZGFyeSBlbnRyeS1wb2ludC5cbiAgICogQHBhcmFtIGRpciBUaGUgZGlyZWN0b3J5IHVuZGVyIHdoaWNoIHRoZSBwYWNrYWdlLmpzb24gc2hvdWxkIGJlIHdyaXR0ZW4uXG4gICAqIEBwYXJhbSBlbnRyeVBvaW50UGFja2FnZU5hbWUgVGhlIGZ1bGwgcGFja2FnZSBuYW1lIGZvciB0aGUgZW50cnkgcG9pbnQsXG4gICAqICAgICBlLmcuICdAYW5ndWxhci9jb21tb24vaHR0cCcuXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVFbnRyeVBvaW50UGFja2FnZUpzb24oZGlyOiBzdHJpbmcsIGVudHJ5UG9pbnRQYWNrYWdlTmFtZTogc3RyaW5nKSB7XG4gICAgY29uc3QgcGtnSnNvbiA9IHBhdGguam9pbihzcmNEaXIsIGRpciwgJ3BhY2thZ2UuanNvbicpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBhbWVuZFBhY2thZ2VKc29uKHBrZ0pzb24sIHtuYW1lOiBlbnRyeVBvaW50UGFja2FnZU5hbWV9LCB0cnVlKTtcbiAgICB3cml0ZUZpbGVGcm9tSW5wdXRQYXRoKHBrZ0pzb24sIGNvbnRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZXMgdGhlIHNwZWNpZmllZCBwYXRoIGJ5IHJlcGxhY2luZyBiYWNrc2xhc2ggc2VwYXJhdG9ycyB3aXRoIFBvc2l4XG4gICAqIGZvcndhcmQgc2xhc2ggc2VwYXJhdG9ycy5cbiAgICovXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVNlcGFyYXRvcnMocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gcGF0aC5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG4gIH1cblxuICAvKipcbiAgICogUmV3aXJlcyBtZXRhZGF0YSB0byBwb2ludCB0byB0aGUgZmxhdHRlbmVkIGR0cyBmaWxlLlxuICAgKlxuICAgKiBAcGFyYW0gbWV0YWRhdGFQYXRoIHRoZSBtZXRhZGF0YSBmaWxlIHBhdGhcbiAgICogQHBhcmFtIHR5cGluZ3NQYXRoIHRoZSB0eXBpbmdzIGJ1bmRsZSBlbnRyeXBvaW50XG4gICAqL1xuICBmdW5jdGlvbiByZXdpcmVNZXRhZGF0YShtZXRhZGF0YVBhdGg6IHN0cmluZywgdHlwaW5nc1BhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyhtZXRhZGF0YVBhdGgsICd1dGYtOCcpKSBhcyB7W2tleTogc3RyaW5nXTogYW55fTtcblxuICAgIGxldCB0eXBpbmdzUmVsYXRpdmVQYXRoID1cbiAgICAgICAgbm9ybWFsaXplU2VwYXJhdG9ycyhwYXRoLnJlbGF0aXZlKHBhdGguZGlybmFtZShtZXRhZGF0YVBhdGgpLCB0eXBpbmdzUGF0aCkpO1xuICAgIGlmICghdHlwaW5nc1JlbGF0aXZlUGF0aC5zdGFydHNXaXRoKCcuLicpKSB7XG4gICAgICB0eXBpbmdzUmVsYXRpdmVQYXRoID0gYC4vJHt0eXBpbmdzUmVsYXRpdmVQYXRofWA7XG4gICAgfVxuXG4gICAgdHlwaW5nc1JlbGF0aXZlUGF0aCA9IHR5cGluZ3NSZWxhdGl2ZVBhdGgucmVwbGFjZSgnLmQudHMnLCAnJyk7XG5cbiAgICAvLyB0aGUgcmVnZXhwIGhlcmUgY2F0Y2hlcyBhbGwgcmVsYXRpdmUgcGF0aHMgc3VjaCBhczpcbiAgICAvLyAuL3NyYy9jb3JlL2Zvby5kLnRzIGFuZCAuLi9zcmMvY29yZS9mb28uZC50c1xuICAgIGNvbnN0IHJlbGF0aXZlUGF0aFJlZ2V4ID0gL1xcLj9cXC5cXC9bXFx3XFwuXFwtX1xcL10rL2c7XG4gICAgaWYgKG1ldGFkYXRhLmV4cG9ydHMpIHtcbiAgICAgIC8vIFN0cmlwIHJlLWV4cG9ydHMgd2hpY2ggYXJlIG5vdyBzZWxmLXJlZmVyZW5jZXNcbiAgICAgIG1ldGFkYXRhLmV4cG9ydHMgPVxuICAgICAgICAgIG1ldGFkYXRhLmV4cG9ydHMuZmlsdGVyKChlOiB7ZnJvbTogc3RyaW5nfSkgPT4gIWUuZnJvbS5tYXRjaChyZWxhdGl2ZVBhdGhSZWdleCkpO1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpLnJlcGxhY2UocmVsYXRpdmVQYXRoUmVnZXgsIHR5cGluZ3NSZWxhdGl2ZVBhdGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0cmlwIHRoZSBuYW1lZCBBTUQgbW9kdWxlIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWJhemVsIHVzZXJzIGZyb20gdHlwaW5ncyBjb250ZW50XG4gICAqIEBwYXJhbSBmaWxlUGF0aCBkdHMgZmlsZSBwYXRoXG4gICAqL1xuICBmdW5jdGlvbiByZWFkVHlwaW5nc0FuZFN0cmlwQW1kTW9kdWxlKGZpbGVQYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBmc1xuICAgICAgICAucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCAndXRmLTgnKVxuICAgICAgICAvLyBTdHJpcCB0aGUgbmFtZWQgQU1EIG1vZHVsZSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1iYXplbCB1c2Vyc1xuICAgICAgICAucmVwbGFjZSgvXlxcL1xcL1xcLyA8YW1kLW1vZHVsZSBuYW1lPS4qXFwvPltcXHJcXG5dKy9nbSwgJycpO1xuICB9XG59XG5cbmlmIChyZXF1aXJlLm1haW4gPT09IG1vZHVsZSkge1xuICBwcm9jZXNzLmV4aXRDb2RlID0gbWFpbihwcm9jZXNzLmFyZ3Yuc2xpY2UoMikpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbmV3QXJyYXk8VCA9IGFueT4oc2l6ZTogbnVtYmVyKTogVFtdO1xuZXhwb3J0IGZ1bmN0aW9uIG5ld0FycmF5PFQ+KHNpemU6IG51bWJlciwgdmFsdWU6IFQpOiBUW107XG5leHBvcnQgZnVuY3Rpb24gbmV3QXJyYXk8VD4oc2l6ZTogbnVtYmVyLCB2YWx1ZT86IFQpOiBUW10ge1xuICBjb25zdCBsaXN0OiBUW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICBsaXN0LnB1c2godmFsdWUhKTtcbiAgfVxuICByZXR1cm4gbGlzdDtcbn1cbiJdfQ==