/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
import * as fs from 'fs';
import * as path from 'path';
import fastGlob from 'fast-glob';
import { analyzeFileAndEnsureNoCrossImports } from './cross_entry_points_imports';
/**
 * List of known `package.json` fields which provide information about
 * supported package formats and their associated entry paths.
 */
const knownFormatPackageJsonFormatFields = ['main', 'typings', 'module'];
// Main entry-point.
main(process.argv.slice(2));
function main(args) {
    // This utility expects all of its arguments to be specified in a params file generated by
    // bazel (see https://docs.bazel.build/versions/master/skylark/lib/Args.html#use_param_file).
    const paramFilePath = args[0];
    // Bazel params may be surrounded with quotes
    function unquoteParameter(s) {
        return s.replace(/^'(.*)'$/, '$1');
    }
    // Parameters are specified in the file one per line.
    const params = fs.readFileSync(paramFilePath, 'utf-8').split('\n').map(unquoteParameter);
    const [
    // Output directory for the npm package.
    outputDirExecPath, 
    // The package segment of the ng_package rule's label (e.g. 'package/common').
    owningPackageName, 
    // JSON data capturing metadata of the package being built. See `PackageMetadata`.
    metadataArg, 
    // Path to the package's README.md.
    readmeMd, 
    // Path to the package's LICENSE file.
    licenseFile, 
    // List of individual ES2022 modules
    esm2022Arg, 
    // List of static files that should be copied into the package.
    staticFilesArg, 
    // List of side-effectful entry-points
    sideEffectEntryPointsArg,] = params;
    const esm2022 = JSON.parse(esm2022Arg);
    const staticFiles = JSON.parse(staticFilesArg);
    const metadata = JSON.parse(metadataArg);
    const sideEffectEntryPoints = JSON.parse(sideEffectEntryPointsArg);
    if (readmeMd) {
        copyFile(readmeMd, 'README.md');
    }
    if (licenseFile) {
        copyFile(licenseFile, 'LICENSE');
    }
    /**
     * Writes a file with the specified content into the package output.
     * @param outputRelativePath Relative path in the output directory where the
     *   file is written to.
     * @param fileContent Content of the file.
     */
    function writeFile(outputRelativePath, fileContent) {
        const outputPath = path.join(outputDirExecPath, outputRelativePath);
        // Always ensure that the target directory exists.
        fs.mkdirSync(path.dirname(outputPath), { recursive: true });
        fs.writeFileSync(outputPath, fileContent);
    }
    /**
     * Copies a file into the package output to the specified location.
     * @param inputPath File that should be copied.
     * @param outputRelativePath Relative path in the output directory where the
     *   file is written to.
     */
    function copyFile(inputPath, outputRelativePath) {
        const fileContent = fs.readFileSync(inputPath, 'utf8');
        writeFile(outputRelativePath, fileContent);
    }
    /**
     * Gets the relative path for the given file within the owning package. This
     * assumes the file is contained in the owning package.
     *
     * e.g. consider the owning package is `packages/core` and the input file
     * is `packages/core/testing/index.d.ts`. This function would return the
     * relative path as followed: `testing/index.d.ts`.
     */
    function getOwningPackageRelativePath(file) {
        return path.relative(owningPackageName, file.shortPath);
    }
    /**
     * Gets the entry-point sub-path from the package root. e.g. if the package name
     * is `@angular/cdk`, then for `@angular/cdk/a11y` just `a11y` would be returned.
     */
    function getEntryPointSubpath(moduleName) {
        return moduleName.slice(`${metadata.npmPackageName}/`.length);
    }
    /**
     * Gets whether the given module name resolves to a secondary entry-point.
     * e.g. if the package name is `@angular/cdk`, then for `@angular/cdk/a11y`
     * this would return `true`.
     */
    function isSecondaryEntryPoint(moduleName) {
        return getEntryPointSubpath(moduleName) !== '';
    }
    const crossEntryPointFailures = esm2022.flatMap((file) => analyzeFileAndEnsureNoCrossImports(file, metadata));
    if (crossEntryPointFailures.length) {
        console.error(crossEntryPointFailures);
        process.exit(1);
    }
    // Copy all FESM files (and their potential shared chunks) into the package output.
    const fesmFiles = fastGlob.sync('**/*', { cwd: metadata.fesmBundlesOut.path });
    fesmFiles.forEach((f) => copyFile(path.join(metadata.fesmBundlesOut.path, f), path.join('fesm2022', f)));
    // Copy all dts files (and their potential shared chunks) into the package output.
    const dtsFiles = fastGlob.sync('**/*', { cwd: metadata.dtsBundlesOut.path });
    dtsFiles.forEach((f) => 
    // TODO(devversion): Put all types under `/types/` folder. Breaking change in v20.
    copyFile(path.join(metadata.dtsBundlesOut.path, f), f));
    for (const file of staticFiles) {
        // We copy all files into the package output while preserving the sub-path from
        // the owning package. e.g. `packages/core/package.json` ends up `<pkg-out>/package.json`.
        const outputRelativePath = getOwningPackageRelativePath(file);
        let content = fs.readFileSync(file.path, 'utf8');
        // Check and modify package.json files as necessary for publishing
        if (path.basename(file.path) === 'package.json') {
            const isPrimaryPackageJson = outputRelativePath === 'package.json';
            const packageJson = JSON.parse(content);
            const packageName = packageJson['name'];
            // Prevent non-primary `package.json` files which would throw-off resolution.
            // Resolution in the package should only be based on the top-level `package.json`.
            if (!isPrimaryPackageJson) {
                throw Error(`Found a nested "package.json" file in the package output: ${file.shortPath}.\n` +
                    `All information of the package should reside in the primary package file.`);
            }
            // Check if the `name` field of the `package.json` files are matching with
            // name of the NPM package. This is an additional safety check.
            if (packageName !== metadata.npmPackageName) {
                throw Error(`Primary "package.json" has mismatching package name. Expected the ` +
                    `package to be named "${metadata.npmPackageName}", but is set to: ${packageName}.`);
            }
            let newPackageJson = insertFormatFieldsIntoPackageJson(outputRelativePath, packageJson, false);
            newPackageJson = updatePrimaryPackageJson(newPackageJson);
            // Update the content with the new `package.json` file content.
            content = JSON.stringify(newPackageJson, null, 2);
        }
        writeFile(outputRelativePath, content);
    }
    /**
     * Inserts or edits properties into the package.json file(s) in the package so that
     * they point to all the right generated artifacts.
     *
     * @param packageJsonOutRelativePath Path where the `package.json` is stored in
     *   the package output.
     * @param parsedPackage Parsed package.json content
     * @param isGeneratedPackageJson Whether the passed package.json has been generated.
     */
    function insertFormatFieldsIntoPackageJson(packageJsonOutRelativePath, parsedPackage, isGeneratedPackageJson) {
        const packageJson = { ...parsedPackage };
        const packageName = packageJson['name'];
        const entryPointInfo = metadata.entryPoints[packageName];
        const packageJsonContainingDir = path.dirname(packageJsonOutRelativePath);
        // If a package json file has been discovered that does not match any
        // entry-point in the metadata, we report a warning as most likely the target
        // is configured incorrectly (e.g. missing `module_name` attribute).
        if (!entryPointInfo) {
            // Ideally we should throw here, as we got an entry point that doesn't
            // have flat module metadata / bundle index, so it may have been an
            // ng_module that's missing a module_name attribute.
            // However, @angular/compiler can't be an ng_module, as it's the internals
            // of the ngc compiler, yet we want to build an ng_package for it.
            // So ignore package.json files when we are missing data.
            console.error('WARNING: no module metadata for package', packageName);
            console.error('   Not updating the package.json file to point to it');
            console.error('   The ng_module for this package is possibly missing the module_name attribute ');
            return packageJson;
        }
        // If we guessed the index paths for a module, and it contains an explicit `package.json`
        // file that already sets format properties, we skip automatic insertion of format
        // properties but report a warning in case properties have been set by accident.
        if (entryPointInfo.guessedPaths &&
            !isGeneratedPackageJson &&
            hasExplicitFormatProperties(packageJson)) {
            console.error('WARNING: `package.json` explicitly sets format properties (like `main`).');
            console.error('    Skipping automatic insertion of format properties as explicit ' +
                'format properties are set.');
            console.error('    Ignore this warning if explicit properties are set intentionally.');
            return packageJson;
        }
        const fesm2022RelativeOutPath = entryPointInfo.fesm2022RelativePath;
        const typingsRelativeOutPath = entryPointInfo.dtsBundleRelativePath;
        packageJson.module = normalizePath(path.relative(packageJsonContainingDir, fesm2022RelativeOutPath));
        packageJson.typings = normalizePath(path.relative(packageJsonContainingDir, typingsRelativeOutPath));
        return packageJson;
    }
    /**
     * Updates the primary `package.json` file of the NPM package to specify
     * the module conditional exports and the ESM module type.
     */
    function updatePrimaryPackageJson(packageJson) {
        if (packageJson.type !== undefined && packageJson.type !== 'module') {
            throw Error('The primary "package.json" file of the package sets the "type" field ' +
                'that is controlled by the packager. Please unset it or set `type` to `module`.');
        }
        const newPackageJson = { ...packageJson };
        newPackageJson.type = 'module';
        // The `package.json` file is made publicly accessible for tools that
        // might want to query information from the Angular NPM package.
        insertExportMappingOrError(newPackageJson, './package.json', { default: './package.json' });
        // Capture all entry-points in the `exports` field using the subpath export declarations:
        // https://nodejs.org/api/packages.html#packages_subpath_exports.
        for (const [moduleName, entryPoint] of Object.entries(metadata.entryPoints)) {
            const subpath = isSecondaryEntryPoint(moduleName)
                ? `./${getEntryPointSubpath(moduleName)}`
                : '.';
            const fesm2022OutRelativePath = entryPoint.fesm2022RelativePath;
            const typesOutRelativePath = entryPoint.dtsBundleRelativePath;
            // Insert the export mapping for the entry-point. We set `default` to the FESM 2022
            // output, and also set the `types` condition which will be respected by TS 4.5.
            // https://github.com/microsoft/TypeScript/pull/45884.
            insertExportMappingOrError(newPackageJson, subpath, {
                types: normalizePath(typesOutRelativePath),
                // Note: The default conditions needs to be the last one.
                default: normalizePath(fesm2022OutRelativePath),
            });
        }
        checkPackageJsonSideEffects(packageJson);
        return newPackageJson;
    }
    function checkPackageJsonSideEffects(packageJson) {
        // Convenience if there are no side effects, and it's explicitly marked.
        // This is okay and we don't ask the developer to drop the explicit field.
        if (packageJson.sideEffects === false && sideEffectEntryPoints.length === 0) {
            return;
        }
        if (packageJson.sideEffects === true) {
            throw Error('Unexpected `sideEffects` field in `package.json`. ' +
                'Side effects should be fine-grained and marked via the Bazel `side_effect_entry_points` option.');
        }
        const sideEffects = packageJson.sideEffects;
        const neededSideEffects = sideEffectEntryPoints.map((entryPointModule) => `./${metadata.entryPoints[entryPointModule].fesm2022RelativePath}`);
        const missingSideEffects = neededSideEffects.filter((p) => 
        // It's missing, if the whole package is marked as having no side effects.
        sideEffects === false ||
            // Alternatively, it's missing if the explicit list doesn't contain the pattern.
            !(sideEffects ?? []).includes(p));
        if (missingSideEffects.length > 0) {
            throw Error('Missing side effects in `package.json` `sideEffects` field. ' +
                'Please add the following side effect file patterns:\n' +
                missingSideEffects.join('\n - '));
        }
        // Find potential side-effects that refer to our FESM bundles, but aren't part
        // of the `ng_package` known entry points.
        const unexpectedExtra = sideEffects !== false
            ? (sideEffects ?? []).filter((p) => p.includes('fesm2022') && !neededSideEffects.includes(p))
            : [];
        if (unexpectedExtra.length > 0) {
            throw Error('Unexpected side effects in `package.json` `sideEffects` field that is not known to `ng_package`. ' +
                'Please add the side effect entry point to the Bazel `side_effect_entry_points` option. ' +
                'Unexpected patterns:\n' +
                unexpectedExtra.join('\n - '));
        }
    }
    /**
     * Inserts a subpath export mapping into the specified `package.json` object.
     * @throws An error if the mapping is already defined and would conflict.
     */
    function insertExportMappingOrError(packageJson, subpath, mapping) {
        if (packageJson.exports === undefined) {
            packageJson.exports = {};
        }
        if (packageJson.exports[subpath] === undefined) {
            packageJson.exports[subpath] = {};
        }
        const subpathExport = packageJson.exports[subpath];
        // Go through all conditions that should be inserted. If the condition is already
        // manually set of the subpath export, we throw an error. In general, we allow for
        // additional conditions to be set. These will always precede the generated ones.
        for (const conditionName of Object.keys(mapping)) {
            if (subpathExport[conditionName] !== undefined) {
                throw Error(`Found a conflicting export condition for "${subpath}". The "${conditionName}" ` +
                    `condition would be overridden by the packager. Please unset it.`);
            }
            // **Note**: The order of the conditions is preserved even though we are setting
            // the conditions once at a time (the latest assignment will be at the end).
            subpathExport[conditionName] = mapping[conditionName];
        }
    }
    /** Whether the package explicitly sets any of the format properties (like `main`). */
    function hasExplicitFormatProperties(parsedPackage) {
        return Object.keys(parsedPackage).some((fieldName) => knownFormatPackageJsonFormatFields.includes(fieldName));
    }
    /**
     * Normalizes the specified path by replacing backslash separators with Posix
     * forward slash separators.
     */
    function normalizePath(path) {
        const result = path.replace(/\\/g, '/');
        return result.startsWith('.') ? result : `./${result}`;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFja2FnZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9iYXplbC9zcmMvbmdfcGFja2FnZS9wYWNrYWdlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFFSCxPQUFPLEtBQUssRUFBRSxNQUFNLElBQUksQ0FBQztBQUN6QixPQUFPLEtBQUssSUFBSSxNQUFNLE1BQU0sQ0FBQztBQUM3QixPQUFPLFFBQVEsTUFBTSxXQUFXLENBQUM7QUFHakMsT0FBTyxFQUFDLGtDQUFrQyxFQUFDLE1BQU0sOEJBQThCLENBQUM7QUFFaEY7OztHQUdHO0FBQ0gsTUFBTSxrQ0FBa0MsR0FBRyxDQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUUsUUFBUSxDQUFVLENBQUM7QUF3QmxGLG9CQUFvQjtBQUNwQixJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUU1QixTQUFTLElBQUksQ0FBQyxJQUFjO0lBQzFCLDBGQUEwRjtJQUMxRiw2RkFBNkY7SUFDN0YsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRTlCLDZDQUE2QztJQUM3QyxTQUFTLGdCQUFnQixDQUFDLENBQVM7UUFDakMsT0FBTyxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQscURBQXFEO0lBQ3JELE1BQU0sTUFBTSxHQUFHLEVBQUUsQ0FBQyxZQUFZLENBQUMsYUFBYSxFQUFFLE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztJQUV6RixNQUFNO0lBQ0osd0NBQXdDO0lBQ3hDLGlCQUFpQjtJQUVqQiw4RUFBOEU7SUFDOUUsaUJBQWlCO0lBRWpCLGtGQUFrRjtJQUNsRixXQUFXO0lBRVgsbUNBQW1D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UUFDdkUsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQWlCLEVBQUUsRUFBRSxDQUMzRCxrQ0FBa0MsQ0FBQyxRQUFRLENBQUMsU0FBeUMsQ0FBQyxDQUN2RixDQUFDO0lBQ0osQ0FBQztJQUVEOzs7T0FHRztJQUNILFNBQVMsYUFBYSxDQUFDLElBQVk7UUFDakMsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDeEMsT0FBTyxNQUFNLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssTUFBTSxFQUFFLENBQUM7SUFDekQsQ0FBQztBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5kZXYvbGljZW5zZVxuICovXG5cbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgZmFzdEdsb2IgZnJvbSAnZmFzdC1nbG9iJztcblxuaW1wb3J0IHtCYXplbEZpbGVJbmZvLCBQYWNrYWdlTWV0YWRhdGF9IGZyb20gJy4vYXBpJztcbmltcG9ydCB7YW5hbHl6ZUZpbGVBbmRFbnN1cmVOb0Nyb3NzSW1wb3J0c30gZnJvbSAnLi9jcm9zc19lbnRyeV9wb2ludHNfaW1wb3J0cyc7XG5cbi8qKlxuICogTGlzdCBvZiBrbm93biBgcGFja2FnZS5qc29uYCBmaWVsZHMgd2hpY2ggcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dFxuICogc3VwcG9ydGVkIHBhY2thZ2UgZm9ybWF0cyBhbmQgdGhlaXIgYXNzb2NpYXRlZCBlbnRyeSBwYXRocy5cbiAqL1xuY29uc3Qga25vd25Gb3JtYXRQYWNrYWdlSnNvbkZvcm1hdEZpZWxkcyA9IFsnbWFpbicsICd0eXBpbmdzJywgJ21vZHVsZSddIGFzIGNvbnN0O1xuXG4vKiogVW5pb24gdHlwZSBtYXRjaGluZyBrbm93biBgcGFja2FnZS5qc29uYCBmb3JtYXQgZmllbGRzLiAqL1xudHlwZSBLbm93blBhY2thZ2VKc29uRm9ybWF0RmllbGRzID0gKHR5cGVvZiBrbm93bkZvcm1hdFBhY2thZ2VKc29uRm9ybWF0RmllbGRzKVtudW1iZXJdO1xuXG4vKipcbiAqIFR5cGUgZGVzY3JpYmluZyB0aGUgY29uZGl0aW9uYWwgZXhwb3J0cyBkZXNjcmlwdG9yIGZvciBhbiBlbnRyeS1wb2ludC5cbiAqIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvcGFja2FnZXMuaHRtbCNwYWNrYWdlc19jb25kaXRpb25hbF9leHBvcnRzXG4gKi9cbnR5cGUgQ29uZGl0aW9uYWxFeHBvcnQgPSB7XG4gIHR5cGVzPzogc3RyaW5nO1xuICBkZWZhdWx0Pzogc3RyaW5nO1xufTtcblxuLyoqIFR5cGUgZGVzY3JpYmluZyBhIGBwYWNrYWdlLmpzb25gIHRoZSBwYWNrYWdlciBkZWFscyB3aXRoLiAqL1xudHlwZSBQYWNrYWdlSnNvbiA9IHtcbiAgW2tleSBpbiBLbm93blBhY2thZ2VKc29uRm9ybWF0RmllbGRzXT86IHN0cmluZztcbn0gJiB7XG4gIG5hbWU6IHN0cmluZztcbiAgdHlwZT86IHN0cmluZztcbiAgc2lkZUVmZmVjdHM/OiBzdHJpbmdbXSB8IGJvb2xlYW47XG4gIGV4cG9ydHM/OiBSZWNvcmQ8c3RyaW5nLCBDb25kaXRpb25hbEV4cG9ydD47XG59O1xuXG4vLyBNYWluIGVudHJ5LXBvaW50LlxubWFpbihwcm9jZXNzLmFyZ3Yuc2xpY2UoMikpO1xuXG5mdW5jdGlvbiBtYWluKGFyZ3M6IHN0cmluZ1tdKTogdm9pZCB7XG4gIC8vIFRoaXMgdXRpbGl0eSBleHBlY3RzIGFsbCBvZiBpdHMgYXJndW1lbnRzIHRvIGJlIHNwZWNpZmllZCBpbiBhIHBhcmFtcyBmaWxlIGdlbmVyYXRlZCBieVxuICAvLyBiYXplbCAoc2VlIGh0dHBzOi8vZG9jcy5iYXplbC5idWlsZC92ZXJzaW9ucy9tYXN0ZXIvc2t5bGFyay9saWIvQXJncy5odG1sI3VzZV9wYXJhbV9maWxlKS5cbiAgY29uc3QgcGFyYW1GaWxlUGF0aCA9IGFyZ3NbMF07XG5cbiAgLy8gQmF6ZWwgcGFyYW1zIG1heSBiZSBzdXJyb3VuZGVkIHdpdGggcXVvdGVzXG4gIGZ1bmN0aW9uIHVucXVvdGVQYXJhbWV0ZXIoczogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZSgvXicoLiopJyQvLCAnJDEnKTtcbiAgfVxuXG4gIC8vIFBhcmFtZXRlcnMgYXJlIHNwZWNpZmllZCBpbiB0aGUgZmlsZSBvbmUgcGVyIGxpbmUuXG4gIGNvbnN0IHBhcmFtcyA9IGZzLnJlYWRGaWxlU3luYyhwYXJhbUZpbGVQYXRoLCAndXRmLTgnKS5zcGxpdCgnXFxuJykubWFwKHVucXVvdGVQYXJhbWV0ZXIpO1xuXG4gIGNvbnN0IFtcbiAgICAvLyBPdXRwdXQgZGlyZWN0b3J5IGZvciB0aGUgbnBtIHBhY2thZ2UuXG4gICAgb3V0cHV0RGlyRXhlY1BhdGgsXG5cbiAgICAvLyBUaGUgcGFja2FnZSBzZWdtZW50IG9mIHRoZSBuZ19wYWNrYWdlIHJ1bGUncyBsYWJlbCAoZS5nLiAncGFja2FnZS9jb21tb24nKS5cbiAgICBvd25pbmdQYWNrYWdlTmFtZSxcblxuICAgIC8vIEpTT04gZGF0YSBjYXB0dXJpbmcgbWV0YWRhdGEgb2YgdGhlIHBhY2thZ2UgYmVpbmcgYnVpbHQuIFNlZSBgUGFja2FnZU1ldGFkYXRhYC5cbiAgICBtZXRhZGF0YUFyZyxcblxuICAgIC8vIFBhdGggdG8gdGhlIHBhY2thZ2UncyBSRUFETUUubWQuXG4gICAgcmVhZG1lTWQsXG5cbiAgICAvLyBQYXRoIHRvIHRoZSBwYWNrYWdlJ3MgTElDRU5TRSBmaWxlLlxuICAgIGxpY2Vuc2VGaWxlLFxuXG4gICAgLy8gTGlzdCBvZiBpbmRpdmlkdWFsIEVTMjAyMiBtb2R1bGVzXG4gICAgZXNtMjAyMkFyZyxcblxuICAgIC8vIExpc3Qgb2Ygc3RhdGljIGZpbGVzIHRoYXQgc2hvdWxkIGJlIGNvcGllZCBpbnRvIHRoZSBwYWNrYWdlLlxuICAgIHN0YXRpY0ZpbGVzQXJnLFxuXG4gICAgLy8gTGlzdCBvZiBzaWRlLWVmZmVjdGZ1bCBlbnRyeS1wb2ludHNcbiAgICBzaWRlRWZmZWN0RW50cnlQb2ludHNBcmcsXG4gIF0gPSBwYXJhbXM7XG5cbiAgY29uc3QgZXNtMjAyMiA9IEpTT04ucGFyc2UoZXNtMjAyMkFyZykgYXMgQmF6ZWxGaWxlSW5mb1tdO1xuICBjb25zdCBzdGF0aWNGaWxlcyA9IEpTT04ucGFyc2Uoc3RhdGljRmlsZXNBcmcpIGFzIEJhemVsRmlsZUluZm9bXTtcbiAgY29uc3QgbWV0YWRhdGEgPSBKU09OLnBhcnNlKG1ldGFkYXRhQXJnKSBhcyBQYWNrYWdlTWV0YWRhdGE7XG4gIGNvbnN0IHNpZGVFZmZlY3RFbnRyeVBvaW50cyA9IEpTT04ucGFyc2Uoc2lkZUVmZmVjdEVudHJ5UG9pbnRzQXJnKSBhcyBzdHJpbmdbXTtcblxuICBpZiAocmVhZG1lTWQpIHtcbiAgICBjb3B5RmlsZShyZWFkbWVNZCwgJ1JFQURNRS5tZCcpO1xuICB9XG5cbiAgaWYgKGxpY2Vuc2VGaWxlKSB7XG4gICAgY29weUZpbGUobGljZW5zZUZpbGUsICdMSUNFTlNFJyk7XG4gIH1cblxuICAvKipcbiAgICogV3JpdGVzIGEgZmlsZSB3aXRoIHRoZSBzcGVjaWZpZWQgY29udGVudCBpbnRvIHRoZSBwYWNrYWdlIG91dHB1dC5cbiAgICogQHBhcmFtIG91dHB1dFJlbGF0aXZlUGF0aCBSZWxhdGl2ZSBwYXRoIGluIHRoZSBvdXRwdXQgZGlyZWN0b3J5IHdoZXJlIHRoZVxuICAgKiAgIGZpbGUgaXMgd3JpdHRlbiB0by5cbiAgICogQHBhcmFtIGZpbGVDb250ZW50IENvbnRlbnQgb2YgdGhlIGZpbGUuXG4gICAqL1xuICBmdW5jdGlvbiB3cml0ZUZpbGUob3V0cHV0UmVsYXRpdmVQYXRoOiBzdHJpbmcsIGZpbGVDb250ZW50OiBzdHJpbmcgfCBCdWZmZXIpIHtcbiAgICBjb25zdCBvdXRwdXRQYXRoID0gcGF0aC5qb2luKG91dHB1dERpckV4ZWNQYXRoLCBvdXRwdXRSZWxhdGl2ZVBhdGgpO1xuXG4gICAgLy8gQWx3YXlzIGVuc3VyZSB0aGF0IHRoZSB0YXJnZXQgZGlyZWN0b3J5IGV4aXN0cy5cbiAgICBmcy5ta2RpclN5bmMocGF0aC5kaXJuYW1lKG91dHB1dFBhdGgpLCB7cmVjdXJzaXZlOiB0cnVlfSk7XG4gICAgZnMud3JpdGVGaWxlU3luYyhvdXRwdXRQYXRoLCBmaWxlQ29udGVudCk7XG4gIH1cblxuICAvKipcbiAgICogQ29waWVzIGEgZmlsZSBpbnRvIHRoZSBwYWNrYWdlIG91dHB1dCB0byB0aGUgc3BlY2lmaWVkIGxvY2F0aW9uLlxuICAgKiBAcGFyYW0gaW5wdXRQYXRoIEZpbGUgdGhhdCBzaG91bGQgYmUgY29waWVkLlxuICAgKiBAcGFyYW0gb3V0cHV0UmVsYXRpdmVQYXRoIFJlbGF0aXZlIHBhdGggaW4gdGhlIG91dHB1dCBkaXJlY3Rvcnkgd2hlcmUgdGhlXG4gICAqICAgZmlsZSBpcyB3cml0dGVuIHRvLlxuICAgKi9cbiAgZnVuY3Rpb24gY29weUZpbGUoaW5wdXRQYXRoOiBzdHJpbmcsIG91dHB1dFJlbGF0aXZlUGF0aDogc3RyaW5nKSB7XG4gICAgY29uc3QgZmlsZUNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoaW5wdXRQYXRoLCAndXRmOCcpO1xuICAgIHdyaXRlRmlsZShvdXRwdXRSZWxhdGl2ZVBhdGgsIGZpbGVDb250ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSByZWxhdGl2ZSBwYXRoIGZvciB0aGUgZ2l2ZW4gZmlsZSB3aXRoaW4gdGhlIG93bmluZyBwYWNrYWdlLiBUaGlzXG4gICAqIGFzc3VtZXMgdGhlIGZpbGUgaXMgY29udGFpbmVkIGluIHRoZSBvd25pbmcgcGFja2FnZS5cbiAgICpcbiAgICogZS5nLiBjb25zaWRlciB0aGUgb3duaW5nIHBhY2thZ2UgaXMgYHBhY2thZ2VzL2NvcmVgIGFuZCB0aGUgaW5wdXQgZmlsZVxuICAgKiBpcyBgcGFja2FnZXMvY29yZS90ZXN0aW5nL2luZGV4LmQudHNgLiBUaGlzIGZ1bmN0aW9uIHdvdWxkIHJldHVybiB0aGVcbiAgICogcmVsYXRpdmUgcGF0aCBhcyBmb2xsb3dlZDogYHRlc3RpbmcvaW5kZXguZC50c2AuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRPd25pbmdQYWNrYWdlUmVsYXRpdmVQYXRoKGZpbGU6IEJhemVsRmlsZUluZm8pOiBzdHJpbmcge1xuICAgIHJldHVybiBwYXRoLnJlbGF0aXZlKG93bmluZ1BhY2thZ2VOYW1lLCBmaWxlLnNob3J0UGF0aCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgZW50cnktcG9pbnQgc3ViLXBhdGggZnJvbSB0aGUgcGFja2FnZSByb290LiBlLmcuIGlmIHRoZSBwYWNrYWdlIG5hbWVcbiAgICogaXMgYEBhbmd1bGFyL2Nka2AsIHRoZW4gZm9yIGBAYW5ndWxhci9jZGsvYTExeWAganVzdCBgYTExeWAgd291bGQgYmUgcmV0dXJuZWQuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRFbnRyeVBvaW50U3VicGF0aChtb2R1bGVOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBtb2R1bGVOYW1lLnNsaWNlKGAke21ldGFkYXRhLm5wbVBhY2thZ2VOYW1lfS9gLmxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB3aGV0aGVyIHRoZSBnaXZlbiBtb2R1bGUgbmFtZSByZXNvbHZlcyB0byBhIHNlY29uZGFyeSBlbnRyeS1wb2ludC5cbiAgICogZS5nLiBpZiB0aGUgcGFja2FnZSBuYW1lIGlzIGBAYW5ndWxhci9jZGtgLCB0aGVuIGZvciBgQGFuZ3VsYXIvY2RrL2ExMXlgXG4gICAqIHRoaXMgd291bGQgcmV0dXJuIGB0cnVlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGlzU2Vjb25kYXJ5RW50cnlQb2ludChtb2R1bGVOYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZ2V0RW50cnlQb2ludFN1YnBhdGgobW9kdWxlTmFtZSkgIT09ICcnO1xuICB9XG5cbiAgY29uc3QgY3Jvc3NFbnRyeVBvaW50RmFpbHVyZXMgPSBlc20yMDIyLmZsYXRNYXAoKGZpbGUpID0+XG4gICAgYW5hbHl6ZUZpbGVBbmRFbnN1cmVOb0Nyb3NzSW1wb3J0cyhmaWxlLCBtZXRhZGF0YSksXG4gICk7XG5cbiAgaWYgKGNyb3NzRW50cnlQb2ludEZhaWx1cmVzLmxlbmd0aCkge1xuICAgIGNvbnNvbGUuZXJyb3IoY3Jvc3NFbnRyeVBvaW50RmFpbHVyZXMpO1xuICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgfVxuXG4gIC8vIENvcHkgYWxsIEZFU00gZmlsZXMgKGFuZCB0aGVpciBwb3RlbnRpYWwgc2hhcmVkIGNodW5rcykgaW50byB0aGUgcGFja2FnZSBvdXRwdXQuXG4gIGNvbnN0IGZlc21GaWxlcyA9IGZhc3RHbG9iLnN5bmMoJyoqLyonLCB7Y3dkOiBtZXRhZGF0YS5mZXNtQnVuZGxlc091dC5wYXRofSk7XG4gIGZlc21GaWxlcy5mb3JFYWNoKChmKSA9PlxuICAgIGNvcHlGaWxlKHBhdGguam9pbihtZXRhZGF0YS5mZXNtQnVuZGxlc091dC5wYXRoLCBmKSwgcGF0aC5qb2luKCdmZXNtMjAyMicsIGYpKSxcbiAgKTtcblxuICAvLyBDb3B5IGFsbCBkdHMgZmlsZXMgKGFuZCB0aGVpciBwb3RlbnRpYWwgc2hhcmVkIGNodW5rcykgaW50byB0aGUgcGFja2FnZSBvdXRwdXQuXG4gIGNvbnN0IGR0c0ZpbGVzID0gZmFzdEdsb2Iuc3luYygnKiovKicsIHtjd2Q6IG1ldGFkYXRhLmR0c0J1bmRsZXNPdXQucGF0aH0pO1xuICBkdHNGaWxlcy5mb3JFYWNoKChmKSA9PlxuICAgIC8vIFRPRE8oZGV2dmVyc2lvbik6IFB1dCBhbGwgdHlwZXMgdW5kZXIgYC90eXBlcy9gIGZvbGRlci4gQnJlYWtpbmcgY2hhbmdlIGluIHYyMC5cbiAgICBjb3B5RmlsZShwYXRoLmpvaW4obWV0YWRhdGEuZHRzQnVuZGxlc091dC5wYXRoLCBmKSwgZiksXG4gICk7XG5cbiAgZm9yIChjb25zdCBmaWxlIG9mIHN0YXRpY0ZpbGVzKSB7XG4gICAgLy8gV2UgY29weSBhbGwgZmlsZXMgaW50byB0aGUgcGFja2FnZSBvdXRwdXQgd2hpbGUgcHJlc2VydmluZyB0aGUgc3ViLXBhdGggZnJvbVxuICAgIC8vIHRoZSBvd25pbmcgcGFja2FnZS4gZS5nLiBgcGFja2FnZXMvY29yZS9wYWNrYWdlLmpzb25gIGVuZHMgdXAgYDxwa2ctb3V0Pi9wYWNrYWdlLmpzb25gLlxuICAgIGNvbnN0IG91dHB1dFJlbGF0aXZlUGF0aCA9IGdldE93bmluZ1BhY2thZ2VSZWxhdGl2ZVBhdGgoZmlsZSk7XG4gICAgbGV0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZS5wYXRoLCAndXRmOCcpO1xuXG4gICAgLy8gQ2hlY2sgYW5kIG1vZGlmeSBwYWNrYWdlLmpzb24gZmlsZXMgYXMgbmVjZXNzYXJ5IGZvciBwdWJsaXNoaW5nXG4gICAgaWYgKHBhdGguYmFzZW5hbWUoZmlsZS5wYXRoKSA9PT0gJ3BhY2thZ2UuanNvbicpIHtcbiAgICAgIGNvbnN0IGlzUHJpbWFyeVBhY2thZ2VKc29uID0gb3V0cHV0UmVsYXRpdmVQYXRoID09PSAncGFja2FnZS5qc29uJztcbiAgICAgIGNvbnN0IHBhY2thZ2VKc29uID0gSlNPTi5wYXJzZShjb250ZW50KSBhcyBQYWNrYWdlSnNvbjtcbiAgICAgIGNvbnN0IHBhY2thZ2VOYW1lID0gcGFja2FnZUpzb25bJ25hbWUnXTtcblxuICAgICAgLy8gUHJldmVudCBub24tcHJpbWFyeSBgcGFja2FnZS5qc29uYCBmaWxlcyB3aGljaCB3b3VsZCB0aHJvdy1vZmYgcmVzb2x1dGlvbi5cbiAgICAgIC8vIFJlc29sdXRpb24gaW4gdGhlIHBhY2thZ2Ugc2hvdWxkIG9ubHkgYmUgYmFzZWQgb24gdGhlIHRvcC1sZXZlbCBgcGFja2FnZS5qc29uYC5cbiAgICAgIGlmICghaXNQcmltYXJ5UGFja2FnZUpzb24pIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgYEZvdW5kIGEgbmVzdGVkIFwicGFja2FnZS5qc29uXCIgZmlsZSBpbiB0aGUgcGFja2FnZSBvdXRwdXQ6ICR7ZmlsZS5zaG9ydFBhdGh9LlxcbmAgK1xuICAgICAgICAgICAgYEFsbCBpbmZvcm1hdGlvbiBvZiB0aGUgcGFja2FnZSBzaG91bGQgcmVzaWRlIGluIHRoZSBwcmltYXJ5IHBhY2thZ2UgZmlsZS5gLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgYG5hbWVgIGZpZWxkIG9mIHRoZSBgcGFja2FnZS5qc29uYCBmaWxlcyBhcmUgbWF0Y2hpbmcgd2l0aFxuICAgICAgLy8gbmFtZSBvZiB0aGUgTlBNIHBhY2thZ2UuIFRoaXMgaXMgYW4gYWRkaXRpb25hbCBzYWZldHkgY2hlY2suXG4gICAgICBpZiAocGFja2FnZU5hbWUgIT09IG1ldGFkYXRhLm5wbVBhY2thZ2VOYW1lKSB7XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIGBQcmltYXJ5IFwicGFja2FnZS5qc29uXCIgaGFzIG1pc21hdGNoaW5nIHBhY2thZ2UgbmFtZS4gRXhwZWN0ZWQgdGhlIGAgK1xuICAgICAgICAgICAgYHBhY2thZ2UgdG8gYmUgbmFtZWQgXCIke21ldGFkYXRhLm5wbVBhY2thZ2VOYW1lfVwiLCBidXQgaXMgc2V0IHRvOiAke3BhY2thZ2VOYW1lfS5gLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBsZXQgbmV3UGFja2FnZUpzb24gPSBpbnNlcnRGb3JtYXRGaWVsZHNJbnRvUGFja2FnZUpzb24oXG4gICAgICAgIG91dHB1dFJlbGF0aXZlUGF0aCxcbiAgICAgICAgcGFja2FnZUpzb24sXG4gICAgICAgIGZhbHNlLFxuICAgICAgKTtcblxuICAgICAgbmV3UGFja2FnZUpzb24gPSB1cGRhdGVQcmltYXJ5UGFja2FnZUpzb24obmV3UGFja2FnZUpzb24pO1xuXG4gICAgICAvLyBVcGRhdGUgdGhlIGNvbnRlbnQgd2l0aCB0aGUgbmV3IGBwYWNrYWdlLmpzb25gIGZpbGUgY29udGVudC5cbiAgICAgIGNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShuZXdQYWNrYWdlSnNvbiwgbnVsbCwgMik7XG4gICAgfVxuXG4gICAgd3JpdGVGaWxlKG91dHB1dFJlbGF0aXZlUGF0aCwgY29udGVudCk7XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0cyBvciBlZGl0cyBwcm9wZXJ0aWVzIGludG8gdGhlIHBhY2thZ2UuanNvbiBmaWxlKHMpIGluIHRoZSBwYWNrYWdlIHNvIHRoYXRcbiAgICogdGhleSBwb2ludCB0byBhbGwgdGhlIHJpZ2h0IGdlbmVyYXRlZCBhcnRpZmFjdHMuXG4gICAqXG4gICAqIEBwYXJhbSBwYWNrYWdlSnNvbk91dFJlbGF0aXZlUGF0aCBQYXRoIHdoZXJlIHRoZSBgcGFja2FnZS5qc29uYCBpcyBzdG9yZWQgaW5cbiAgICogICB0aGUgcGFja2FnZSBvdXRwdXQuXG4gICAqIEBwYXJhbSBwYXJzZWRQYWNrYWdlIFBhcnNlZCBwYWNrYWdlLmpzb24gY29udGVudFxuICAgKiBAcGFyYW0gaXNHZW5lcmF0ZWRQYWNrYWdlSnNvbiBXaGV0aGVyIHRoZSBwYXNzZWQgcGFja2FnZS5qc29uIGhhcyBiZWVuIGdlbmVyYXRlZC5cbiAgICovXG4gIGZ1bmN0aW9uIGluc2VydEZvcm1hdEZpZWxkc0ludG9QYWNrYWdlSnNvbihcbiAgICBwYWNrYWdlSnNvbk91dFJlbGF0aXZlUGF0aDogc3RyaW5nLFxuICAgIHBhcnNlZFBhY2thZ2U6IFJlYWRvbmx5PFBhY2thZ2VKc29uPixcbiAgICBpc0dlbmVyYXRlZFBhY2thZ2VKc29uOiBib29sZWFuLFxuICApOiBQYWNrYWdlSnNvbiB7XG4gICAgY29uc3QgcGFja2FnZUpzb246IFBhY2thZ2VKc29uID0gey4uLnBhcnNlZFBhY2thZ2V9O1xuICAgIGNvbnN0IHBhY2thZ2VOYW1lID0gcGFja2FnZUpzb25bJ25hbWUnXTtcbiAgICBjb25zdCBlbnRyeVBvaW50SW5mbyA9IG1ldGFkYXRhLmVudHJ5UG9pbnRzW3BhY2thZ2VOYW1lXTtcbiAgICBjb25zdCBwYWNrYWdlSnNvbkNvbnRhaW5pbmdEaXIgPSBwYXRoLmRpcm5hbWUocGFja2FnZUpzb25PdXRSZWxhdGl2ZVBhdGgpO1xuXG4gICAgLy8gSWYgYSBwYWNrYWdlIGpzb24gZmlsZSBoYXMgYmVlbiBkaXNjb3ZlcmVkIHRoYXQgZG9lcyBub3QgbWF0Y2ggYW55XG4gICAgLy8gZW50cnktcG9pbnQgaW4gdGhlIG1ldGFkYXRhLCB3ZSByZXBvcnQgYSB3YXJuaW5nIGFzIG1vc3QgbGlrZWx5IHRoZSB0YXJnZXRcbiAgICAvLyBpcyBjb25maWd1cmVkIGluY29ycmVjdGx5IChlLmcuIG1pc3NpbmcgYG1vZHVsZV9uYW1lYCBhdHRyaWJ1dGUpLlxuICAgIGlmICghZW50cnlQb2ludEluZm8pIHtcbiAgICAgIC8vIElkZWFsbHkgd2Ugc2hvdWxkIHRocm93IGhlcmUsIGFzIHdlIGdvdCBhbiBlbnRyeSBwb2ludCB0aGF0IGRvZXNuJ3RcbiAgICAgIC8vIGhhdmUgZmxhdCBtb2R1bGUgbWV0YWRhdGEgLyBidW5kbGUgaW5kZXgsIHNvIGl0IG1heSBoYXZlIGJlZW4gYW5cbiAgICAgIC8vIG5nX21vZHVsZSB0aGF0J3MgbWlzc2luZyBhIG1vZHVsZV9uYW1lIGF0dHJpYnV0ZS5cbiAgICAgIC8vIEhvd2V2ZXIsIEBhbmd1bGFyL2NvbXBpbGVyIGNhbid0IGJlIGFuIG5nX21vZHVsZSwgYXMgaXQncyB0aGUgaW50ZXJuYWxzXG4gICAgICAvLyBvZiB0aGUgbmdjIGNvbXBpbGVyLCB5ZXQgd2Ugd2FudCB0byBidWlsZCBhbiBuZ19wYWNrYWdlIGZvciBpdC5cbiAgICAgIC8vIFNvIGlnbm9yZSBwYWNrYWdlLmpzb24gZmlsZXMgd2hlbiB3ZSBhcmUgbWlzc2luZyBkYXRhLlxuICAgICAgY29uc29sZS5lcnJvcignV0FSTklORzogbm8gbW9kdWxlIG1ldGFkYXRhIGZvciBwYWNrYWdlJywgcGFja2FnZU5hbWUpO1xuICAgICAgY29uc29sZS5lcnJvcignICAgTm90IHVwZGF0aW5nIHRoZSBwYWNrYWdlLmpzb24gZmlsZSB0byBwb2ludCB0byBpdCcpO1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgJyAgIFRoZSBuZ19tb2R1bGUgZm9yIHRoaXMgcGFja2FnZSBpcyBwb3NzaWJseSBtaXNzaW5nIHRoZSBtb2R1bGVfbmFtZSBhdHRyaWJ1dGUgJyxcbiAgICAgICk7XG4gICAgICByZXR1cm4gcGFja2FnZUpzb247XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZ3Vlc3NlZCB0aGUgaW5kZXggcGF0aHMgZm9yIGEgbW9kdWxlLCBhbmQgaXQgY29udGFpbnMgYW4gZXhwbGljaXQgYHBhY2thZ2UuanNvbmBcbiAgICAvLyBmaWxlIHRoYXQgYWxyZWFkeSBzZXRzIGZvcm1hdCBwcm9wZXJ0aWVzLCB3ZSBza2lwIGF1dG9tYXRpYyBpbnNlcnRpb24gb2YgZm9ybWF0XG4gICAgLy8gcHJvcGVydGllcyBidXQgcmVwb3J0IGEgd2FybmluZyBpbiBjYXNlIHByb3BlcnRpZXMgaGF2ZSBiZWVuIHNldCBieSBhY2NpZGVudC5cbiAgICBpZiAoXG4gICAgICBlbnRyeVBvaW50SW5mby5ndWVzc2VkUGF0aHMgJiZcbiAgICAgICFpc0dlbmVyYXRlZFBhY2thZ2VKc29uICYmXG4gICAgICBoYXNFeHBsaWNpdEZvcm1hdFByb3BlcnRpZXMocGFja2FnZUpzb24pXG4gICAgKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdXQVJOSU5HOiBgcGFja2FnZS5qc29uYCBleHBsaWNpdGx5IHNldHMgZm9ybWF0IHByb3BlcnRpZXMgKGxpa2UgYG1haW5gKS4nKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICcgICAgU2tpcHBpbmcgYXV0b21hdGljIGluc2VydGlvbiBvZiBmb3JtYXQgcHJvcGVydGllcyBhcyBleHBsaWNpdCAnICtcbiAgICAgICAgICAnZm9ybWF0IHByb3BlcnRpZXMgYXJlIHNldC4nLFxuICAgICAgKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyAgICBJZ25vcmUgdGhpcyB3YXJuaW5nIGlmIGV4cGxpY2l0IHByb3BlcnRpZXMgYXJlIHNldCBpbnRlbnRpb25hbGx5LicpO1xuICAgICAgcmV0dXJuIHBhY2thZ2VKc29uO1xuICAgIH1cblxuICAgIGNvbnN0IGZlc20yMDIyUmVsYXRpdmVPdXRQYXRoID0gZW50cnlQb2ludEluZm8uZmVzbTIwMjJSZWxhdGl2ZVBhdGg7XG4gICAgY29uc3QgdHlwaW5nc1JlbGF0aXZlT3V0UGF0aCA9IGVudHJ5UG9pbnRJbmZvLmR0c0J1bmRsZVJlbGF0aXZlUGF0aDtcblxuICAgIHBhY2thZ2VKc29uLm1vZHVsZSA9IG5vcm1hbGl6ZVBhdGgoXG4gICAgICBwYXRoLnJlbGF0aXZlKHBhY2thZ2VKc29uQ29udGFpbmluZ0RpciwgZmVzbTIwMjJSZWxhdGl2ZU91dFBhdGgpLFxuICAgICk7XG4gICAgcGFja2FnZUpzb24udHlwaW5ncyA9IG5vcm1hbGl6ZVBhdGgoXG4gICAgICBwYXRoLnJlbGF0aXZlKHBhY2thZ2VKc29uQ29udGFpbmluZ0RpciwgdHlwaW5nc1JlbGF0aXZlT3V0UGF0aCksXG4gICAgKTtcblxuICAgIHJldHVybiBwYWNrYWdlSnNvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBwcmltYXJ5IGBwYWNrYWdlLmpzb25gIGZpbGUgb2YgdGhlIE5QTSBwYWNrYWdlIHRvIHNwZWNpZnlcbiAgICogdGhlIG1vZHVsZSBjb25kaXRpb25hbCBleHBvcnRzIGFuZCB0aGUgRVNNIG1vZHVsZSB0eXBlLlxuICAgKi9cbiAgZnVuY3Rpb24gdXBkYXRlUHJpbWFyeVBhY2thZ2VKc29uKHBhY2thZ2VKc29uOiBSZWFkb25seTxQYWNrYWdlSnNvbj4pOiBQYWNrYWdlSnNvbiB7XG4gICAgaWYgKHBhY2thZ2VKc29uLnR5cGUgIT09IHVuZGVmaW5lZCAmJiBwYWNrYWdlSnNvbi50eXBlICE9PSAnbW9kdWxlJykge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICdUaGUgcHJpbWFyeSBcInBhY2thZ2UuanNvblwiIGZpbGUgb2YgdGhlIHBhY2thZ2Ugc2V0cyB0aGUgXCJ0eXBlXCIgZmllbGQgJyArXG4gICAgICAgICAgJ3RoYXQgaXMgY29udHJvbGxlZCBieSB0aGUgcGFja2FnZXIuIFBsZWFzZSB1bnNldCBpdCBvciBzZXQgYHR5cGVgIHRvIGBtb2R1bGVgLicsXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld1BhY2thZ2VKc29uOiBQYWNrYWdlSnNvbiA9IHsuLi5wYWNrYWdlSnNvbn07XG5cbiAgICBuZXdQYWNrYWdlSnNvbi50eXBlID0gJ21vZHVsZSc7XG5cbiAgICAvLyBUaGUgYHBhY2thZ2UuanNvbmAgZmlsZSBpcyBtYWRlIHB1YmxpY2x5IGFjY2Vzc2libGUgZm9yIHRvb2xzIHRoYXRcbiAgICAvLyBtaWdodCB3YW50IHRvIHF1ZXJ5IGluZm9ybWF0aW9uIGZyb20gdGhlIEFuZ3VsYXIgTlBNIHBhY2thZ2UuXG4gICAgaW5zZXJ0RXhwb3J0TWFwcGluZ09yRXJyb3IobmV3UGFja2FnZUpzb24sICcuL3BhY2thZ2UuanNvbicsIHtkZWZhdWx0OiAnLi9wYWNrYWdlLmpzb24nfSk7XG5cbiAgICAvLyBDYXB0dXJlIGFsbCBlbnRyeS1wb2ludHMgaW4gdGhlIGBleHBvcnRzYCBmaWVsZCB1c2luZyB0aGUgc3VicGF0aCBleHBvcnQgZGVjbGFyYXRpb25zOlxuICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvcGFja2FnZXMuaHRtbCNwYWNrYWdlc19zdWJwYXRoX2V4cG9ydHMuXG4gICAgZm9yIChjb25zdCBbbW9kdWxlTmFtZSwgZW50cnlQb2ludF0gb2YgT2JqZWN0LmVudHJpZXMobWV0YWRhdGEuZW50cnlQb2ludHMpKSB7XG4gICAgICBjb25zdCBzdWJwYXRoID0gaXNTZWNvbmRhcnlFbnRyeVBvaW50KG1vZHVsZU5hbWUpXG4gICAgICAgID8gYC4vJHtnZXRFbnRyeVBvaW50U3VicGF0aChtb2R1bGVOYW1lKX1gXG4gICAgICAgIDogJy4nO1xuICAgICAgY29uc3QgZmVzbTIwMjJPdXRSZWxhdGl2ZVBhdGggPSBlbnRyeVBvaW50LmZlc20yMDIyUmVsYXRpdmVQYXRoO1xuICAgICAgY29uc3QgdHlwZXNPdXRSZWxhdGl2ZVBhdGggPSBlbnRyeVBvaW50LmR0c0J1bmRsZVJlbGF0aXZlUGF0aDtcblxuICAgICAgLy8gSW5zZXJ0IHRoZSBleHBvcnQgbWFwcGluZyBmb3IgdGhlIGVudHJ5LXBvaW50LiBXZSBzZXQgYGRlZmF1bHRgIHRvIHRoZSBGRVNNIDIwMjJcbiAgICAgIC8vIG91dHB1dCwgYW5kIGFsc28gc2V0IHRoZSBgdHlwZXNgIGNvbmRpdGlvbiB3aGljaCB3aWxsIGJlIHJlc3BlY3RlZCBieSBUUyA0LjUuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvcHVsbC80NTg4NC5cbiAgICAgIGluc2VydEV4cG9ydE1hcHBpbmdPckVycm9yKG5ld1BhY2thZ2VKc29uLCBzdWJwYXRoLCB7XG4gICAgICAgIHR5cGVzOiBub3JtYWxpemVQYXRoKHR5cGVzT3V0UmVsYXRpdmVQYXRoKSxcbiAgICAgICAgLy8gTm90ZTogVGhlIGRlZmF1bHQgY29uZGl0aW9ucyBuZWVkcyB0byBiZSB0aGUgbGFzdCBvbmUuXG4gICAgICAgIGRlZmF1bHQ6IG5vcm1hbGl6ZVBhdGgoZmVzbTIwMjJPdXRSZWxhdGl2ZVBhdGgpLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY2hlY2tQYWNrYWdlSnNvblNpZGVFZmZlY3RzKHBhY2thZ2VKc29uKTtcblxuICAgIHJldHVybiBuZXdQYWNrYWdlSnNvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrUGFja2FnZUpzb25TaWRlRWZmZWN0cyhwYWNrYWdlSnNvbjogUGFja2FnZUpzb24pOiB2b2lkIHtcbiAgICAvLyBDb252ZW5pZW5jZSBpZiB0aGVyZSBhcmUgbm8gc2lkZSBlZmZlY3RzLCBhbmQgaXQncyBleHBsaWNpdGx5IG1hcmtlZC5cbiAgICAvLyBUaGlzIGlzIG9rYXkgYW5kIHdlIGRvbid0IGFzayB0aGUgZGV2ZWxvcGVyIHRvIGRyb3AgdGhlIGV4cGxpY2l0IGZpZWxkLlxuICAgIGlmIChwYWNrYWdlSnNvbi5zaWRlRWZmZWN0cyA9PT0gZmFsc2UgJiYgc2lkZUVmZmVjdEVudHJ5UG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwYWNrYWdlSnNvbi5zaWRlRWZmZWN0cyA9PT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICdVbmV4cGVjdGVkIGBzaWRlRWZmZWN0c2AgZmllbGQgaW4gYHBhY2thZ2UuanNvbmAuICcgK1xuICAgICAgICAgICdTaWRlIGVmZmVjdHMgc2hvdWxkIGJlIGZpbmUtZ3JhaW5lZCBhbmQgbWFya2VkIHZpYSB0aGUgQmF6ZWwgYHNpZGVfZWZmZWN0X2VudHJ5X3BvaW50c2Agb3B0aW9uLicsXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHNpZGVFZmZlY3RzID0gcGFja2FnZUpzb24uc2lkZUVmZmVjdHMgYXMgdW5kZWZpbmVkIHwgZmFsc2UgfCBzdHJpbmdbXTtcbiAgICBjb25zdCBuZWVkZWRTaWRlRWZmZWN0cyA9IHNpZGVFZmZlY3RFbnRyeVBvaW50cy5tYXAoXG4gICAgICAoZW50cnlQb2ludE1vZHVsZSkgPT4gYC4vJHttZXRhZGF0YS5lbnRyeVBvaW50c1tlbnRyeVBvaW50TW9kdWxlXS5mZXNtMjAyMlJlbGF0aXZlUGF0aH1gLFxuICAgICk7XG4gICAgY29uc3QgbWlzc2luZ1NpZGVFZmZlY3RzID0gbmVlZGVkU2lkZUVmZmVjdHMuZmlsdGVyKFxuICAgICAgKHApID0+XG4gICAgICAgIC8vIEl0J3MgbWlzc2luZywgaWYgdGhlIHdob2xlIHBhY2thZ2UgaXMgbWFya2VkIGFzIGhhdmluZyBubyBzaWRlIGVmZmVjdHMuXG4gICAgICAgIHNpZGVFZmZlY3RzID09PSBmYWxzZSB8fFxuICAgICAgICAvLyBBbHRlcm5hdGl2ZWx5LCBpdCdzIG1pc3NpbmcgaWYgdGhlIGV4cGxpY2l0IGxpc3QgZG9lc24ndCBjb250YWluIHRoZSBwYXR0ZXJuLlxuICAgICAgICAhKHNpZGVFZmZlY3RzID8/IFtdKS5pbmNsdWRlcyhwKSxcbiAgICApO1xuXG4gICAgaWYgKG1pc3NpbmdTaWRlRWZmZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgJ01pc3Npbmcgc2lkZSBlZmZlY3RzIGluIGBwYWNrYWdlLmpzb25gIGBzaWRlRWZmZWN0c2AgZmllbGQuICcgK1xuICAgICAgICAgICdQbGVhc2UgYWRkIHRoZSBmb2xsb3dpbmcgc2lkZSBlZmZlY3QgZmlsZSBwYXR0ZXJuczpcXG4nICtcbiAgICAgICAgICBtaXNzaW5nU2lkZUVmZmVjdHMuam9pbignXFxuIC0gJyksXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEZpbmQgcG90ZW50aWFsIHNpZGUtZWZmZWN0cyB0aGF0IHJlZmVyIHRvIG91ciBGRVNNIGJ1bmRsZXMsIGJ1dCBhcmVuJ3QgcGFydFxuICAgIC8vIG9mIHRoZSBgbmdfcGFja2FnZWAga25vd24gZW50cnkgcG9pbnRzLlxuICAgIGNvbnN0IHVuZXhwZWN0ZWRFeHRyYSA9XG4gICAgICBzaWRlRWZmZWN0cyAhPT0gZmFsc2VcbiAgICAgICAgPyAoc2lkZUVmZmVjdHMgPz8gW10pLmZpbHRlcihcbiAgICAgICAgICAgIChwKSA9PiBwLmluY2x1ZGVzKCdmZXNtMjAyMicpICYmICFuZWVkZWRTaWRlRWZmZWN0cy5pbmNsdWRlcyhwKSxcbiAgICAgICAgICApXG4gICAgICAgIDogW107XG4gICAgaWYgKHVuZXhwZWN0ZWRFeHRyYS5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgJ1VuZXhwZWN0ZWQgc2lkZSBlZmZlY3RzIGluIGBwYWNrYWdlLmpzb25gIGBzaWRlRWZmZWN0c2AgZmllbGQgdGhhdCBpcyBub3Qga25vd24gdG8gYG5nX3BhY2thZ2VgLiAnICtcbiAgICAgICAgICAnUGxlYXNlIGFkZCB0aGUgc2lkZSBlZmZlY3QgZW50cnkgcG9pbnQgdG8gdGhlIEJhemVsIGBzaWRlX2VmZmVjdF9lbnRyeV9wb2ludHNgIG9wdGlvbi4gJyArXG4gICAgICAgICAgJ1VuZXhwZWN0ZWQgcGF0dGVybnM6XFxuJyArXG4gICAgICAgICAgdW5leHBlY3RlZEV4dHJhLmpvaW4oJ1xcbiAtICcpLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0cyBhIHN1YnBhdGggZXhwb3J0IG1hcHBpbmcgaW50byB0aGUgc3BlY2lmaWVkIGBwYWNrYWdlLmpzb25gIG9iamVjdC5cbiAgICogQHRocm93cyBBbiBlcnJvciBpZiB0aGUgbWFwcGluZyBpcyBhbHJlYWR5IGRlZmluZWQgYW5kIHdvdWxkIGNvbmZsaWN0LlxuICAgKi9cbiAgZnVuY3Rpb24gaW5zZXJ0RXhwb3J0TWFwcGluZ09yRXJyb3IoXG4gICAgcGFja2FnZUpzb246IFBhY2thZ2VKc29uLFxuICAgIHN1YnBhdGg6IHN0cmluZyxcbiAgICBtYXBwaW5nOiBDb25kaXRpb25hbEV4cG9ydCxcbiAgKSB7XG4gICAgaWYgKHBhY2thZ2VKc29uLmV4cG9ydHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcGFja2FnZUpzb24uZXhwb3J0cyA9IHt9O1xuICAgIH1cbiAgICBpZiAocGFja2FnZUpzb24uZXhwb3J0c1tzdWJwYXRoXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYWNrYWdlSnNvbi5leHBvcnRzW3N1YnBhdGhdID0ge307XG4gICAgfVxuXG4gICAgY29uc3Qgc3VicGF0aEV4cG9ydCA9IHBhY2thZ2VKc29uLmV4cG9ydHNbc3VicGF0aF07XG5cbiAgICAvLyBHbyB0aHJvdWdoIGFsbCBjb25kaXRpb25zIHRoYXQgc2hvdWxkIGJlIGluc2VydGVkLiBJZiB0aGUgY29uZGl0aW9uIGlzIGFscmVhZHlcbiAgICAvLyBtYW51YWxseSBzZXQgb2YgdGhlIHN1YnBhdGggZXhwb3J0LCB3ZSB0aHJvdyBhbiBlcnJvci4gSW4gZ2VuZXJhbCwgd2UgYWxsb3cgZm9yXG4gICAgLy8gYWRkaXRpb25hbCBjb25kaXRpb25zIHRvIGJlIHNldC4gVGhlc2Ugd2lsbCBhbHdheXMgcHJlY2VkZSB0aGUgZ2VuZXJhdGVkIG9uZXMuXG4gICAgZm9yIChjb25zdCBjb25kaXRpb25OYW1lIG9mIE9iamVjdC5rZXlzKG1hcHBpbmcpIGFzIFtrZXlvZiBDb25kaXRpb25hbEV4cG9ydF0pIHtcbiAgICAgIGlmIChzdWJwYXRoRXhwb3J0W2NvbmRpdGlvbk5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgYEZvdW5kIGEgY29uZmxpY3RpbmcgZXhwb3J0IGNvbmRpdGlvbiBmb3IgXCIke3N1YnBhdGh9XCIuIFRoZSBcIiR7Y29uZGl0aW9uTmFtZX1cIiBgICtcbiAgICAgICAgICAgIGBjb25kaXRpb24gd291bGQgYmUgb3ZlcnJpZGRlbiBieSB0aGUgcGFja2FnZXIuIFBsZWFzZSB1bnNldCBpdC5gLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyAqKk5vdGUqKjogVGhlIG9yZGVyIG9mIHRoZSBjb25kaXRpb25zIGlzIHByZXNlcnZlZCBldmVuIHRob3VnaCB3ZSBhcmUgc2V0dGluZ1xuICAgICAgLy8gdGhlIGNvbmRpdGlvbnMgb25jZSBhdCBhIHRpbWUgKHRoZSBsYXRlc3QgYXNzaWdubWVudCB3aWxsIGJlIGF0IHRoZSBlbmQpLlxuICAgICAgc3VicGF0aEV4cG9ydFtjb25kaXRpb25OYW1lXSA9IG1hcHBpbmdbY29uZGl0aW9uTmFtZV07XG4gICAgfVxuICB9XG5cbiAgLyoqIFdoZXRoZXIgdGhlIHBhY2thZ2UgZXhwbGljaXRseSBzZXRzIGFueSBvZiB0aGUgZm9ybWF0IHByb3BlcnRpZXMgKGxpa2UgYG1haW5gKS4gKi9cbiAgZnVuY3Rpb24gaGFzRXhwbGljaXRGb3JtYXRQcm9wZXJ0aWVzKHBhcnNlZFBhY2thZ2U6IFJlYWRvbmx5PFBhY2thZ2VKc29uPik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhwYXJzZWRQYWNrYWdlKS5zb21lKChmaWVsZE5hbWU6IHN0cmluZykgPT5cbiAgICAgIGtub3duRm9ybWF0UGFja2FnZUpzb25Gb3JtYXRGaWVsZHMuaW5jbHVkZXMoZmllbGROYW1lIGFzIEtub3duUGFja2FnZUpzb25Gb3JtYXRGaWVsZHMpLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplcyB0aGUgc3BlY2lmaWVkIHBhdGggYnkgcmVwbGFjaW5nIGJhY2tzbGFzaCBzZXBhcmF0b3JzIHdpdGggUG9zaXhcbiAgICogZm9yd2FyZCBzbGFzaCBzZXBhcmF0b3JzLlxuICAgKi9cbiAgZnVuY3Rpb24gbm9ybWFsaXplUGF0aChwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhdGgucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuICAgIHJldHVybiByZXN1bHQuc3RhcnRzV2l0aCgnLicpID8gcmVzdWx0IDogYC4vJHtyZXN1bHR9YDtcbiAgfVxufVxuIl19