/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import * as fs from 'fs';
import * as path from 'path';
/**
 * List of known `package.json` fields which provide information about
 * supported package formats and their associated entry paths.
 */
const knownFormatPackageJsonFormatFields = [
    'main',
    'fesm2020',
    'esm2020',
    'es2020',
    'typings',
    'module',
    'fesm2015',
];
// Main entry-point.
main(process.argv.slice(2));
function main(args) {
    // This utility expects all of its arguments to be specified in a params file generated by
    // bazel (see https://docs.bazel.build/versions/master/skylark/lib/Args.html#use_param_file).
    const paramFilePath = args[0];
    // Bazel params may be surrounded with quotes
    function unquoteParameter(s) {
        return s.replace(/^'(.*)'$/, '$1');
    }
    // Parameters are specified in the file one per line.
    const params = fs.readFileSync(paramFilePath, 'utf-8').split('\n').map(unquoteParameter);
    const [
    // Output directory for the npm package.
    outputDirExecPath, 
    // The package segment of the ng_package rule's label (e.g. 'package/common').
    owningPackageName, 
    // JSON data capturing metadata of the package being built. See `PackageMetadata`.
    metadataArg, 
    // Path to the package's README.md.
    readmeMd, 
    // List of rolled-up flat ES2020 modules
    fesm2020Arg, 
    // List of individual ES2020 modules
    esm2020Arg, 
    // List of rolled-up flat ES2015 modules
    fesm2015Arg, 
    // List of static files that should be copied into the package.
    staticFilesArg, 
    // List of all type definitions that need to packaged into the ng_package.
    typeDefinitionsArg,] = params;
    const fesm2020 = JSON.parse(fesm2020Arg);
    const esm2020 = JSON.parse(esm2020Arg);
    const fesm2015 = JSON.parse(fesm2015Arg);
    const typeDefinitions = JSON.parse(typeDefinitionsArg);
    const staticFiles = JSON.parse(staticFilesArg);
    const metadata = JSON.parse(metadataArg);
    if (readmeMd) {
        copyFile(readmeMd, 'README.md');
    }
    /**
     * Writes a file with the specified content into the package output.
     * @param outputRelativePath Relative path in the output directory where the
     *   file is written to.
     * @param fileContent Content of the file.
     */
    function writeFile(outputRelativePath, fileContent) {
        const outputPath = path.join(outputDirExecPath, outputRelativePath);
        // Always ensure that the target directory exists.
        fs.mkdirSync(path.dirname(outputPath), { recursive: true });
        fs.writeFileSync(outputPath, fileContent);
    }
    /**
     * Copies a file into the package output to the specified location.
     * @param inputPath File that should be copied.
     * @param outputRelativePath Relative path in the output directory where the
     *   file is written to.
     */
    function copyFile(inputPath, outputRelativePath) {
        const fileContent = fs.readFileSync(inputPath, 'utf8');
        writeFile(outputRelativePath, fileContent);
    }
    /**
     * Gets the relative path for the given file within the owning package. This
     * assumes the file is contained in the owning package.
     *
     * e.g. consider the owning package is `packages/core` and the input file
     * is `packages/core/testing/index.d.ts`. This function would return the
     * relative path as followed: `testing/index.d.ts`.
     */
    function getOwningPackageRelativePath(file) {
        return path.relative(owningPackageName, file.shortPath);
    }
    /** Writes an ESM file into the `esm2020` output directory. */
    function writeEsm2020File(file) {
        // Note: files which do not belong to the owning package of this `ng_package` are omitted.
        // this prevents us from accidentally bringing in transitive node module dependencies.
        const packageRelativePath = getOwningPackageRelativePath(file);
        if (!packageRelativePath.startsWith('..')) {
            copyFile(file.path, getEsm2020OutputRelativePath(file));
        }
    }
    /** Gets the output-relative path where the given flat ESM file should be written to. */
    function getFlatEsmOutputRelativePath(file) {
        // Flat ESM files should be put into their owning package relative sub-path. e.g. if
        // there is a bundle in `packages/animations/fesm2020/browser/testing.mjs` then we
        // want the bundle to be stored in `fesm2020/browser/testing.mjs`. Same thing applies
        // for the `fesm2015` bundles. The directory name for `fesm` is already declared as
        // part of the Bazel action generating these files. See `ng_package.bzl`.
        return getOwningPackageRelativePath(file);
    }
    /** Gets the output-relative path where a non-flat ESM2020 file should be written to. */
    function getEsm2020OutputRelativePath(file) {
        // Path computed relative to the current package in bazel-bin. e.g. a ES2020 output file
        // in `bazel-out/<..>/packages/core/src/di.mjs` should be stored in `esm2020/src/di.mjs`.
        return path.join('esm2020', getOwningPackageRelativePath(file));
    }
    /** Gets the output-relative path where the typing file is being written to. */
    function getTypingOutputRelativePath(file) {
        // Type definitions are intended to be copied into the package output while preserving the
        // sub-path from the owning package. e.g. a file like `packages/animations/browser/__index.d.ts`
        // will end up being written to `<pkg-out>/browser/index.d.ts`. Note that types are bundled
        // as a separate action in the `ng_package` Starlark rule and prefixed with `__` to avoid
        // conflicts with source `index.d.ts` files. We remove this prefix here.
        return getOwningPackageRelativePath(file).replace(/__index\.d\.ts$/, 'index.d.ts');
    }
    /**
     * Gets the entry-point sub-path from the package root. e.g. if the package name
     * is `@angular/cdk`, then for `@angular/cdk/a11y` just `a11y` would be returned.
     */
    function getEntryPointSubpath(moduleName) {
        return moduleName.slice(`${metadata.npmPackageName}/`.length);
    }
    /**
     * Gets whether the given module name resolves to a secondary entry-point.
     * e.g. if the package name is `@angular/cdk`, then for `@angular/cdk/a11y`
     * this would return `true`.
     */
    function isSecondaryEntryPoint(moduleName) {
        return getEntryPointSubpath(moduleName) !== '';
    }
    esm2020.forEach(file => writeEsm2020File(file));
    // Copy all FESM files into the package output.
    fesm2020.forEach(f => copyFile(f.path, getFlatEsmOutputRelativePath(f)));
    fesm2015.forEach(f => copyFile(f.path, getFlatEsmOutputRelativePath(f)));
    // Copy all type definitions into the package, preserving the sub-path from the
    // owning package. e.g. a file like `packages/animations/browser/__index.d.ts` will
    // end up in `browser/index.d.ts`
    typeDefinitions.forEach(f => copyFile(f.path, getTypingOutputRelativePath(f)));
    for (const file of staticFiles) {
        // We copy all files into the package output while preserving the sub-path from
        // the owning package. e.g. `packages/core/package.json` ends up `<pkg-out>/package.json`.
        const outputRelativePath = getOwningPackageRelativePath(file);
        let content = fs.readFileSync(file.path, 'utf8');
        // Check and modify package.json files as necessary for publishing
        if (path.basename(file.path) === 'package.json') {
            const isPrimaryPackageJson = outputRelativePath === 'package.json';
            const packageJson = JSON.parse(content);
            const packageName = packageJson['name'];
            // Prevent non-primary `package.json` files which would throw-off resolution.
            // Resolution in the package should only be based on the top-level `package.json`.
            if (!isPrimaryPackageJson) {
                throw Error(`Found a nested "package.json" file in the package output: ${file.shortPath}.\n` +
                    `All information of the package should reside in the primary package file.`);
            }
            // Check if the `name` field of the `package.json` files are matching with
            // name of the NPM package. This is an additional safety check.
            if (packageName !== metadata.npmPackageName) {
                throw Error(`Primary "package.json" has mismatching package name. Expected the ` +
                    `package to be named "${metadata.npmPackageName}", but is set to: ${packageName}.`);
            }
            let newPackageJson = insertFormatFieldsIntoPackageJson(outputRelativePath, packageJson, false);
            newPackageJson = updatePrimaryPackageJson(newPackageJson);
            // Update the content with the new `package.json` file content.
            content = JSON.stringify(newPackageJson, null, 2);
        }
        writeFile(outputRelativePath, content);
    }
    /**
     * Inserts or edits properties into the package.json file(s) in the package so that
     * they point to all the right generated artifacts.
     *
     * @param packageJsonOutRelativePath Path where the `package.json` is stored in
     *   the package output.
     * @param parsedPackage Parsed package.json content
     * @param isGeneratedPackageJson Whether the passed package.json has been generated.
     */
    function insertFormatFieldsIntoPackageJson(packageJsonOutRelativePath, parsedPackage, isGeneratedPackageJson) {
        const packageJson = { ...parsedPackage };
        const packageName = packageJson['name'];
        const entryPointInfo = metadata.entryPoints[packageName];
        const packageJsonContainingDir = path.dirname(packageJsonOutRelativePath);
        // If a package json file has been discovered that does not match any
        // entry-point in the metadata, we report a warning as most likely the target
        // is configured incorrectly (e.g. missing `module_name` attribute).
        if (!entryPointInfo) {
            // Ideally we should throw here, as we got an entry point that doesn't
            // have flat module metadata / bundle index, so it may have been an
            // ng_module that's missing a module_name attribute.
            // However, @angular/compiler can't be an ng_module, as it's the internals
            // of the ngc compiler, yet we want to build an ng_package for it.
            // So ignore package.json files when we are missing data.
            console.error('WARNING: no module metadata for package', packageName);
            console.error('   Not updating the package.json file to point to it');
            console.error('   The ng_module for this package is possibly missing the module_name attribute ');
            return packageJson;
        }
        // If we guessed the index paths for a module, and it contains an explicit `package.json`
        // file that already sets format properties, we skip automatic insertion of format
        // properties but report a warning in case properties have been set by accident.
        if (entryPointInfo.guessedPaths && !isGeneratedPackageJson &&
            hasExplicitFormatProperties(packageJson)) {
            console.error('WARNING: `package.json` explicitly sets format properties (like `main`).');
            console.error('    Skipping automatic insertion of format properties as explicit ' +
                'format properties are set.');
            console.error('    Ignore this warning if explicit properties are set intentionally.');
            return packageJson;
        }
        const fesm2020RelativeOutPath = getFlatEsmOutputRelativePath(entryPointInfo.fesm2020Bundle);
        const fesm2015RelativeOutPath = getFlatEsmOutputRelativePath(entryPointInfo.fesm2015Bundle);
        const esm2020RelativeOutPath = getEsm2020OutputRelativePath(entryPointInfo.index);
        const typingsRelativeOutPath = getTypingOutputRelativePath(entryPointInfo.typings);
        packageJson.fesm2020 =
            normalizePath(path.relative(packageJsonContainingDir, fesm2020RelativeOutPath));
        packageJson.fesm2015 =
            normalizePath(path.relative(packageJsonContainingDir, fesm2015RelativeOutPath));
        packageJson.esm2020 =
            normalizePath(path.relative(packageJsonContainingDir, esm2020RelativeOutPath));
        packageJson.typings =
            normalizePath(path.relative(packageJsonContainingDir, typingsRelativeOutPath));
        // For now, we point the primary entry points at the fesm files, because of Webpack
        // performance issues with a large number of individual files.
        packageJson.module = packageJson.fesm2015;
        packageJson.es2020 = packageJson.fesm2020;
        return packageJson;
    }
    /**
     * Updates the primary `package.json` file of the NPM package to specify
     * the module conditional exports and the ESM module type.
     */
    function updatePrimaryPackageJson(packageJson) {
        if (packageJson.type !== undefined) {
            throw Error('The primary "package.json" file of the package sets the "type" field ' +
                'that is controlled by the packager. Please unset it.');
        }
        const newPackageJson = { ...packageJson };
        newPackageJson.type = 'module';
        // The `package.json` file is made publicly accessible for tools that
        // might want to query information from the Angular NPM package.
        insertExportMappingOrError(newPackageJson, './package.json', { default: './package.json' });
        // Capture all entry-points in the `exports` field using the subpath export declarations:
        // https://nodejs.org/api/packages.html#packages_subpath_exports.
        for (const [moduleName, entryPoint] of Object.entries(metadata.entryPoints)) {
            const subpath = isSecondaryEntryPoint(moduleName) ? `./${getEntryPointSubpath(moduleName)}` : '.';
            const esm2020IndexOutRelativePath = getEsm2020OutputRelativePath(entryPoint.index);
            const fesm2020OutRelativePath = getFlatEsmOutputRelativePath(entryPoint.fesm2020Bundle);
            const fesm2015OutRelativePath = getFlatEsmOutputRelativePath(entryPoint.fesm2015Bundle);
            const typesOutRelativePath = getTypingOutputRelativePath(entryPoint.typings);
            // Insert the export mapping for the entry-point. We set `default` to the FESM 2020
            // output, and also set the `types` condition which will be respected by TS 4.5.
            // https://github.com/microsoft/TypeScript/pull/45884.
            insertExportMappingOrError(newPackageJson, subpath, {
                types: normalizePath(typesOutRelativePath),
                esm2020: normalizePath(esm2020IndexOutRelativePath),
                es2020: normalizePath(fesm2020OutRelativePath),
                // We also expose a non-standard condition that would allow consumers to resolve
                // to the `ES2015` output outside of NodeJS, if desired.
                // TODO(devversion): remove/replace this if NodeJS v12 is no longer supported.
                es2015: normalizePath(fesm2015OutRelativePath),
                // We declare the `node` condition and point to the ES2015 output as we currently still
                // support NodeJS v12 which does not fully support ES2020 output. We chose ES2015 over
                // ES2020 because we wan async/await downleveled as this allows for patching withZoneJS.
                // TODO(devversion): remove/replace this if NodeJS v12 is no longer supported.
                node: normalizePath(fesm2015OutRelativePath),
                // Note: The default conditions needs to be the last one.
                default: normalizePath(fesm2020OutRelativePath),
            });
        }
        return newPackageJson;
    }
    /**
     * Inserts a subpath export mapping into the specified `package.json` object.
     * @throws An error if the mapping is already defined and would conflict.
     */
    function insertExportMappingOrError(packageJson, subpath, mapping) {
        if (packageJson.exports === undefined) {
            packageJson.exports = {};
        }
        if (packageJson.exports[subpath] === undefined) {
            packageJson.exports[subpath] = {};
        }
        const subpathExport = packageJson.exports[subpath];
        // Go through all conditions that should be inserted. If the condition is already
        // manually set of the subpath export, we throw an error. In general, we allow for
        // additional conditions to be set. These will always precede the generated ones.
        for (const conditionName of Object.keys(mapping)) {
            if (subpathExport[conditionName] !== undefined) {
                throw Error(`Found a conflicting export condition for "${subpath}". The "${conditionName}" ` +
                    `condition would be overridden by the packager. Please unset it.`);
            }
            // **Note**: The order of the conditions is preserved even though we are setting
            // the conditions once at a time (the latest assignment will be at the end).
            subpathExport[conditionName] = mapping[conditionName];
        }
    }
    /** Whether the package explicitly sets any of the format properties (like `main`). */
    function hasExplicitFormatProperties(parsedPackage) {
        return Object.keys(parsedPackage)
            .some((fieldName) => knownFormatPackageJsonFormatFields.includes(fieldName));
    }
    /**
     * Normalizes the specified path by replacing backslash separators with Posix
     * forward slash separators.
     */
    function normalizePath(path) {
        const result = path.replace(/\\/g, '/');
        return result.startsWith('.') ? result : `./${result}`;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFja2FnZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9iYXplbC9zcmMvbmdfcGFja2FnZS9wYWNrYWdlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFFSCxPQUFPLEtBQUssRUFBRSxNQUFNLElBQUksQ0FBQztBQUN6QixPQUFPLEtBQUssSUFBSSxNQUFNLE1BQU0sQ0FBQztBQXVDN0I7OztHQUdHO0FBQ0gsTUFBTSxrQ0FBa0MsR0FBRztJQUN6QyxNQUFNO0lBQ04sVUFBVTtJQUNWLFNBQVM7SUFDVCxRQUFRO0lBQ1IsU0FBUztJQUNULFFBQVE7SUFDUixVQUFVO0NBQ0YsQ0FBQztBQTJCWCxvQkFBb0I7QUFDcEIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFFNUIsU0FBUyxJQUFJLENBQUMsSUFBYztJQUMxQiwwRkFBMEY7SUFDMUYsNkZBQTZGO0lBQzdGLE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUU5Qiw2Q0FBNkM7SUFDN0MsU0FBUyxnQkFBZ0IsQ0FBQyxDQUFTO1FBQ2pDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVELHFEQUFxRDtJQUNyRCxNQUFNLE1BQU0sR0FBRyxFQUFFLENBQUMsWUFBWSxDQUFDLGFBQWEsRUFBRSxPQUFPLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLENBQUM7SUFFekYsTUFBTTtJQUNGLHdDQUF3QztJQUN4QyxpQkFBaUI7SUFFakIsOEVBQThFO0lBQzlFLGlCQUFpQjtJQUVqQixrRkFBa0Y7SUFDbEYsV0FBVztJQUVYLG1DQUFtQztJQUNuQyxRQUFRO0lBRVIsd0NBQXdDO0lBQ3hDLFdBQVc7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QyxDQUFDLENBQUM7SUFDdEUsQ0FBQztJQUVEOzs7T0FHRztJQUNILFNBQVMsYUFBYSxDQUFDLElBQVk7UUFDakMsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDeEMsT0FBTyxNQUFNLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssTUFBTSxFQUFFLENBQUM7SUFDekQsQ0FBQztBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcblxuLyoqXG4gKiBJbnRlcmZhY2UgZGVzY3JpYmluZyBhIGZpbGUgY2FwdHVyZWQgaW4gdGhlIEJhemVsIGFjdGlvbi5cbiAqIGh0dHBzOi8vZG9jcy5iYXplbC5idWlsZC92ZXJzaW9ucy9tYWluL3NreWxhcmsvbGliL0ZpbGUuaHRtbC5cbiAqL1xuaW50ZXJmYWNlIEJhemVsRmlsZUluZm8ge1xuICAvKiogRXhlY3Jvb3QtcmVsYXRpdmUgcGF0aCBwb2ludGluZyB0byB0aGUgZmlsZS4gKi9cbiAgcGF0aDogc3RyaW5nO1xuICAvKiogVGhlIHBhdGggb2YgdGhpcyBmaWxlIHJlbGF0aXZlIHRvIGl0cyByb290LiBlLmcuIG9taXR0aW5nIGBiYXplbC1vdXQvPC4uPi9iaW5gLiAqL1xuICBzaG9ydFBhdGg6IHN0cmluZztcbn1cblxuLyoqIEludGVyZmFjZSBkZXNjcmliaW5nIGFuIGVudHJ5LXBvaW50LiAqL1xuaW50ZXJmYWNlIEVudHJ5UG9pbnRJbmZvIHtcbiAgLyoqIEVTMjAyMCBpbmRleCBmaWxlIGZvciB0aGUgQVBGIGVudHJ5LXBvaW50LiAqL1xuICBpbmRleDogQmF6ZWxGaWxlSW5mbztcbiAgLyoqIEZsYXQgRVMyMDIwIEVTIG1vZHVsZSBidW5kbGUgZmlsZS4gKi9cbiAgZmVzbTIwMjBCdW5kbGU6IEJhemVsRmlsZUluZm87XG4gIC8qKiBGbGF0IEVTMjAxNSBFUyBtb2R1bGUgYnVuZGxlIGZpbGUuICovXG4gIGZlc20yMDE1QnVuZGxlOiBCYXplbEZpbGVJbmZvO1xuICAvKiogSW5kZXggdHlwZSBkZWZpbml0aW9uIGZpbGUgZm9yIHRoZSBBUEYgZW50cnktcG9pbnQuICovXG4gIHR5cGluZ3M6IEJhemVsRmlsZUluZm87XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBpbmRleCBvciB0eXBpbmcgcGF0aHMgaGF2ZSBiZWVuIGd1ZXNzZWQuIEZvciBlbnRyeS1wb2ludHMgYnVpbHRcbiAgICogdGhyb3VnaCBgdHNfbGlicmFyeWAsIHRoZXJlIGlzIG5vIGV4cGxpY2l0IHNldHRpbmcgdGhhdCBkZWNsYXJlcyB0aGUgZW50cnktcG9pbnRcbiAgICogc28gdGhlIGluZGV4IGZpbGUgaXMgZ3Vlc3NlZC5cbiAgICovXG4gIGd1ZXNzZWRQYXRoczogYm9vbGVhbjtcbn1cblxuLyoqIEludGVyZmFjZSBjYXB0dXJpbmcgcmVsZXZhbnQgbWV0YWRhdGEgZm9yIHBhY2thZ2luZy4gKi9cbmludGVyZmFjZSBQYWNrYWdlTWV0YWRhdGEge1xuICAvKiogTlBNIHBhY2thZ2UgbmFtZSBvZiB0aGUgb3V0cHV0LiAqL1xuICBucG1QYWNrYWdlTmFtZTogc3RyaW5nO1xuICAvKiogUmVjb3JkIG9mIGVudHJ5LXBvaW50cyAoaW5jbHVkaW5nIHRoZSBwcmltYXJ5IG9uZSkgYW5kIHRoZWlyIGluZm8uICovXG4gIGVudHJ5UG9pbnRzOiBSZWNvcmQ8c3RyaW5nLCBFbnRyeVBvaW50SW5mbz47XG59XG5cbi8qKlxuICogTGlzdCBvZiBrbm93biBgcGFja2FnZS5qc29uYCBmaWVsZHMgd2hpY2ggcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dFxuICogc3VwcG9ydGVkIHBhY2thZ2UgZm9ybWF0cyBhbmQgdGhlaXIgYXNzb2NpYXRlZCBlbnRyeSBwYXRocy5cbiAqL1xuY29uc3Qga25vd25Gb3JtYXRQYWNrYWdlSnNvbkZvcm1hdEZpZWxkcyA9IFtcbiAgJ21haW4nLFxuICAnZmVzbTIwMjAnLFxuICAnZXNtMjAyMCcsXG4gICdlczIwMjAnLFxuICAndHlwaW5ncycsXG4gICdtb2R1bGUnLFxuICAnZmVzbTIwMTUnLFxuXSBhcyBjb25zdDtcblxuLyoqIFVuaW9uIHR5cGUgbWF0Y2hpbmcga25vd24gYHBhY2thZ2UuanNvbmAgZm9ybWF0IGZpZWxkcy4gKi9cbnR5cGUgS25vd25QYWNrYWdlSnNvbkZvcm1hdEZpZWxkcyA9IHR5cGVvZiBrbm93bkZvcm1hdFBhY2thZ2VKc29uRm9ybWF0RmllbGRzW251bWJlcl07XG5cbi8qKlxuICogVHlwZSBkZXNjcmliaW5nIHRoZSBjb25kaXRpb25hbCBleHBvcnRzIGRlc2NyaXB0b3IgZm9yIGFuIGVudHJ5LXBvaW50LlxuICogaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9wYWNrYWdlcy5odG1sI3BhY2thZ2VzX2NvbmRpdGlvbmFsX2V4cG9ydHNcbiAqL1xudHlwZSBDb25kaXRpb25hbEV4cG9ydCA9IHtcbiAgbm9kZT86IHN0cmluZztcbiAgdHlwZXM/OiBzdHJpbmc7XG4gIGVzbTIwMjA/OiBzdHJpbmc7XG4gIGVzMjAyMD86IHN0cmluZztcbiAgZXMyMDE1Pzogc3RyaW5nO1xuICBkZWZhdWx0Pzogc3RyaW5nO1xufTtcblxuLyoqIFR5cGUgZGVzY3JpYmluZyBhIGBwYWNrYWdlLmpzb25gIHRoZSBwYWNrYWdlciBkZWFscyB3aXRoLiAqL1xudHlwZSBQYWNrYWdlSnNvbiA9IHtcbiAgW2tleSBpbiBLbm93blBhY2thZ2VKc29uRm9ybWF0RmllbGRzXT86IHN0cmluZztcbn0me1xuICBuYW1lOiBzdHJpbmc7XG4gIHR5cGU/OiBzdHJpbmc7XG4gIGV4cG9ydHM/OiBSZWNvcmQ8c3RyaW5nLCBDb25kaXRpb25hbEV4cG9ydD47XG59O1xuXG4vLyBNYWluIGVudHJ5LXBvaW50LlxubWFpbihwcm9jZXNzLmFyZ3Yuc2xpY2UoMikpO1xuXG5mdW5jdGlvbiBtYWluKGFyZ3M6IHN0cmluZ1tdKTogdm9pZCB7XG4gIC8vIFRoaXMgdXRpbGl0eSBleHBlY3RzIGFsbCBvZiBpdHMgYXJndW1lbnRzIHRvIGJlIHNwZWNpZmllZCBpbiBhIHBhcmFtcyBmaWxlIGdlbmVyYXRlZCBieVxuICAvLyBiYXplbCAoc2VlIGh0dHBzOi8vZG9jcy5iYXplbC5idWlsZC92ZXJzaW9ucy9tYXN0ZXIvc2t5bGFyay9saWIvQXJncy5odG1sI3VzZV9wYXJhbV9maWxlKS5cbiAgY29uc3QgcGFyYW1GaWxlUGF0aCA9IGFyZ3NbMF07XG5cbiAgLy8gQmF6ZWwgcGFyYW1zIG1heSBiZSBzdXJyb3VuZGVkIHdpdGggcXVvdGVzXG4gIGZ1bmN0aW9uIHVucXVvdGVQYXJhbWV0ZXIoczogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZSgvXicoLiopJyQvLCAnJDEnKTtcbiAgfVxuXG4gIC8vIFBhcmFtZXRlcnMgYXJlIHNwZWNpZmllZCBpbiB0aGUgZmlsZSBvbmUgcGVyIGxpbmUuXG4gIGNvbnN0IHBhcmFtcyA9IGZzLnJlYWRGaWxlU3luYyhwYXJhbUZpbGVQYXRoLCAndXRmLTgnKS5zcGxpdCgnXFxuJykubWFwKHVucXVvdGVQYXJhbWV0ZXIpO1xuXG4gIGNvbnN0IFtcbiAgICAgIC8vIE91dHB1dCBkaXJlY3RvcnkgZm9yIHRoZSBucG0gcGFja2FnZS5cbiAgICAgIG91dHB1dERpckV4ZWNQYXRoLFxuXG4gICAgICAvLyBUaGUgcGFja2FnZSBzZWdtZW50IG9mIHRoZSBuZ19wYWNrYWdlIHJ1bGUncyBsYWJlbCAoZS5nLiAncGFja2FnZS9jb21tb24nKS5cbiAgICAgIG93bmluZ1BhY2thZ2VOYW1lLFxuXG4gICAgICAvLyBKU09OIGRhdGEgY2FwdHVyaW5nIG1ldGFkYXRhIG9mIHRoZSBwYWNrYWdlIGJlaW5nIGJ1aWx0LiBTZWUgYFBhY2thZ2VNZXRhZGF0YWAuXG4gICAgICBtZXRhZGF0YUFyZyxcblxuICAgICAgLy8gUGF0aCB0byB0aGUgcGFja2FnZSdzIFJFQURNRS5tZC5cbiAgICAgIHJlYWRtZU1kLFxuXG4gICAgICAvLyBMaXN0IG9mIHJvbGxlZC11cCBmbGF0IEVTMjAyMCBtb2R1bGVzXG4gICAgICBmZXNtMjAyMEFyZyxcblxuICAgICAgLy8gTGlzdCBvZiBpbmRpdmlkdWFsIEVTMjAyMCBtb2R1bGVzXG4gICAgICBlc20yMDIwQXJnLFxuXG4gICAgICAvLyBMaXN0IG9mIHJvbGxlZC11cCBmbGF0IEVTMjAxNSBtb2R1bGVzXG4gICAgICBmZXNtMjAxNUFyZyxcblxuICAgICAgLy8gTGlzdCBvZiBzdGF0aWMgZmlsZXMgdGhhdCBzaG91bGQgYmUgY29waWVkIGludG8gdGhlIHBhY2thZ2UuXG4gICAgICBzdGF0aWNGaWxlc0FyZyxcblxuICAgICAgLy8gTGlzdCBvZiBhbGwgdHlwZSBkZWZpbml0aW9ucyB0aGF0IG5lZWQgdG8gcGFja2FnZWQgaW50byB0aGUgbmdfcGFja2FnZS5cbiAgICAgIHR5cGVEZWZpbml0aW9uc0FyZyxcbiAgXSA9IHBhcmFtcztcblxuICBjb25zdCBmZXNtMjAyMCA9IEpTT04ucGFyc2UoZmVzbTIwMjBBcmcpIGFzIEJhemVsRmlsZUluZm9bXTtcbiAgY29uc3QgZXNtMjAyMCA9IEpTT04ucGFyc2UoZXNtMjAyMEFyZykgYXMgQmF6ZWxGaWxlSW5mb1tdO1xuICBjb25zdCBmZXNtMjAxNSA9IEpTT04ucGFyc2UoZmVzbTIwMTVBcmcpIGFzIEJhemVsRmlsZUluZm9bXTtcbiAgY29uc3QgdHlwZURlZmluaXRpb25zID0gSlNPTi5wYXJzZSh0eXBlRGVmaW5pdGlvbnNBcmcpIGFzIEJhemVsRmlsZUluZm9bXTtcbiAgY29uc3Qgc3RhdGljRmlsZXMgPSBKU09OLnBhcnNlKHN0YXRpY0ZpbGVzQXJnKSBhcyBCYXplbEZpbGVJbmZvW107XG4gIGNvbnN0IG1ldGFkYXRhID0gSlNPTi5wYXJzZShtZXRhZGF0YUFyZykgYXMgUGFja2FnZU1ldGFkYXRhO1xuXG4gIGlmIChyZWFkbWVNZCkge1xuICAgIGNvcHlGaWxlKHJlYWRtZU1kLCAnUkVBRE1FLm1kJyk7XG4gIH1cblxuICAvKipcbiAgICogV3JpdGVzIGEgZmlsZSB3aXRoIHRoZSBzcGVjaWZpZWQgY29udGVudCBpbnRvIHRoZSBwYWNrYWdlIG91dHB1dC5cbiAgICogQHBhcmFtIG91dHB1dFJlbGF0aXZlUGF0aCBSZWxhdGl2ZSBwYXRoIGluIHRoZSBvdXRwdXQgZGlyZWN0b3J5IHdoZXJlIHRoZVxuICAgKiAgIGZpbGUgaXMgd3JpdHRlbiB0by5cbiAgICogQHBhcmFtIGZpbGVDb250ZW50IENvbnRlbnQgb2YgdGhlIGZpbGUuXG4gICAqL1xuICBmdW5jdGlvbiB3cml0ZUZpbGUob3V0cHV0UmVsYXRpdmVQYXRoOiBzdHJpbmcsIGZpbGVDb250ZW50OiBzdHJpbmd8QnVmZmVyKSB7XG4gICAgY29uc3Qgb3V0cHV0UGF0aCA9IHBhdGguam9pbihvdXRwdXREaXJFeGVjUGF0aCwgb3V0cHV0UmVsYXRpdmVQYXRoKTtcblxuICAgIC8vIEFsd2F5cyBlbnN1cmUgdGhhdCB0aGUgdGFyZ2V0IGRpcmVjdG9yeSBleGlzdHMuXG4gICAgZnMubWtkaXJTeW5jKHBhdGguZGlybmFtZShvdXRwdXRQYXRoKSwge3JlY3Vyc2l2ZTogdHJ1ZX0pO1xuICAgIGZzLndyaXRlRmlsZVN5bmMob3V0cHV0UGF0aCwgZmlsZUNvbnRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvcGllcyBhIGZpbGUgaW50byB0aGUgcGFja2FnZSBvdXRwdXQgdG8gdGhlIHNwZWNpZmllZCBsb2NhdGlvbi5cbiAgICogQHBhcmFtIGlucHV0UGF0aCBGaWxlIHRoYXQgc2hvdWxkIGJlIGNvcGllZC5cbiAgICogQHBhcmFtIG91dHB1dFJlbGF0aXZlUGF0aCBSZWxhdGl2ZSBwYXRoIGluIHRoZSBvdXRwdXQgZGlyZWN0b3J5IHdoZXJlIHRoZVxuICAgKiAgIGZpbGUgaXMgd3JpdHRlbiB0by5cbiAgICovXG4gIGZ1bmN0aW9uIGNvcHlGaWxlKGlucHV0UGF0aDogc3RyaW5nLCBvdXRwdXRSZWxhdGl2ZVBhdGg6IHN0cmluZykge1xuICAgIGNvbnN0IGZpbGVDb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKGlucHV0UGF0aCwgJ3V0ZjgnKTtcbiAgICB3cml0ZUZpbGUob3V0cHV0UmVsYXRpdmVQYXRoLCBmaWxlQ29udGVudCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgcmVsYXRpdmUgcGF0aCBmb3IgdGhlIGdpdmVuIGZpbGUgd2l0aGluIHRoZSBvd25pbmcgcGFja2FnZS4gVGhpc1xuICAgKiBhc3N1bWVzIHRoZSBmaWxlIGlzIGNvbnRhaW5lZCBpbiB0aGUgb3duaW5nIHBhY2thZ2UuXG4gICAqXG4gICAqIGUuZy4gY29uc2lkZXIgdGhlIG93bmluZyBwYWNrYWdlIGlzIGBwYWNrYWdlcy9jb3JlYCBhbmQgdGhlIGlucHV0IGZpbGVcbiAgICogaXMgYHBhY2thZ2VzL2NvcmUvdGVzdGluZy9pbmRleC5kLnRzYC4gVGhpcyBmdW5jdGlvbiB3b3VsZCByZXR1cm4gdGhlXG4gICAqIHJlbGF0aXZlIHBhdGggYXMgZm9sbG93ZWQ6IGB0ZXN0aW5nL2luZGV4LmQudHNgLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0T3duaW5nUGFja2FnZVJlbGF0aXZlUGF0aChmaWxlOiBCYXplbEZpbGVJbmZvKTogc3RyaW5nIHtcbiAgICByZXR1cm4gcGF0aC5yZWxhdGl2ZShvd25pbmdQYWNrYWdlTmFtZSwgZmlsZS5zaG9ydFBhdGgpO1xuICB9XG5cbiAgLyoqIFdyaXRlcyBhbiBFU00gZmlsZSBpbnRvIHRoZSBgZXNtMjAyMGAgb3V0cHV0IGRpcmVjdG9yeS4gKi9cbiAgZnVuY3Rpb24gd3JpdGVFc20yMDIwRmlsZShmaWxlOiBCYXplbEZpbGVJbmZvKSB7XG4gICAgLy8gTm90ZTogZmlsZXMgd2hpY2ggZG8gbm90IGJlbG9uZyB0byB0aGUgb3duaW5nIHBhY2thZ2Ugb2YgdGhpcyBgbmdfcGFja2FnZWAgYXJlIG9taXR0ZWQuXG4gICAgLy8gdGhpcyBwcmV2ZW50cyB1cyBmcm9tIGFjY2lkZW50YWxseSBicmluZ2luZyBpbiB0cmFuc2l0aXZlIG5vZGUgbW9kdWxlIGRlcGVuZGVuY2llcy5cbiAgICBjb25zdCBwYWNrYWdlUmVsYXRpdmVQYXRoID0gZ2V0T3duaW5nUGFja2FnZVJlbGF0aXZlUGF0aChmaWxlKTtcbiAgICBpZiAoIXBhY2thZ2VSZWxhdGl2ZVBhdGguc3RhcnRzV2l0aCgnLi4nKSkge1xuICAgICAgY29weUZpbGUoZmlsZS5wYXRoLCBnZXRFc20yMDIwT3V0cHV0UmVsYXRpdmVQYXRoKGZpbGUpKTtcbiAgICB9XG4gIH1cblxuICAvKiogR2V0cyB0aGUgb3V0cHV0LXJlbGF0aXZlIHBhdGggd2hlcmUgdGhlIGdpdmVuIGZsYXQgRVNNIGZpbGUgc2hvdWxkIGJlIHdyaXR0ZW4gdG8uICovXG4gIGZ1bmN0aW9uIGdldEZsYXRFc21PdXRwdXRSZWxhdGl2ZVBhdGgoZmlsZTogQmF6ZWxGaWxlSW5mbykge1xuICAgIC8vIEZsYXQgRVNNIGZpbGVzIHNob3VsZCBiZSBwdXQgaW50byB0aGVpciBvd25pbmcgcGFja2FnZSByZWxhdGl2ZSBzdWItcGF0aC4gZS5nLiBpZlxuICAgIC8vIHRoZXJlIGlzIGEgYnVuZGxlIGluIGBwYWNrYWdlcy9hbmltYXRpb25zL2Zlc20yMDIwL2Jyb3dzZXIvdGVzdGluZy5tanNgIHRoZW4gd2VcbiAgICAvLyB3YW50IHRoZSBidW5kbGUgdG8gYmUgc3RvcmVkIGluIGBmZXNtMjAyMC9icm93c2VyL3Rlc3RpbmcubWpzYC4gU2FtZSB0aGluZyBhcHBsaWVzXG4gICAgLy8gZm9yIHRoZSBgZmVzbTIwMTVgIGJ1bmRsZXMuIFRoZSBkaXJlY3RvcnkgbmFtZSBmb3IgYGZlc21gIGlzIGFscmVhZHkgZGVjbGFyZWQgYXNcbiAgICAvLyBwYXJ0IG9mIHRoZSBCYXplbCBhY3Rpb24gZ2VuZXJhdGluZyB0aGVzZSBmaWxlcy4gU2VlIGBuZ19wYWNrYWdlLmJ6bGAuXG4gICAgcmV0dXJuIGdldE93bmluZ1BhY2thZ2VSZWxhdGl2ZVBhdGgoZmlsZSk7XG4gIH1cblxuICAvKiogR2V0cyB0aGUgb3V0cHV0LXJlbGF0aXZlIHBhdGggd2hlcmUgYSBub24tZmxhdCBFU00yMDIwIGZpbGUgc2hvdWxkIGJlIHdyaXR0ZW4gdG8uICovXG4gIGZ1bmN0aW9uIGdldEVzbTIwMjBPdXRwdXRSZWxhdGl2ZVBhdGgoZmlsZTogQmF6ZWxGaWxlSW5mbykge1xuICAgIC8vIFBhdGggY29tcHV0ZWQgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcGFja2FnZSBpbiBiYXplbC1iaW4uIGUuZy4gYSBFUzIwMjAgb3V0cHV0IGZpbGVcbiAgICAvLyBpbiBgYmF6ZWwtb3V0LzwuLj4vcGFja2FnZXMvY29yZS9zcmMvZGkubWpzYCBzaG91bGQgYmUgc3RvcmVkIGluIGBlc20yMDIwL3NyYy9kaS5tanNgLlxuICAgIHJldHVybiBwYXRoLmpvaW4oJ2VzbTIwMjAnLCBnZXRPd25pbmdQYWNrYWdlUmVsYXRpdmVQYXRoKGZpbGUpKTtcbiAgfVxuXG4gIC8qKiBHZXRzIHRoZSBvdXRwdXQtcmVsYXRpdmUgcGF0aCB3aGVyZSB0aGUgdHlwaW5nIGZpbGUgaXMgYmVpbmcgd3JpdHRlbiB0by4gKi9cbiAgZnVuY3Rpb24gZ2V0VHlwaW5nT3V0cHV0UmVsYXRpdmVQYXRoKGZpbGU6IEJhemVsRmlsZUluZm8pIHtcbiAgICAvLyBUeXBlIGRlZmluaXRpb25zIGFyZSBpbnRlbmRlZCB0byBiZSBjb3BpZWQgaW50byB0aGUgcGFja2FnZSBvdXRwdXQgd2hpbGUgcHJlc2VydmluZyB0aGVcbiAgICAvLyBzdWItcGF0aCBmcm9tIHRoZSBvd25pbmcgcGFja2FnZS4gZS5nLiBhIGZpbGUgbGlrZSBgcGFja2FnZXMvYW5pbWF0aW9ucy9icm93c2VyL19faW5kZXguZC50c2BcbiAgICAvLyB3aWxsIGVuZCB1cCBiZWluZyB3cml0dGVuIHRvIGA8cGtnLW91dD4vYnJvd3Nlci9pbmRleC5kLnRzYC4gTm90ZSB0aGF0IHR5cGVzIGFyZSBidW5kbGVkXG4gICAgLy8gYXMgYSBzZXBhcmF0ZSBhY3Rpb24gaW4gdGhlIGBuZ19wYWNrYWdlYCBTdGFybGFyayBydWxlIGFuZCBwcmVmaXhlZCB3aXRoIGBfX2AgdG8gYXZvaWRcbiAgICAvLyBjb25mbGljdHMgd2l0aCBzb3VyY2UgYGluZGV4LmQudHNgIGZpbGVzLiBXZSByZW1vdmUgdGhpcyBwcmVmaXggaGVyZS5cbiAgICByZXR1cm4gZ2V0T3duaW5nUGFja2FnZVJlbGF0aXZlUGF0aChmaWxlKS5yZXBsYWNlKC9fX2luZGV4XFwuZFxcLnRzJC8sICdpbmRleC5kLnRzJyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgZW50cnktcG9pbnQgc3ViLXBhdGggZnJvbSB0aGUgcGFja2FnZSByb290LiBlLmcuIGlmIHRoZSBwYWNrYWdlIG5hbWVcbiAgICogaXMgYEBhbmd1bGFyL2Nka2AsIHRoZW4gZm9yIGBAYW5ndWxhci9jZGsvYTExeWAganVzdCBgYTExeWAgd291bGQgYmUgcmV0dXJuZWQuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRFbnRyeVBvaW50U3VicGF0aChtb2R1bGVOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBtb2R1bGVOYW1lLnNsaWNlKGAke21ldGFkYXRhLm5wbVBhY2thZ2VOYW1lfS9gLmxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB3aGV0aGVyIHRoZSBnaXZlbiBtb2R1bGUgbmFtZSByZXNvbHZlcyB0byBhIHNlY29uZGFyeSBlbnRyeS1wb2ludC5cbiAgICogZS5nLiBpZiB0aGUgcGFja2FnZSBuYW1lIGlzIGBAYW5ndWxhci9jZGtgLCB0aGVuIGZvciBgQGFuZ3VsYXIvY2RrL2ExMXlgXG4gICAqIHRoaXMgd291bGQgcmV0dXJuIGB0cnVlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGlzU2Vjb25kYXJ5RW50cnlQb2ludChtb2R1bGVOYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZ2V0RW50cnlQb2ludFN1YnBhdGgobW9kdWxlTmFtZSkgIT09ICcnO1xuICB9XG5cbiAgZXNtMjAyMC5mb3JFYWNoKGZpbGUgPT4gd3JpdGVFc20yMDIwRmlsZShmaWxlKSk7XG5cbiAgLy8gQ29weSBhbGwgRkVTTSBmaWxlcyBpbnRvIHRoZSBwYWNrYWdlIG91dHB1dC5cbiAgZmVzbTIwMjAuZm9yRWFjaChmID0+IGNvcHlGaWxlKGYucGF0aCwgZ2V0RmxhdEVzbU91dHB1dFJlbGF0aXZlUGF0aChmKSkpO1xuICBmZXNtMjAxNS5mb3JFYWNoKGYgPT4gY29weUZpbGUoZi5wYXRoLCBnZXRGbGF0RXNtT3V0cHV0UmVsYXRpdmVQYXRoKGYpKSk7XG5cbiAgLy8gQ29weSBhbGwgdHlwZSBkZWZpbml0aW9ucyBpbnRvIHRoZSBwYWNrYWdlLCBwcmVzZXJ2aW5nIHRoZSBzdWItcGF0aCBmcm9tIHRoZVxuICAvLyBvd25pbmcgcGFja2FnZS4gZS5nLiBhIGZpbGUgbGlrZSBgcGFja2FnZXMvYW5pbWF0aW9ucy9icm93c2VyL19faW5kZXguZC50c2Agd2lsbFxuICAvLyBlbmQgdXAgaW4gYGJyb3dzZXIvaW5kZXguZC50c2BcbiAgdHlwZURlZmluaXRpb25zLmZvckVhY2goZiA9PiBjb3B5RmlsZShmLnBhdGgsIGdldFR5cGluZ091dHB1dFJlbGF0aXZlUGF0aChmKSkpO1xuXG4gIGZvciAoY29uc3QgZmlsZSBvZiBzdGF0aWNGaWxlcykge1xuICAgIC8vIFdlIGNvcHkgYWxsIGZpbGVzIGludG8gdGhlIHBhY2thZ2Ugb3V0cHV0IHdoaWxlIHByZXNlcnZpbmcgdGhlIHN1Yi1wYXRoIGZyb21cbiAgICAvLyB0aGUgb3duaW5nIHBhY2thZ2UuIGUuZy4gYHBhY2thZ2VzL2NvcmUvcGFja2FnZS5qc29uYCBlbmRzIHVwIGA8cGtnLW91dD4vcGFja2FnZS5qc29uYC5cbiAgICBjb25zdCBvdXRwdXRSZWxhdGl2ZVBhdGggPSBnZXRPd25pbmdQYWNrYWdlUmVsYXRpdmVQYXRoKGZpbGUpO1xuICAgIGxldCBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKGZpbGUucGF0aCwgJ3V0ZjgnKTtcblxuICAgIC8vIENoZWNrIGFuZCBtb2RpZnkgcGFja2FnZS5qc29uIGZpbGVzIGFzIG5lY2Vzc2FyeSBmb3IgcHVibGlzaGluZ1xuICAgIGlmIChwYXRoLmJhc2VuYW1lKGZpbGUucGF0aCkgPT09ICdwYWNrYWdlLmpzb24nKSB7XG4gICAgICBjb25zdCBpc1ByaW1hcnlQYWNrYWdlSnNvbiA9IG91dHB1dFJlbGF0aXZlUGF0aCA9PT0gJ3BhY2thZ2UuanNvbic7XG4gICAgICBjb25zdCBwYWNrYWdlSnNvbiA9IEpTT04ucGFyc2UoY29udGVudCkgYXMgUGFja2FnZUpzb247XG4gICAgICBjb25zdCBwYWNrYWdlTmFtZSA9IHBhY2thZ2VKc29uWyduYW1lJ107XG5cbiAgICAgIC8vIFByZXZlbnQgbm9uLXByaW1hcnkgYHBhY2thZ2UuanNvbmAgZmlsZXMgd2hpY2ggd291bGQgdGhyb3ctb2ZmIHJlc29sdXRpb24uXG4gICAgICAvLyBSZXNvbHV0aW9uIGluIHRoZSBwYWNrYWdlIHNob3VsZCBvbmx5IGJlIGJhc2VkIG9uIHRoZSB0b3AtbGV2ZWwgYHBhY2thZ2UuanNvbmAuXG4gICAgICBpZiAoIWlzUHJpbWFyeVBhY2thZ2VKc29uKSB7XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgYEZvdW5kIGEgbmVzdGVkIFwicGFja2FnZS5qc29uXCIgZmlsZSBpbiB0aGUgcGFja2FnZSBvdXRwdXQ6ICR7ZmlsZS5zaG9ydFBhdGh9LlxcbmAgK1xuICAgICAgICAgICAgYEFsbCBpbmZvcm1hdGlvbiBvZiB0aGUgcGFja2FnZSBzaG91bGQgcmVzaWRlIGluIHRoZSBwcmltYXJ5IHBhY2thZ2UgZmlsZS5gKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGBuYW1lYCBmaWVsZCBvZiB0aGUgYHBhY2thZ2UuanNvbmAgZmlsZXMgYXJlIG1hdGNoaW5nIHdpdGhcbiAgICAgIC8vIG5hbWUgb2YgdGhlIE5QTSBwYWNrYWdlLiBUaGlzIGlzIGFuIGFkZGl0aW9uYWwgc2FmZXR5IGNoZWNrLlxuICAgICAgaWYgKHBhY2thZ2VOYW1lICE9PSBtZXRhZGF0YS5ucG1QYWNrYWdlTmFtZSkge1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIGBQcmltYXJ5IFwicGFja2FnZS5qc29uXCIgaGFzIG1pc21hdGNoaW5nIHBhY2thZ2UgbmFtZS4gRXhwZWN0ZWQgdGhlIGAgK1xuICAgICAgICAgICAgYHBhY2thZ2UgdG8gYmUgbmFtZWQgXCIke21ldGFkYXRhLm5wbVBhY2thZ2VOYW1lfVwiLCBidXQgaXMgc2V0IHRvOiAke3BhY2thZ2VOYW1lfS5gKTtcbiAgICAgIH1cblxuICAgICAgbGV0IG5ld1BhY2thZ2VKc29uID1cbiAgICAgICAgICBpbnNlcnRGb3JtYXRGaWVsZHNJbnRvUGFja2FnZUpzb24ob3V0cHV0UmVsYXRpdmVQYXRoLCBwYWNrYWdlSnNvbiwgZmFsc2UpO1xuXG4gICAgICBuZXdQYWNrYWdlSnNvbiA9IHVwZGF0ZVByaW1hcnlQYWNrYWdlSnNvbihuZXdQYWNrYWdlSnNvbik7XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgY29udGVudCB3aXRoIHRoZSBuZXcgYHBhY2thZ2UuanNvbmAgZmlsZSBjb250ZW50LlxuICAgICAgY29udGVudCA9IEpTT04uc3RyaW5naWZ5KG5ld1BhY2thZ2VKc29uLCBudWxsLCAyKTtcbiAgICB9XG5cbiAgICB3cml0ZUZpbGUob3V0cHV0UmVsYXRpdmVQYXRoLCBjb250ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIG9yIGVkaXRzIHByb3BlcnRpZXMgaW50byB0aGUgcGFja2FnZS5qc29uIGZpbGUocykgaW4gdGhlIHBhY2thZ2Ugc28gdGhhdFxuICAgKiB0aGV5IHBvaW50IHRvIGFsbCB0aGUgcmlnaHQgZ2VuZXJhdGVkIGFydGlmYWN0cy5cbiAgICpcbiAgICogQHBhcmFtIHBhY2thZ2VKc29uT3V0UmVsYXRpdmVQYXRoIFBhdGggd2hlcmUgdGhlIGBwYWNrYWdlLmpzb25gIGlzIHN0b3JlZCBpblxuICAgKiAgIHRoZSBwYWNrYWdlIG91dHB1dC5cbiAgICogQHBhcmFtIHBhcnNlZFBhY2thZ2UgUGFyc2VkIHBhY2thZ2UuanNvbiBjb250ZW50XG4gICAqIEBwYXJhbSBpc0dlbmVyYXRlZFBhY2thZ2VKc29uIFdoZXRoZXIgdGhlIHBhc3NlZCBwYWNrYWdlLmpzb24gaGFzIGJlZW4gZ2VuZXJhdGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gaW5zZXJ0Rm9ybWF0RmllbGRzSW50b1BhY2thZ2VKc29uKFxuICAgICAgcGFja2FnZUpzb25PdXRSZWxhdGl2ZVBhdGg6IHN0cmluZywgcGFyc2VkUGFja2FnZTogUmVhZG9ubHk8UGFja2FnZUpzb24+LFxuICAgICAgaXNHZW5lcmF0ZWRQYWNrYWdlSnNvbjogYm9vbGVhbik6IFBhY2thZ2VKc29uIHtcbiAgICBjb25zdCBwYWNrYWdlSnNvbjogUGFja2FnZUpzb24gPSB7Li4ucGFyc2VkUGFja2FnZX07XG4gICAgY29uc3QgcGFja2FnZU5hbWUgPSBwYWNrYWdlSnNvblsnbmFtZSddO1xuICAgIGNvbnN0IGVudHJ5UG9pbnRJbmZvID0gbWV0YWRhdGEuZW50cnlQb2ludHNbcGFja2FnZU5hbWVdO1xuICAgIGNvbnN0IHBhY2thZ2VKc29uQ29udGFpbmluZ0RpciA9IHBhdGguZGlybmFtZShwYWNrYWdlSnNvbk91dFJlbGF0aXZlUGF0aCk7XG5cbiAgICAvLyBJZiBhIHBhY2thZ2UganNvbiBmaWxlIGhhcyBiZWVuIGRpc2NvdmVyZWQgdGhhdCBkb2VzIG5vdCBtYXRjaCBhbnlcbiAgICAvLyBlbnRyeS1wb2ludCBpbiB0aGUgbWV0YWRhdGEsIHdlIHJlcG9ydCBhIHdhcm5pbmcgYXMgbW9zdCBsaWtlbHkgdGhlIHRhcmdldFxuICAgIC8vIGlzIGNvbmZpZ3VyZWQgaW5jb3JyZWN0bHkgKGUuZy4gbWlzc2luZyBgbW9kdWxlX25hbWVgIGF0dHJpYnV0ZSkuXG4gICAgaWYgKCFlbnRyeVBvaW50SW5mbykge1xuICAgICAgLy8gSWRlYWxseSB3ZSBzaG91bGQgdGhyb3cgaGVyZSwgYXMgd2UgZ290IGFuIGVudHJ5IHBvaW50IHRoYXQgZG9lc24ndFxuICAgICAgLy8gaGF2ZSBmbGF0IG1vZHVsZSBtZXRhZGF0YSAvIGJ1bmRsZSBpbmRleCwgc28gaXQgbWF5IGhhdmUgYmVlbiBhblxuICAgICAgLy8gbmdfbW9kdWxlIHRoYXQncyBtaXNzaW5nIGEgbW9kdWxlX25hbWUgYXR0cmlidXRlLlxuICAgICAgLy8gSG93ZXZlciwgQGFuZ3VsYXIvY29tcGlsZXIgY2FuJ3QgYmUgYW4gbmdfbW9kdWxlLCBhcyBpdCdzIHRoZSBpbnRlcm5hbHNcbiAgICAgIC8vIG9mIHRoZSBuZ2MgY29tcGlsZXIsIHlldCB3ZSB3YW50IHRvIGJ1aWxkIGFuIG5nX3BhY2thZ2UgZm9yIGl0LlxuICAgICAgLy8gU28gaWdub3JlIHBhY2thZ2UuanNvbiBmaWxlcyB3aGVuIHdlIGFyZSBtaXNzaW5nIGRhdGEuXG4gICAgICBjb25zb2xlLmVycm9yKCdXQVJOSU5HOiBubyBtb2R1bGUgbWV0YWRhdGEgZm9yIHBhY2thZ2UnLCBwYWNrYWdlTmFtZSk7XG4gICAgICBjb25zb2xlLmVycm9yKCcgICBOb3QgdXBkYXRpbmcgdGhlIHBhY2thZ2UuanNvbiBmaWxlIHRvIHBvaW50IHRvIGl0Jyk7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICcgICBUaGUgbmdfbW9kdWxlIGZvciB0aGlzIHBhY2thZ2UgaXMgcG9zc2libHkgbWlzc2luZyB0aGUgbW9kdWxlX25hbWUgYXR0cmlidXRlICcpO1xuICAgICAgcmV0dXJuIHBhY2thZ2VKc29uO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGd1ZXNzZWQgdGhlIGluZGV4IHBhdGhzIGZvciBhIG1vZHVsZSwgYW5kIGl0IGNvbnRhaW5zIGFuIGV4cGxpY2l0IGBwYWNrYWdlLmpzb25gXG4gICAgLy8gZmlsZSB0aGF0IGFscmVhZHkgc2V0cyBmb3JtYXQgcHJvcGVydGllcywgd2Ugc2tpcCBhdXRvbWF0aWMgaW5zZXJ0aW9uIG9mIGZvcm1hdFxuICAgIC8vIHByb3BlcnRpZXMgYnV0IHJlcG9ydCBhIHdhcm5pbmcgaW4gY2FzZSBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBzZXQgYnkgYWNjaWRlbnQuXG4gICAgaWYgKGVudHJ5UG9pbnRJbmZvLmd1ZXNzZWRQYXRocyAmJiAhaXNHZW5lcmF0ZWRQYWNrYWdlSnNvbiAmJlxuICAgICAgICBoYXNFeHBsaWNpdEZvcm1hdFByb3BlcnRpZXMocGFja2FnZUpzb24pKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdXQVJOSU5HOiBgcGFja2FnZS5qc29uYCBleHBsaWNpdGx5IHNldHMgZm9ybWF0IHByb3BlcnRpZXMgKGxpa2UgYG1haW5gKS4nKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgJyAgICBTa2lwcGluZyBhdXRvbWF0aWMgaW5zZXJ0aW9uIG9mIGZvcm1hdCBwcm9wZXJ0aWVzIGFzIGV4cGxpY2l0ICcgK1xuICAgICAgICAgICdmb3JtYXQgcHJvcGVydGllcyBhcmUgc2V0LicpO1xuICAgICAgY29uc29sZS5lcnJvcignICAgIElnbm9yZSB0aGlzIHdhcm5pbmcgaWYgZXhwbGljaXQgcHJvcGVydGllcyBhcmUgc2V0IGludGVudGlvbmFsbHkuJyk7XG4gICAgICByZXR1cm4gcGFja2FnZUpzb247XG4gICAgfVxuXG4gICAgY29uc3QgZmVzbTIwMjBSZWxhdGl2ZU91dFBhdGggPSBnZXRGbGF0RXNtT3V0cHV0UmVsYXRpdmVQYXRoKGVudHJ5UG9pbnRJbmZvLmZlc20yMDIwQnVuZGxlKTtcbiAgICBjb25zdCBmZXNtMjAxNVJlbGF0aXZlT3V0UGF0aCA9IGdldEZsYXRFc21PdXRwdXRSZWxhdGl2ZVBhdGgoZW50cnlQb2ludEluZm8uZmVzbTIwMTVCdW5kbGUpO1xuICAgIGNvbnN0IGVzbTIwMjBSZWxhdGl2ZU91dFBhdGggPSBnZXRFc20yMDIwT3V0cHV0UmVsYXRpdmVQYXRoKGVudHJ5UG9pbnRJbmZvLmluZGV4KTtcbiAgICBjb25zdCB0eXBpbmdzUmVsYXRpdmVPdXRQYXRoID0gZ2V0VHlwaW5nT3V0cHV0UmVsYXRpdmVQYXRoKGVudHJ5UG9pbnRJbmZvLnR5cGluZ3MpO1xuXG4gICAgcGFja2FnZUpzb24uZmVzbTIwMjAgPVxuICAgICAgICBub3JtYWxpemVQYXRoKHBhdGgucmVsYXRpdmUocGFja2FnZUpzb25Db250YWluaW5nRGlyLCBmZXNtMjAyMFJlbGF0aXZlT3V0UGF0aCkpO1xuICAgIHBhY2thZ2VKc29uLmZlc20yMDE1ID1cbiAgICAgICAgbm9ybWFsaXplUGF0aChwYXRoLnJlbGF0aXZlKHBhY2thZ2VKc29uQ29udGFpbmluZ0RpciwgZmVzbTIwMTVSZWxhdGl2ZU91dFBhdGgpKTtcbiAgICBwYWNrYWdlSnNvbi5lc20yMDIwID1cbiAgICAgICAgbm9ybWFsaXplUGF0aChwYXRoLnJlbGF0aXZlKHBhY2thZ2VKc29uQ29udGFpbmluZ0RpciwgZXNtMjAyMFJlbGF0aXZlT3V0UGF0aCkpO1xuICAgIHBhY2thZ2VKc29uLnR5cGluZ3MgPVxuICAgICAgICBub3JtYWxpemVQYXRoKHBhdGgucmVsYXRpdmUocGFja2FnZUpzb25Db250YWluaW5nRGlyLCB0eXBpbmdzUmVsYXRpdmVPdXRQYXRoKSk7XG5cbiAgICAvLyBGb3Igbm93LCB3ZSBwb2ludCB0aGUgcHJpbWFyeSBlbnRyeSBwb2ludHMgYXQgdGhlIGZlc20gZmlsZXMsIGJlY2F1c2Ugb2YgV2VicGFja1xuICAgIC8vIHBlcmZvcm1hbmNlIGlzc3VlcyB3aXRoIGEgbGFyZ2UgbnVtYmVyIG9mIGluZGl2aWR1YWwgZmlsZXMuXG4gICAgcGFja2FnZUpzb24ubW9kdWxlID0gcGFja2FnZUpzb24uZmVzbTIwMTU7XG4gICAgcGFja2FnZUpzb24uZXMyMDIwID0gcGFja2FnZUpzb24uZmVzbTIwMjA7XG5cbiAgICByZXR1cm4gcGFja2FnZUpzb247XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcHJpbWFyeSBgcGFja2FnZS5qc29uYCBmaWxlIG9mIHRoZSBOUE0gcGFja2FnZSB0byBzcGVjaWZ5XG4gICAqIHRoZSBtb2R1bGUgY29uZGl0aW9uYWwgZXhwb3J0cyBhbmQgdGhlIEVTTSBtb2R1bGUgdHlwZS5cbiAgICovXG4gIGZ1bmN0aW9uIHVwZGF0ZVByaW1hcnlQYWNrYWdlSnNvbihwYWNrYWdlSnNvbjogUmVhZG9ubHk8UGFja2FnZUpzb24+KTogUGFja2FnZUpzb24ge1xuICAgIGlmIChwYWNrYWdlSnNvbi50eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICdUaGUgcHJpbWFyeSBcInBhY2thZ2UuanNvblwiIGZpbGUgb2YgdGhlIHBhY2thZ2Ugc2V0cyB0aGUgXCJ0eXBlXCIgZmllbGQgJyArXG4gICAgICAgICAgJ3RoYXQgaXMgY29udHJvbGxlZCBieSB0aGUgcGFja2FnZXIuIFBsZWFzZSB1bnNldCBpdC4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdQYWNrYWdlSnNvbjogUGFja2FnZUpzb24gPSB7Li4ucGFja2FnZUpzb259O1xuXG4gICAgbmV3UGFja2FnZUpzb24udHlwZSA9ICdtb2R1bGUnO1xuXG4gICAgLy8gVGhlIGBwYWNrYWdlLmpzb25gIGZpbGUgaXMgbWFkZSBwdWJsaWNseSBhY2Nlc3NpYmxlIGZvciB0b29scyB0aGF0XG4gICAgLy8gbWlnaHQgd2FudCB0byBxdWVyeSBpbmZvcm1hdGlvbiBmcm9tIHRoZSBBbmd1bGFyIE5QTSBwYWNrYWdlLlxuICAgIGluc2VydEV4cG9ydE1hcHBpbmdPckVycm9yKG5ld1BhY2thZ2VKc29uLCAnLi9wYWNrYWdlLmpzb24nLCB7ZGVmYXVsdDogJy4vcGFja2FnZS5qc29uJ30pO1xuXG4gICAgLy8gQ2FwdHVyZSBhbGwgZW50cnktcG9pbnRzIGluIHRoZSBgZXhwb3J0c2AgZmllbGQgdXNpbmcgdGhlIHN1YnBhdGggZXhwb3J0IGRlY2xhcmF0aW9uczpcbiAgICAvLyBodHRwczovL25vZGVqcy5vcmcvYXBpL3BhY2thZ2VzLmh0bWwjcGFja2FnZXNfc3VicGF0aF9leHBvcnRzLlxuICAgIGZvciAoY29uc3QgW21vZHVsZU5hbWUsIGVudHJ5UG9pbnRdIG9mIE9iamVjdC5lbnRyaWVzKG1ldGFkYXRhLmVudHJ5UG9pbnRzKSkge1xuICAgICAgY29uc3Qgc3VicGF0aCA9XG4gICAgICAgICAgaXNTZWNvbmRhcnlFbnRyeVBvaW50KG1vZHVsZU5hbWUpID8gYC4vJHtnZXRFbnRyeVBvaW50U3VicGF0aChtb2R1bGVOYW1lKX1gIDogJy4nO1xuICAgICAgY29uc3QgZXNtMjAyMEluZGV4T3V0UmVsYXRpdmVQYXRoID0gZ2V0RXNtMjAyME91dHB1dFJlbGF0aXZlUGF0aChlbnRyeVBvaW50LmluZGV4KTtcbiAgICAgIGNvbnN0IGZlc20yMDIwT3V0UmVsYXRpdmVQYXRoID0gZ2V0RmxhdEVzbU91dHB1dFJlbGF0aXZlUGF0aChlbnRyeVBvaW50LmZlc20yMDIwQnVuZGxlKTtcbiAgICAgIGNvbnN0IGZlc20yMDE1T3V0UmVsYXRpdmVQYXRoID0gZ2V0RmxhdEVzbU91dHB1dFJlbGF0aXZlUGF0aChlbnRyeVBvaW50LmZlc20yMDE1QnVuZGxlKTtcbiAgICAgIGNvbnN0IHR5cGVzT3V0UmVsYXRpdmVQYXRoID0gZ2V0VHlwaW5nT3V0cHV0UmVsYXRpdmVQYXRoKGVudHJ5UG9pbnQudHlwaW5ncyk7XG5cbiAgICAgIC8vIEluc2VydCB0aGUgZXhwb3J0IG1hcHBpbmcgZm9yIHRoZSBlbnRyeS1wb2ludC4gV2Ugc2V0IGBkZWZhdWx0YCB0byB0aGUgRkVTTSAyMDIwXG4gICAgICAvLyBvdXRwdXQsIGFuZCBhbHNvIHNldCB0aGUgYHR5cGVzYCBjb25kaXRpb24gd2hpY2ggd2lsbCBiZSByZXNwZWN0ZWQgYnkgVFMgNC41LlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L3B1bGwvNDU4ODQuXG4gICAgICBpbnNlcnRFeHBvcnRNYXBwaW5nT3JFcnJvcihuZXdQYWNrYWdlSnNvbiwgc3VicGF0aCwge1xuICAgICAgICB0eXBlczogbm9ybWFsaXplUGF0aCh0eXBlc091dFJlbGF0aXZlUGF0aCksXG4gICAgICAgIGVzbTIwMjA6IG5vcm1hbGl6ZVBhdGgoZXNtMjAyMEluZGV4T3V0UmVsYXRpdmVQYXRoKSxcbiAgICAgICAgZXMyMDIwOiBub3JtYWxpemVQYXRoKGZlc20yMDIwT3V0UmVsYXRpdmVQYXRoKSxcbiAgICAgICAgLy8gV2UgYWxzbyBleHBvc2UgYSBub24tc3RhbmRhcmQgY29uZGl0aW9uIHRoYXQgd291bGQgYWxsb3cgY29uc3VtZXJzIHRvIHJlc29sdmVcbiAgICAgICAgLy8gdG8gdGhlIGBFUzIwMTVgIG91dHB1dCBvdXRzaWRlIG9mIE5vZGVKUywgaWYgZGVzaXJlZC5cbiAgICAgICAgLy8gVE9ETyhkZXZ2ZXJzaW9uKTogcmVtb3ZlL3JlcGxhY2UgdGhpcyBpZiBOb2RlSlMgdjEyIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuXG4gICAgICAgIGVzMjAxNTogbm9ybWFsaXplUGF0aChmZXNtMjAxNU91dFJlbGF0aXZlUGF0aCksXG4gICAgICAgIC8vIFdlIGRlY2xhcmUgdGhlIGBub2RlYCBjb25kaXRpb24gYW5kIHBvaW50IHRvIHRoZSBFUzIwMTUgb3V0cHV0IGFzIHdlIGN1cnJlbnRseSBzdGlsbFxuICAgICAgICAvLyBzdXBwb3J0IE5vZGVKUyB2MTIgd2hpY2ggZG9lcyBub3QgZnVsbHkgc3VwcG9ydCBFUzIwMjAgb3V0cHV0LiBXZSBjaG9zZSBFUzIwMTUgb3ZlclxuICAgICAgICAvLyBFUzIwMjAgYmVjYXVzZSB3ZSB3YW4gYXN5bmMvYXdhaXQgZG93bmxldmVsZWQgYXMgdGhpcyBhbGxvd3MgZm9yIHBhdGNoaW5nIHdpdGhab25lSlMuXG4gICAgICAgIC8vIFRPRE8oZGV2dmVyc2lvbik6IHJlbW92ZS9yZXBsYWNlIHRoaXMgaWYgTm9kZUpTIHYxMiBpcyBubyBsb25nZXIgc3VwcG9ydGVkLlxuICAgICAgICBub2RlOiBub3JtYWxpemVQYXRoKGZlc20yMDE1T3V0UmVsYXRpdmVQYXRoKSxcbiAgICAgICAgLy8gTm90ZTogVGhlIGRlZmF1bHQgY29uZGl0aW9ucyBuZWVkcyB0byBiZSB0aGUgbGFzdCBvbmUuXG4gICAgICAgIGRlZmF1bHQ6IG5vcm1hbGl6ZVBhdGgoZmVzbTIwMjBPdXRSZWxhdGl2ZVBhdGgpLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1BhY2thZ2VKc29uO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgYSBzdWJwYXRoIGV4cG9ydCBtYXBwaW5nIGludG8gdGhlIHNwZWNpZmllZCBgcGFja2FnZS5qc29uYCBvYmplY3QuXG4gICAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIG1hcHBpbmcgaXMgYWxyZWFkeSBkZWZpbmVkIGFuZCB3b3VsZCBjb25mbGljdC5cbiAgICovXG4gIGZ1bmN0aW9uIGluc2VydEV4cG9ydE1hcHBpbmdPckVycm9yKFxuICAgICAgcGFja2FnZUpzb246IFBhY2thZ2VKc29uLCBzdWJwYXRoOiBzdHJpbmcsIG1hcHBpbmc6IENvbmRpdGlvbmFsRXhwb3J0KSB7XG4gICAgaWYgKHBhY2thZ2VKc29uLmV4cG9ydHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcGFja2FnZUpzb24uZXhwb3J0cyA9IHt9O1xuICAgIH1cbiAgICBpZiAocGFja2FnZUpzb24uZXhwb3J0c1tzdWJwYXRoXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYWNrYWdlSnNvbi5leHBvcnRzW3N1YnBhdGhdID0ge307XG4gICAgfVxuXG4gICAgY29uc3Qgc3VicGF0aEV4cG9ydCA9IHBhY2thZ2VKc29uLmV4cG9ydHNbc3VicGF0aF07XG5cbiAgICAvLyBHbyB0aHJvdWdoIGFsbCBjb25kaXRpb25zIHRoYXQgc2hvdWxkIGJlIGluc2VydGVkLiBJZiB0aGUgY29uZGl0aW9uIGlzIGFscmVhZHlcbiAgICAvLyBtYW51YWxseSBzZXQgb2YgdGhlIHN1YnBhdGggZXhwb3J0LCB3ZSB0aHJvdyBhbiBlcnJvci4gSW4gZ2VuZXJhbCwgd2UgYWxsb3cgZm9yXG4gICAgLy8gYWRkaXRpb25hbCBjb25kaXRpb25zIHRvIGJlIHNldC4gVGhlc2Ugd2lsbCBhbHdheXMgcHJlY2VkZSB0aGUgZ2VuZXJhdGVkIG9uZXMuXG4gICAgZm9yIChjb25zdCBjb25kaXRpb25OYW1lIG9mIE9iamVjdC5rZXlzKG1hcHBpbmcpIGFzIFtrZXlvZiBDb25kaXRpb25hbEV4cG9ydF0pIHtcbiAgICAgIGlmIChzdWJwYXRoRXhwb3J0W2NvbmRpdGlvbk5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBgRm91bmQgYSBjb25mbGljdGluZyBleHBvcnQgY29uZGl0aW9uIGZvciBcIiR7c3VicGF0aH1cIi4gVGhlIFwiJHtjb25kaXRpb25OYW1lfVwiIGAgK1xuICAgICAgICAgICAgYGNvbmRpdGlvbiB3b3VsZCBiZSBvdmVycmlkZGVuIGJ5IHRoZSBwYWNrYWdlci4gUGxlYXNlIHVuc2V0IGl0LmApO1xuICAgICAgfVxuXG4gICAgICAvLyAqKk5vdGUqKjogVGhlIG9yZGVyIG9mIHRoZSBjb25kaXRpb25zIGlzIHByZXNlcnZlZCBldmVuIHRob3VnaCB3ZSBhcmUgc2V0dGluZ1xuICAgICAgLy8gdGhlIGNvbmRpdGlvbnMgb25jZSBhdCBhIHRpbWUgKHRoZSBsYXRlc3QgYXNzaWdubWVudCB3aWxsIGJlIGF0IHRoZSBlbmQpLlxuICAgICAgc3VicGF0aEV4cG9ydFtjb25kaXRpb25OYW1lXSA9IG1hcHBpbmdbY29uZGl0aW9uTmFtZV07XG4gICAgfVxuICB9XG5cbiAgLyoqIFdoZXRoZXIgdGhlIHBhY2thZ2UgZXhwbGljaXRseSBzZXRzIGFueSBvZiB0aGUgZm9ybWF0IHByb3BlcnRpZXMgKGxpa2UgYG1haW5gKS4gKi9cbiAgZnVuY3Rpb24gaGFzRXhwbGljaXRGb3JtYXRQcm9wZXJ0aWVzKHBhcnNlZFBhY2thZ2U6IFJlYWRvbmx5PFBhY2thZ2VKc29uPik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhwYXJzZWRQYWNrYWdlKVxuICAgICAgICAuc29tZShcbiAgICAgICAgICAgIChmaWVsZE5hbWU6IEtub3duUGFja2FnZUpzb25Gb3JtYXRGaWVsZHMpID0+XG4gICAgICAgICAgICAgICAga25vd25Gb3JtYXRQYWNrYWdlSnNvbkZvcm1hdEZpZWxkcy5pbmNsdWRlcyhmaWVsZE5hbWUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemVzIHRoZSBzcGVjaWZpZWQgcGF0aCBieSByZXBsYWNpbmcgYmFja3NsYXNoIHNlcGFyYXRvcnMgd2l0aCBQb3NpeFxuICAgKiBmb3J3YXJkIHNsYXNoIHNlcGFyYXRvcnMuXG4gICAqL1xuICBmdW5jdGlvbiBub3JtYWxpemVQYXRoKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgcmVzdWx0ID0gcGF0aC5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG4gICAgcmV0dXJuIHJlc3VsdC5zdGFydHNXaXRoKCcuJykgPyByZXN1bHQgOiBgLi8ke3Jlc3VsdH1gO1xuICB9XG59XG4iXX0=