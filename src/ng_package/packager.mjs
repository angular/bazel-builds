/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
import * as fs from 'fs';
import * as path from 'path';
import { analyzeFileAndEnsureNoCrossImports } from './cross_entry_points_imports';
/**
 * List of known `package.json` fields which provide information about
 * supported package formats and their associated entry paths.
 */
const knownFormatPackageJsonFormatFields = ['main', 'esm2022', 'esm', 'typings', 'module'];
// Main entry-point.
main(process.argv.slice(2));
function main(args) {
    // This utility expects all of its arguments to be specified in a params file generated by
    // bazel (see https://docs.bazel.build/versions/master/skylark/lib/Args.html#use_param_file).
    const paramFilePath = args[0];
    // Bazel params may be surrounded with quotes
    function unquoteParameter(s) {
        return s.replace(/^'(.*)'$/, '$1');
    }
    // Parameters are specified in the file one per line.
    const params = fs.readFileSync(paramFilePath, 'utf-8').split('\n').map(unquoteParameter);
    const [
    // Output directory for the npm package.
    outputDirExecPath, 
    // The package segment of the ng_package rule's label (e.g. 'package/common').
    owningPackageName, 
    // JSON data capturing metadata of the package being built. See `PackageMetadata`.
    metadataArg, 
    // Path to the package's README.md.
    readmeMd, 
    // Path to the package's LICENSE file.
    licenseFile, 
    // List of rolled-up flat ES2022 modules
    fesm2022Arg, 
    // List of individual ES2022 modules
    esm2022Arg, 
    // List of static files that should be copied into the package.
    staticFilesArg, 
    // List of all type definitions that need to packaged into the ng_package.
    typeDefinitionsArg,] = params;
    const fesm2022 = JSON.parse(fesm2022Arg);
    const esm2022 = JSON.parse(esm2022Arg);
    const typeDefinitions = JSON.parse(typeDefinitionsArg);
    const staticFiles = JSON.parse(staticFilesArg);
    const metadata = JSON.parse(metadataArg);
    if (readmeMd) {
        copyFile(readmeMd, 'README.md');
    }
    if (licenseFile) {
        copyFile(licenseFile, 'LICENSE');
    }
    /**
     * Writes a file with the specified content into the package output.
     * @param outputRelativePath Relative path in the output directory where the
     *   file is written to.
     * @param fileContent Content of the file.
     */
    function writeFile(outputRelativePath, fileContent) {
        const outputPath = path.join(outputDirExecPath, outputRelativePath);
        // Always ensure that the target directory exists.
        fs.mkdirSync(path.dirname(outputPath), { recursive: true });
        fs.writeFileSync(outputPath, fileContent);
    }
    /**
     * Copies a file into the package output to the specified location.
     * @param inputPath File that should be copied.
     * @param outputRelativePath Relative path in the output directory where the
     *   file is written to.
     */
    function copyFile(inputPath, outputRelativePath) {
        const fileContent = fs.readFileSync(inputPath, 'utf8');
        writeFile(outputRelativePath, fileContent);
    }
    /**
     * Gets the relative path for the given file within the owning package. This
     * assumes the file is contained in the owning package.
     *
     * e.g. consider the owning package is `packages/core` and the input file
     * is `packages/core/testing/index.d.ts`. This function would return the
     * relative path as followed: `testing/index.d.ts`.
     */
    function getOwningPackageRelativePath(file) {
        return path.relative(owningPackageName, file.shortPath);
    }
    /** Writes an ESM file into the `esm2022` output directory. */
    function writeEsm2022File(file) {
        // Note: files which do not belong to the owning package of this `ng_package` are omitted.
        // this prevents us from accidentally bringing in transitive node module dependencies.
        const packageRelativePath = getOwningPackageRelativePath(file);
        if (!packageRelativePath.startsWith('..')) {
            copyFile(file.path, getEsm2022OutputRelativePath(file));
        }
    }
    /** Gets the output-relative path where the given flat ESM file should be written to. */
    function getFlatEsmOutputRelativePath(file) {
        // Flat ESM files should be put into their owning package relative sub-path. e.g. if
        // there is a bundle in `packages/animations/fesm2022/browser/testing.mjs` then we
        // want the bundle to be stored in `fesm2022/browser/testing.mjs`. Same thing applies
        // for the `fesm2022` bundles. The directory name for `fesm` is already declared as
        // part of the Bazel action generating these files. See `ng_package.bzl`.
        return getOwningPackageRelativePath(file);
    }
    /** Gets the output-relative path where a non-flat ESM2022 file should be written to. */
    function getEsm2022OutputRelativePath(file) {
        // Path computed relative to the current package in bazel-bin. e.g. a ES2022 output file
        // in `bazel-out/<..>/packages/core/src/di.mjs` should be stored in `esm2022/src/di.mjs`.
        return path.join('esm2022', getOwningPackageRelativePath(file));
    }
    /** Gets the output-relative path where the typing file is being written to. */
    function getTypingOutputRelativePath(file) {
        // Type definitions are intended to be copied into the package output while preserving the
        // sub-path from the owning package. e.g. a file like `packages/animations/browser/__index.d.ts`
        // will end up being written to `<pkg-out>/browser/index.d.ts`. Note that types are bundled
        // as a separate action in the `ng_package` Starlark rule and prefixed with `__` to avoid
        // conflicts with source `index.d.ts` files. We remove this prefix here.
        return getOwningPackageRelativePath(file).replace(/__index\.d\.ts$/, 'index.d.ts');
    }
    /**
     * Gets the entry-point sub-path from the package root. e.g. if the package name
     * is `@angular/cdk`, then for `@angular/cdk/a11y` just `a11y` would be returned.
     */
    function getEntryPointSubpath(moduleName) {
        return moduleName.slice(`${metadata.npmPackageName}/`.length);
    }
    /**
     * Gets whether the given module name resolves to a secondary entry-point.
     * e.g. if the package name is `@angular/cdk`, then for `@angular/cdk/a11y`
     * this would return `true`.
     */
    function isSecondaryEntryPoint(moduleName) {
        return getEntryPointSubpath(moduleName) !== '';
    }
    const crossEntryPointFailures = [];
    esm2022.forEach((file) => {
        crossEntryPointFailures.push(...analyzeFileAndEnsureNoCrossImports(file, metadata));
        writeEsm2022File(file);
    });
    if (crossEntryPointFailures.length) {
        console.error(crossEntryPointFailures);
        process.exit(1);
    }
    // Copy all FESM files into the package output.
    fesm2022.forEach((f) => copyFile(f.path, getFlatEsmOutputRelativePath(f)));
    // Copy all type definitions into the package, preserving the sub-path from the
    // owning package. e.g. a file like `packages/animations/browser/__index.d.ts` will
    // end up in `browser/index.d.ts`
    typeDefinitions.forEach((f) => copyFile(f.path, getTypingOutputRelativePath(f)));
    for (const file of staticFiles) {
        // We copy all files into the package output while preserving the sub-path from
        // the owning package. e.g. `packages/core/package.json` ends up `<pkg-out>/package.json`.
        const outputRelativePath = getOwningPackageRelativePath(file);
        let content = fs.readFileSync(file.path, 'utf8');
        // Check and modify package.json files as necessary for publishing
        if (path.basename(file.path) === 'package.json') {
            const isPrimaryPackageJson = outputRelativePath === 'package.json';
            const packageJson = JSON.parse(content);
            const packageName = packageJson['name'];
            // Prevent non-primary `package.json` files which would throw-off resolution.
            // Resolution in the package should only be based on the top-level `package.json`.
            if (!isPrimaryPackageJson) {
                throw Error(`Found a nested "package.json" file in the package output: ${file.shortPath}.\n` +
                    `All information of the package should reside in the primary package file.`);
            }
            // Check if the `name` field of the `package.json` files are matching with
            // name of the NPM package. This is an additional safety check.
            if (packageName !== metadata.npmPackageName) {
                throw Error(`Primary "package.json" has mismatching package name. Expected the ` +
                    `package to be named "${metadata.npmPackageName}", but is set to: ${packageName}.`);
            }
            let newPackageJson = insertFormatFieldsIntoPackageJson(outputRelativePath, packageJson, false);
            newPackageJson = updatePrimaryPackageJson(newPackageJson);
            // Update the content with the new `package.json` file content.
            content = JSON.stringify(newPackageJson, null, 2);
        }
        writeFile(outputRelativePath, content);
    }
    /**
     * Inserts or edits properties into the package.json file(s) in the package so that
     * they point to all the right generated artifacts.
     *
     * @param packageJsonOutRelativePath Path where the `package.json` is stored in
     *   the package output.
     * @param parsedPackage Parsed package.json content
     * @param isGeneratedPackageJson Whether the passed package.json has been generated.
     */
    function insertFormatFieldsIntoPackageJson(packageJsonOutRelativePath, parsedPackage, isGeneratedPackageJson) {
        const packageJson = { ...parsedPackage };
        const packageName = packageJson['name'];
        const entryPointInfo = metadata.entryPoints[packageName];
        const packageJsonContainingDir = path.dirname(packageJsonOutRelativePath);
        // If a package json file has been discovered that does not match any
        // entry-point in the metadata, we report a warning as most likely the target
        // is configured incorrectly (e.g. missing `module_name` attribute).
        if (!entryPointInfo) {
            // Ideally we should throw here, as we got an entry point that doesn't
            // have flat module metadata / bundle index, so it may have been an
            // ng_module that's missing a module_name attribute.
            // However, @angular/compiler can't be an ng_module, as it's the internals
            // of the ngc compiler, yet we want to build an ng_package for it.
            // So ignore package.json files when we are missing data.
            console.error('WARNING: no module metadata for package', packageName);
            console.error('   Not updating the package.json file to point to it');
            console.error('   The ng_module for this package is possibly missing the module_name attribute ');
            return packageJson;
        }
        // If we guessed the index paths for a module, and it contains an explicit `package.json`
        // file that already sets format properties, we skip automatic insertion of format
        // properties but report a warning in case properties have been set by accident.
        if (entryPointInfo.guessedPaths &&
            !isGeneratedPackageJson &&
            hasExplicitFormatProperties(packageJson)) {
            console.error('WARNING: `package.json` explicitly sets format properties (like `main`).');
            console.error('    Skipping automatic insertion of format properties as explicit ' +
                'format properties are set.');
            console.error('    Ignore this warning if explicit properties are set intentionally.');
            return packageJson;
        }
        const fesm2022RelativeOutPath = getFlatEsmOutputRelativePath(entryPointInfo.fesm2022Bundle);
        const typingsRelativeOutPath = getTypingOutputRelativePath(entryPointInfo.typings);
        packageJson.module = normalizePath(path.relative(packageJsonContainingDir, fesm2022RelativeOutPath));
        packageJson.typings = normalizePath(path.relative(packageJsonContainingDir, typingsRelativeOutPath));
        return packageJson;
    }
    /**
     * Updates the primary `package.json` file of the NPM package to specify
     * the module conditional exports and the ESM module type.
     */
    function updatePrimaryPackageJson(packageJson) {
        if (packageJson.type !== undefined) {
            throw Error('The primary "package.json" file of the package sets the "type" field ' +
                'that is controlled by the packager. Please unset it.');
        }
        const newPackageJson = { ...packageJson };
        newPackageJson.type = 'module';
        // The `package.json` file is made publicly accessible for tools that
        // might want to query information from the Angular NPM package.
        insertExportMappingOrError(newPackageJson, './package.json', { default: './package.json' });
        // Capture all entry-points in the `exports` field using the subpath export declarations:
        // https://nodejs.org/api/packages.html#packages_subpath_exports.
        for (const [moduleName, entryPoint] of Object.entries(metadata.entryPoints)) {
            const subpath = isSecondaryEntryPoint(moduleName)
                ? `./${getEntryPointSubpath(moduleName)}`
                : '.';
            const esmIndexOutRelativePath = getEsm2022OutputRelativePath(entryPoint.index);
            const fesm2022OutRelativePath = getFlatEsmOutputRelativePath(entryPoint.fesm2022Bundle);
            const typesOutRelativePath = getTypingOutputRelativePath(entryPoint.typings);
            // Insert the export mapping for the entry-point. We set `default` to the FESM 2022
            // output, and also set the `types` condition which will be respected by TS 4.5.
            // https://github.com/microsoft/TypeScript/pull/45884.
            insertExportMappingOrError(newPackageJson, subpath, {
                types: normalizePath(typesOutRelativePath),
                esm2022: normalizePath(esmIndexOutRelativePath),
                esm: normalizePath(esmIndexOutRelativePath),
                // Note: The default conditions needs to be the last one.
                default: normalizePath(fesm2022OutRelativePath),
            });
        }
        return newPackageJson;
    }
    /**
     * Inserts a subpath export mapping into the specified `package.json` object.
     * @throws An error if the mapping is already defined and would conflict.
     */
    function insertExportMappingOrError(packageJson, subpath, mapping) {
        if (packageJson.exports === undefined) {
            packageJson.exports = {};
        }
        if (packageJson.exports[subpath] === undefined) {
            packageJson.exports[subpath] = {};
        }
        const subpathExport = packageJson.exports[subpath];
        // Go through all conditions that should be inserted. If the condition is already
        // manually set of the subpath export, we throw an error. In general, we allow for
        // additional conditions to be set. These will always precede the generated ones.
        for (const conditionName of Object.keys(mapping)) {
            if (subpathExport[conditionName] !== undefined) {
                throw Error(`Found a conflicting export condition for "${subpath}". The "${conditionName}" ` +
                    `condition would be overridden by the packager. Please unset it.`);
            }
            // **Note**: The order of the conditions is preserved even though we are setting
            // the conditions once at a time (the latest assignment will be at the end).
            subpathExport[conditionName] = mapping[conditionName];
        }
    }
    /** Whether the package explicitly sets any of the format properties (like `main`). */
    function hasExplicitFormatProperties(parsedPackage) {
        return Object.keys(parsedPackage).some((fieldName) => knownFormatPackageJsonFormatFields.includes(fieldName));
    }
    /**
     * Normalizes the specified path by replacing backslash separators with Posix
     * forward slash separators.
     */
    function normalizePath(path) {
        const result = path.replace(/\\/g, '/');
        return result.startsWith('.') ? result : `./${result}`;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFja2FnZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9iYXplbC9zcmMvbmdfcGFja2FnZS9wYWNrYWdlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFFSCxPQUFPLEtBQUssRUFBRSxNQUFNLElBQUksQ0FBQztBQUN6QixPQUFPLEtBQUssSUFBSSxNQUFNLE1BQU0sQ0FBQztBQUc3QixPQUFPLEVBQUMsa0NBQWtDLEVBQUMsTUFBTSw4QkFBOEIsQ0FBQztBQUVoRjs7O0dBR0c7QUFDSCxNQUFNLGtDQUFrQyxHQUFHLENBQUMsTUFBTSxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLFFBQVEsQ0FBVSxDQUFDO0FBeUJwRyxvQkFBb0I7QUFDcEIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFFNUIsU0FBUyxJQUFJLENBQUMsSUFBYztJQUMxQiwwRkFBMEY7SUFDMUYsNkZBQTZGO0lBQzdGLE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUU5Qiw2Q0FBNkM7SUFDN0MsU0FBUyxnQkFBZ0IsQ0FBQyxDQUFTO1FBQ2pDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVELHFEQUFxRDtJQUNyRCxNQUFNLE1BQU0sR0FBRyxFQUFFLENBQUMsWUFBWSxDQUFDLGFBQWEsRUFBRSxPQUFPLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLENBQUM7SUFFekYsTUFBTTtJQUNKLHdDQUF3QztJQUN4QyxpQkFBaUI7SUFFakIsOEVBQThFO0lBQzlFLGlCQUFpQjtJQUVqQixrRkFBa0Y7SUFDbEYsV0FBVztJQUVYLG1DQUFtQztJQUNuQyxRQUFR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QWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuZGV2L2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuXG5pbXBvcnQge0JhemVsRmlsZUluZm8sIFBhY2thZ2VNZXRhZGF0YX0gZnJvbSAnLi9hcGknO1xuaW1wb3J0IHthbmFseXplRmlsZUFuZEVuc3VyZU5vQ3Jvc3NJbXBvcnRzfSBmcm9tICcuL2Nyb3NzX2VudHJ5X3BvaW50c19pbXBvcnRzJztcblxuLyoqXG4gKiBMaXN0IG9mIGtub3duIGBwYWNrYWdlLmpzb25gIGZpZWxkcyB3aGljaCBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0XG4gKiBzdXBwb3J0ZWQgcGFja2FnZSBmb3JtYXRzIGFuZCB0aGVpciBhc3NvY2lhdGVkIGVudHJ5IHBhdGhzLlxuICovXG5jb25zdCBrbm93bkZvcm1hdFBhY2thZ2VKc29uRm9ybWF0RmllbGRzID0gWydtYWluJywgJ2VzbTIwMjInLCAnZXNtJywgJ3R5cGluZ3MnLCAnbW9kdWxlJ10gYXMgY29uc3Q7XG5cbi8qKiBVbmlvbiB0eXBlIG1hdGNoaW5nIGtub3duIGBwYWNrYWdlLmpzb25gIGZvcm1hdCBmaWVsZHMuICovXG50eXBlIEtub3duUGFja2FnZUpzb25Gb3JtYXRGaWVsZHMgPSAodHlwZW9mIGtub3duRm9ybWF0UGFja2FnZUpzb25Gb3JtYXRGaWVsZHMpW251bWJlcl07XG5cbi8qKlxuICogVHlwZSBkZXNjcmliaW5nIHRoZSBjb25kaXRpb25hbCBleHBvcnRzIGRlc2NyaXB0b3IgZm9yIGFuIGVudHJ5LXBvaW50LlxuICogaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9wYWNrYWdlcy5odG1sI3BhY2thZ2VzX2NvbmRpdGlvbmFsX2V4cG9ydHNcbiAqL1xudHlwZSBDb25kaXRpb25hbEV4cG9ydCA9IHtcbiAgdHlwZXM/OiBzdHJpbmc7XG4gIGVzbTIwMjI/OiBzdHJpbmc7XG4gIGVzbT86IHN0cmluZztcbiAgZGVmYXVsdD86IHN0cmluZztcbn07XG5cbi8qKiBUeXBlIGRlc2NyaWJpbmcgYSBgcGFja2FnZS5qc29uYCB0aGUgcGFja2FnZXIgZGVhbHMgd2l0aC4gKi9cbnR5cGUgUGFja2FnZUpzb24gPSB7XG4gIFtrZXkgaW4gS25vd25QYWNrYWdlSnNvbkZvcm1hdEZpZWxkc10/OiBzdHJpbmc7XG59ICYge1xuICBuYW1lOiBzdHJpbmc7XG4gIHR5cGU/OiBzdHJpbmc7XG4gIGV4cG9ydHM/OiBSZWNvcmQ8c3RyaW5nLCBDb25kaXRpb25hbEV4cG9ydD47XG59O1xuXG4vLyBNYWluIGVudHJ5LXBvaW50LlxubWFpbihwcm9jZXNzLmFyZ3Yuc2xpY2UoMikpO1xuXG5mdW5jdGlvbiBtYWluKGFyZ3M6IHN0cmluZ1tdKTogdm9pZCB7XG4gIC8vIFRoaXMgdXRpbGl0eSBleHBlY3RzIGFsbCBvZiBpdHMgYXJndW1lbnRzIHRvIGJlIHNwZWNpZmllZCBpbiBhIHBhcmFtcyBmaWxlIGdlbmVyYXRlZCBieVxuICAvLyBiYXplbCAoc2VlIGh0dHBzOi8vZG9jcy5iYXplbC5idWlsZC92ZXJzaW9ucy9tYXN0ZXIvc2t5bGFyay9saWIvQXJncy5odG1sI3VzZV9wYXJhbV9maWxlKS5cbiAgY29uc3QgcGFyYW1GaWxlUGF0aCA9IGFyZ3NbMF07XG5cbiAgLy8gQmF6ZWwgcGFyYW1zIG1heSBiZSBzdXJyb3VuZGVkIHdpdGggcXVvdGVzXG4gIGZ1bmN0aW9uIHVucXVvdGVQYXJhbWV0ZXIoczogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZSgvXicoLiopJyQvLCAnJDEnKTtcbiAgfVxuXG4gIC8vIFBhcmFtZXRlcnMgYXJlIHNwZWNpZmllZCBpbiB0aGUgZmlsZSBvbmUgcGVyIGxpbmUuXG4gIGNvbnN0IHBhcmFtcyA9IGZzLnJlYWRGaWxlU3luYyhwYXJhbUZpbGVQYXRoLCAndXRmLTgnKS5zcGxpdCgnXFxuJykubWFwKHVucXVvdGVQYXJhbWV0ZXIpO1xuXG4gIGNvbnN0IFtcbiAgICAvLyBPdXRwdXQgZGlyZWN0b3J5IGZvciB0aGUgbnBtIHBhY2thZ2UuXG4gICAgb3V0cHV0RGlyRXhlY1BhdGgsXG5cbiAgICAvLyBUaGUgcGFja2FnZSBzZWdtZW50IG9mIHRoZSBuZ19wYWNrYWdlIHJ1bGUncyBsYWJlbCAoZS5nLiAncGFja2FnZS9jb21tb24nKS5cbiAgICBvd25pbmdQYWNrYWdlTmFtZSxcblxuICAgIC8vIEpTT04gZGF0YSBjYXB0dXJpbmcgbWV0YWRhdGEgb2YgdGhlIHBhY2thZ2UgYmVpbmcgYnVpbHQuIFNlZSBgUGFja2FnZU1ldGFkYXRhYC5cbiAgICBtZXRhZGF0YUFyZyxcblxuICAgIC8vIFBhdGggdG8gdGhlIHBhY2thZ2UncyBSRUFETUUubWQuXG4gICAgcmVhZG1lTWQsXG5cbiAgICAvLyBQYXRoIHRvIHRoZSBwYWNrYWdlJ3MgTElDRU5TRSBmaWxlLlxuICAgIGxpY2Vuc2VGaWxlLFxuXG4gICAgLy8gTGlzdCBvZiByb2xsZWQtdXAgZmxhdCBFUzIwMjIgbW9kdWxlc1xuICAgIGZlc20yMDIyQXJnLFxuXG4gICAgLy8gTGlzdCBvZiBpbmRpdmlkdWFsIEVTMjAyMiBtb2R1bGVzXG4gICAgZXNtMjAyMkFyZyxcblxuICAgIC8vIExpc3Qgb2Ygc3RhdGljIGZpbGVzIHRoYXQgc2hvdWxkIGJlIGNvcGllZCBpbnRvIHRoZSBwYWNrYWdlLlxuICAgIHN0YXRpY0ZpbGVzQXJnLFxuXG4gICAgLy8gTGlzdCBvZiBhbGwgdHlwZSBkZWZpbml0aW9ucyB0aGF0IG5lZWQgdG8gcGFja2FnZWQgaW50byB0aGUgbmdfcGFja2FnZS5cbiAgICB0eXBlRGVmaW5pdGlvbnNBcmcsXG4gIF0gPSBwYXJhbXM7XG5cbiAgY29uc3QgZmVzbTIwMjIgPSBKU09OLnBhcnNlKGZlc20yMDIyQXJnKSBhcyBCYXplbEZpbGVJbmZvW107XG4gIGNvbnN0IGVzbTIwMjIgPSBKU09OLnBhcnNlKGVzbTIwMjJBcmcpIGFzIEJhemVsRmlsZUluZm9bXTtcbiAgY29uc3QgdHlwZURlZmluaXRpb25zID0gSlNPTi5wYXJzZSh0eXBlRGVmaW5pdGlvbnNBcmcpIGFzIEJhemVsRmlsZUluZm9bXTtcbiAgY29uc3Qgc3RhdGljRmlsZXMgPSBKU09OLnBhcnNlKHN0YXRpY0ZpbGVzQXJnKSBhcyBCYXplbEZpbGVJbmZvW107XG4gIGNvbnN0IG1ldGFkYXRhID0gSlNPTi5wYXJzZShtZXRhZGF0YUFyZykgYXMgUGFja2FnZU1ldGFkYXRhO1xuXG4gIGlmIChyZWFkbWVNZCkge1xuICAgIGNvcHlGaWxlKHJlYWRtZU1kLCAnUkVBRE1FLm1kJyk7XG4gIH1cblxuICBpZiAobGljZW5zZUZpbGUpIHtcbiAgICBjb3B5RmlsZShsaWNlbnNlRmlsZSwgJ0xJQ0VOU0UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZXMgYSBmaWxlIHdpdGggdGhlIHNwZWNpZmllZCBjb250ZW50IGludG8gdGhlIHBhY2thZ2Ugb3V0cHV0LlxuICAgKiBAcGFyYW0gb3V0cHV0UmVsYXRpdmVQYXRoIFJlbGF0aXZlIHBhdGggaW4gdGhlIG91dHB1dCBkaXJlY3Rvcnkgd2hlcmUgdGhlXG4gICAqICAgZmlsZSBpcyB3cml0dGVuIHRvLlxuICAgKiBAcGFyYW0gZmlsZUNvbnRlbnQgQ29udGVudCBvZiB0aGUgZmlsZS5cbiAgICovXG4gIGZ1bmN0aW9uIHdyaXRlRmlsZShvdXRwdXRSZWxhdGl2ZVBhdGg6IHN0cmluZywgZmlsZUNvbnRlbnQ6IHN0cmluZyB8IEJ1ZmZlcikge1xuICAgIGNvbnN0IG91dHB1dFBhdGggPSBwYXRoLmpvaW4ob3V0cHV0RGlyRXhlY1BhdGgsIG91dHB1dFJlbGF0aXZlUGF0aCk7XG5cbiAgICAvLyBBbHdheXMgZW5zdXJlIHRoYXQgdGhlIHRhcmdldCBkaXJlY3RvcnkgZXhpc3RzLlxuICAgIGZzLm1rZGlyU3luYyhwYXRoLmRpcm5hbWUob3V0cHV0UGF0aCksIHtyZWN1cnNpdmU6IHRydWV9KTtcbiAgICBmcy53cml0ZUZpbGVTeW5jKG91dHB1dFBhdGgsIGZpbGVDb250ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3BpZXMgYSBmaWxlIGludG8gdGhlIHBhY2thZ2Ugb3V0cHV0IHRvIHRoZSBzcGVjaWZpZWQgbG9jYXRpb24uXG4gICAqIEBwYXJhbSBpbnB1dFBhdGggRmlsZSB0aGF0IHNob3VsZCBiZSBjb3BpZWQuXG4gICAqIEBwYXJhbSBvdXRwdXRSZWxhdGl2ZVBhdGggUmVsYXRpdmUgcGF0aCBpbiB0aGUgb3V0cHV0IGRpcmVjdG9yeSB3aGVyZSB0aGVcbiAgICogICBmaWxlIGlzIHdyaXR0ZW4gdG8uXG4gICAqL1xuICBmdW5jdGlvbiBjb3B5RmlsZShpbnB1dFBhdGg6IHN0cmluZywgb3V0cHV0UmVsYXRpdmVQYXRoOiBzdHJpbmcpIHtcbiAgICBjb25zdCBmaWxlQ29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhpbnB1dFBhdGgsICd1dGY4Jyk7XG4gICAgd3JpdGVGaWxlKG91dHB1dFJlbGF0aXZlUGF0aCwgZmlsZUNvbnRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHJlbGF0aXZlIHBhdGggZm9yIHRoZSBnaXZlbiBmaWxlIHdpdGhpbiB0aGUgb3duaW5nIHBhY2thZ2UuIFRoaXNcbiAgICogYXNzdW1lcyB0aGUgZmlsZSBpcyBjb250YWluZWQgaW4gdGhlIG93bmluZyBwYWNrYWdlLlxuICAgKlxuICAgKiBlLmcuIGNvbnNpZGVyIHRoZSBvd25pbmcgcGFja2FnZSBpcyBgcGFja2FnZXMvY29yZWAgYW5kIHRoZSBpbnB1dCBmaWxlXG4gICAqIGlzIGBwYWNrYWdlcy9jb3JlL3Rlc3RpbmcvaW5kZXguZC50c2AuIFRoaXMgZnVuY3Rpb24gd291bGQgcmV0dXJuIHRoZVxuICAgKiByZWxhdGl2ZSBwYXRoIGFzIGZvbGxvd2VkOiBgdGVzdGluZy9pbmRleC5kLnRzYC5cbiAgICovXG4gIGZ1bmN0aW9uIGdldE93bmluZ1BhY2thZ2VSZWxhdGl2ZVBhdGgoZmlsZTogQmF6ZWxGaWxlSW5mbyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHBhdGgucmVsYXRpdmUob3duaW5nUGFja2FnZU5hbWUsIGZpbGUuc2hvcnRQYXRoKTtcbiAgfVxuXG4gIC8qKiBXcml0ZXMgYW4gRVNNIGZpbGUgaW50byB0aGUgYGVzbTIwMjJgIG91dHB1dCBkaXJlY3RvcnkuICovXG4gIGZ1bmN0aW9uIHdyaXRlRXNtMjAyMkZpbGUoZmlsZTogQmF6ZWxGaWxlSW5mbykge1xuICAgIC8vIE5vdGU6IGZpbGVzIHdoaWNoIGRvIG5vdCBiZWxvbmcgdG8gdGhlIG93bmluZyBwYWNrYWdlIG9mIHRoaXMgYG5nX3BhY2thZ2VgIGFyZSBvbWl0dGVkLlxuICAgIC8vIHRoaXMgcHJldmVudHMgdXMgZnJvbSBhY2NpZGVudGFsbHkgYnJpbmdpbmcgaW4gdHJhbnNpdGl2ZSBub2RlIG1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gICAgY29uc3QgcGFja2FnZVJlbGF0aXZlUGF0aCA9IGdldE93bmluZ1BhY2thZ2VSZWxhdGl2ZVBhdGgoZmlsZSk7XG4gICAgaWYgKCFwYWNrYWdlUmVsYXRpdmVQYXRoLnN0YXJ0c1dpdGgoJy4uJykpIHtcbiAgICAgIGNvcHlGaWxlKGZpbGUucGF0aCwgZ2V0RXNtMjAyMk91dHB1dFJlbGF0aXZlUGF0aChmaWxlKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEdldHMgdGhlIG91dHB1dC1yZWxhdGl2ZSBwYXRoIHdoZXJlIHRoZSBnaXZlbiBmbGF0IEVTTSBmaWxlIHNob3VsZCBiZSB3cml0dGVuIHRvLiAqL1xuICBmdW5jdGlvbiBnZXRGbGF0RXNtT3V0cHV0UmVsYXRpdmVQYXRoKGZpbGU6IEJhemVsRmlsZUluZm8pIHtcbiAgICAvLyBGbGF0IEVTTSBmaWxlcyBzaG91bGQgYmUgcHV0IGludG8gdGhlaXIgb3duaW5nIHBhY2thZ2UgcmVsYXRpdmUgc3ViLXBhdGguIGUuZy4gaWZcbiAgICAvLyB0aGVyZSBpcyBhIGJ1bmRsZSBpbiBgcGFja2FnZXMvYW5pbWF0aW9ucy9mZXNtMjAyMi9icm93c2VyL3Rlc3RpbmcubWpzYCB0aGVuIHdlXG4gICAgLy8gd2FudCB0aGUgYnVuZGxlIHRvIGJlIHN0b3JlZCBpbiBgZmVzbTIwMjIvYnJvd3Nlci90ZXN0aW5nLm1qc2AuIFNhbWUgdGhpbmcgYXBwbGllc1xuICAgIC8vIGZvciB0aGUgYGZlc20yMDIyYCBidW5kbGVzLiBUaGUgZGlyZWN0b3J5IG5hbWUgZm9yIGBmZXNtYCBpcyBhbHJlYWR5IGRlY2xhcmVkIGFzXG4gICAgLy8gcGFydCBvZiB0aGUgQmF6ZWwgYWN0aW9uIGdlbmVyYXRpbmcgdGhlc2UgZmlsZXMuIFNlZSBgbmdfcGFja2FnZS5iemxgLlxuICAgIHJldHVybiBnZXRPd25pbmdQYWNrYWdlUmVsYXRpdmVQYXRoKGZpbGUpO1xuICB9XG5cbiAgLyoqIEdldHMgdGhlIG91dHB1dC1yZWxhdGl2ZSBwYXRoIHdoZXJlIGEgbm9uLWZsYXQgRVNNMjAyMiBmaWxlIHNob3VsZCBiZSB3cml0dGVuIHRvLiAqL1xuICBmdW5jdGlvbiBnZXRFc20yMDIyT3V0cHV0UmVsYXRpdmVQYXRoKGZpbGU6IEJhemVsRmlsZUluZm8pIHtcbiAgICAvLyBQYXRoIGNvbXB1dGVkIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBhY2thZ2UgaW4gYmF6ZWwtYmluLiBlLmcuIGEgRVMyMDIyIG91dHB1dCBmaWxlXG4gICAgLy8gaW4gYGJhemVsLW91dC88Li4+L3BhY2thZ2VzL2NvcmUvc3JjL2RpLm1qc2Agc2hvdWxkIGJlIHN0b3JlZCBpbiBgZXNtMjAyMi9zcmMvZGkubWpzYC5cbiAgICByZXR1cm4gcGF0aC5qb2luKCdlc20yMDIyJywgZ2V0T3duaW5nUGFja2FnZVJlbGF0aXZlUGF0aChmaWxlKSk7XG4gIH1cblxuICAvKiogR2V0cyB0aGUgb3V0cHV0LXJlbGF0aXZlIHBhdGggd2hlcmUgdGhlIHR5cGluZyBmaWxlIGlzIGJlaW5nIHdyaXR0ZW4gdG8uICovXG4gIGZ1bmN0aW9uIGdldFR5cGluZ091dHB1dFJlbGF0aXZlUGF0aChmaWxlOiBCYXplbEZpbGVJbmZvKSB7XG4gICAgLy8gVHlwZSBkZWZpbml0aW9ucyBhcmUgaW50ZW5kZWQgdG8gYmUgY29waWVkIGludG8gdGhlIHBhY2thZ2Ugb3V0cHV0IHdoaWxlIHByZXNlcnZpbmcgdGhlXG4gICAgLy8gc3ViLXBhdGggZnJvbSB0aGUgb3duaW5nIHBhY2thZ2UuIGUuZy4gYSBmaWxlIGxpa2UgYHBhY2thZ2VzL2FuaW1hdGlvbnMvYnJvd3Nlci9fX2luZGV4LmQudHNgXG4gICAgLy8gd2lsbCBlbmQgdXAgYmVpbmcgd3JpdHRlbiB0byBgPHBrZy1vdXQ+L2Jyb3dzZXIvaW5kZXguZC50c2AuIE5vdGUgdGhhdCB0eXBlcyBhcmUgYnVuZGxlZFxuICAgIC8vIGFzIGEgc2VwYXJhdGUgYWN0aW9uIGluIHRoZSBgbmdfcGFja2FnZWAgU3RhcmxhcmsgcnVsZSBhbmQgcHJlZml4ZWQgd2l0aCBgX19gIHRvIGF2b2lkXG4gICAgLy8gY29uZmxpY3RzIHdpdGggc291cmNlIGBpbmRleC5kLnRzYCBmaWxlcy4gV2UgcmVtb3ZlIHRoaXMgcHJlZml4IGhlcmUuXG4gICAgcmV0dXJuIGdldE93bmluZ1BhY2thZ2VSZWxhdGl2ZVBhdGgoZmlsZSkucmVwbGFjZSgvX19pbmRleFxcLmRcXC50cyQvLCAnaW5kZXguZC50cycpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGVudHJ5LXBvaW50IHN1Yi1wYXRoIGZyb20gdGhlIHBhY2thZ2Ugcm9vdC4gZS5nLiBpZiB0aGUgcGFja2FnZSBuYW1lXG4gICAqIGlzIGBAYW5ndWxhci9jZGtgLCB0aGVuIGZvciBgQGFuZ3VsYXIvY2RrL2ExMXlgIGp1c3QgYGExMXlgIHdvdWxkIGJlIHJldHVybmVkLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0RW50cnlQb2ludFN1YnBhdGgobW9kdWxlTmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gbW9kdWxlTmFtZS5zbGljZShgJHttZXRhZGF0YS5ucG1QYWNrYWdlTmFtZX0vYC5sZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgd2hldGhlciB0aGUgZ2l2ZW4gbW9kdWxlIG5hbWUgcmVzb2x2ZXMgdG8gYSBzZWNvbmRhcnkgZW50cnktcG9pbnQuXG4gICAqIGUuZy4gaWYgdGhlIHBhY2thZ2UgbmFtZSBpcyBgQGFuZ3VsYXIvY2RrYCwgdGhlbiBmb3IgYEBhbmd1bGFyL2Nkay9hMTF5YFxuICAgKiB0aGlzIHdvdWxkIHJldHVybiBgdHJ1ZWAuXG4gICAqL1xuICBmdW5jdGlvbiBpc1NlY29uZGFyeUVudHJ5UG9pbnQobW9kdWxlTmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGdldEVudHJ5UG9pbnRTdWJwYXRoKG1vZHVsZU5hbWUpICE9PSAnJztcbiAgfVxuXG4gIGNvbnN0IGNyb3NzRW50cnlQb2ludEZhaWx1cmVzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIGVzbTIwMjIuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgIGNyb3NzRW50cnlQb2ludEZhaWx1cmVzLnB1c2goLi4uYW5hbHl6ZUZpbGVBbmRFbnN1cmVOb0Nyb3NzSW1wb3J0cyhmaWxlLCBtZXRhZGF0YSkpO1xuICAgIHdyaXRlRXNtMjAyMkZpbGUoZmlsZSk7XG4gIH0pO1xuXG4gIGlmIChjcm9zc0VudHJ5UG9pbnRGYWlsdXJlcy5sZW5ndGgpIHtcbiAgICBjb25zb2xlLmVycm9yKGNyb3NzRW50cnlQb2ludEZhaWx1cmVzKTtcbiAgICBwcm9jZXNzLmV4aXQoMSk7XG4gIH1cblxuICAvLyBDb3B5IGFsbCBGRVNNIGZpbGVzIGludG8gdGhlIHBhY2thZ2Ugb3V0cHV0LlxuICBmZXNtMjAyMi5mb3JFYWNoKChmKSA9PiBjb3B5RmlsZShmLnBhdGgsIGdldEZsYXRFc21PdXRwdXRSZWxhdGl2ZVBhdGgoZikpKTtcblxuICAvLyBDb3B5IGFsbCB0eXBlIGRlZmluaXRpb25zIGludG8gdGhlIHBhY2thZ2UsIHByZXNlcnZpbmcgdGhlIHN1Yi1wYXRoIGZyb20gdGhlXG4gIC8vIG93bmluZyBwYWNrYWdlLiBlLmcuIGEgZmlsZSBsaWtlIGBwYWNrYWdlcy9hbmltYXRpb25zL2Jyb3dzZXIvX19pbmRleC5kLnRzYCB3aWxsXG4gIC8vIGVuZCB1cCBpbiBgYnJvd3Nlci9pbmRleC5kLnRzYFxuICB0eXBlRGVmaW5pdGlvbnMuZm9yRWFjaCgoZikgPT4gY29weUZpbGUoZi5wYXRoLCBnZXRUeXBpbmdPdXRwdXRSZWxhdGl2ZVBhdGgoZikpKTtcblxuICBmb3IgKGNvbnN0IGZpbGUgb2Ygc3RhdGljRmlsZXMpIHtcbiAgICAvLyBXZSBjb3B5IGFsbCBmaWxlcyBpbnRvIHRoZSBwYWNrYWdlIG91dHB1dCB3aGlsZSBwcmVzZXJ2aW5nIHRoZSBzdWItcGF0aCBmcm9tXG4gICAgLy8gdGhlIG93bmluZyBwYWNrYWdlLiBlLmcuIGBwYWNrYWdlcy9jb3JlL3BhY2thZ2UuanNvbmAgZW5kcyB1cCBgPHBrZy1vdXQ+L3BhY2thZ2UuanNvbmAuXG4gICAgY29uc3Qgb3V0cHV0UmVsYXRpdmVQYXRoID0gZ2V0T3duaW5nUGFja2FnZVJlbGF0aXZlUGF0aChmaWxlKTtcbiAgICBsZXQgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhmaWxlLnBhdGgsICd1dGY4Jyk7XG5cbiAgICAvLyBDaGVjayBhbmQgbW9kaWZ5IHBhY2thZ2UuanNvbiBmaWxlcyBhcyBuZWNlc3NhcnkgZm9yIHB1Ymxpc2hpbmdcbiAgICBpZiAocGF0aC5iYXNlbmFtZShmaWxlLnBhdGgpID09PSAncGFja2FnZS5qc29uJykge1xuICAgICAgY29uc3QgaXNQcmltYXJ5UGFja2FnZUpzb24gPSBvdXRwdXRSZWxhdGl2ZVBhdGggPT09ICdwYWNrYWdlLmpzb24nO1xuICAgICAgY29uc3QgcGFja2FnZUpzb24gPSBKU09OLnBhcnNlKGNvbnRlbnQpIGFzIFBhY2thZ2VKc29uO1xuICAgICAgY29uc3QgcGFja2FnZU5hbWUgPSBwYWNrYWdlSnNvblsnbmFtZSddO1xuXG4gICAgICAvLyBQcmV2ZW50IG5vbi1wcmltYXJ5IGBwYWNrYWdlLmpzb25gIGZpbGVzIHdoaWNoIHdvdWxkIHRocm93LW9mZiByZXNvbHV0aW9uLlxuICAgICAgLy8gUmVzb2x1dGlvbiBpbiB0aGUgcGFja2FnZSBzaG91bGQgb25seSBiZSBiYXNlZCBvbiB0aGUgdG9wLWxldmVsIGBwYWNrYWdlLmpzb25gLlxuICAgICAgaWYgKCFpc1ByaW1hcnlQYWNrYWdlSnNvbikge1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBgRm91bmQgYSBuZXN0ZWQgXCJwYWNrYWdlLmpzb25cIiBmaWxlIGluIHRoZSBwYWNrYWdlIG91dHB1dDogJHtmaWxlLnNob3J0UGF0aH0uXFxuYCArXG4gICAgICAgICAgICBgQWxsIGluZm9ybWF0aW9uIG9mIHRoZSBwYWNrYWdlIHNob3VsZCByZXNpZGUgaW4gdGhlIHByaW1hcnkgcGFja2FnZSBmaWxlLmAsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBgbmFtZWAgZmllbGQgb2YgdGhlIGBwYWNrYWdlLmpzb25gIGZpbGVzIGFyZSBtYXRjaGluZyB3aXRoXG4gICAgICAvLyBuYW1lIG9mIHRoZSBOUE0gcGFja2FnZS4gVGhpcyBpcyBhbiBhZGRpdGlvbmFsIHNhZmV0eSBjaGVjay5cbiAgICAgIGlmIChwYWNrYWdlTmFtZSAhPT0gbWV0YWRhdGEubnBtUGFja2FnZU5hbWUpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgYFByaW1hcnkgXCJwYWNrYWdlLmpzb25cIiBoYXMgbWlzbWF0Y2hpbmcgcGFja2FnZSBuYW1lLiBFeHBlY3RlZCB0aGUgYCArXG4gICAgICAgICAgICBgcGFja2FnZSB0byBiZSBuYW1lZCBcIiR7bWV0YWRhdGEubnBtUGFja2FnZU5hbWV9XCIsIGJ1dCBpcyBzZXQgdG86ICR7cGFja2FnZU5hbWV9LmAsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGxldCBuZXdQYWNrYWdlSnNvbiA9IGluc2VydEZvcm1hdEZpZWxkc0ludG9QYWNrYWdlSnNvbihcbiAgICAgICAgb3V0cHV0UmVsYXRpdmVQYXRoLFxuICAgICAgICBwYWNrYWdlSnNvbixcbiAgICAgICAgZmFsc2UsXG4gICAgICApO1xuXG4gICAgICBuZXdQYWNrYWdlSnNvbiA9IHVwZGF0ZVByaW1hcnlQYWNrYWdlSnNvbihuZXdQYWNrYWdlSnNvbik7XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgY29udGVudCB3aXRoIHRoZSBuZXcgYHBhY2thZ2UuanNvbmAgZmlsZSBjb250ZW50LlxuICAgICAgY29udGVudCA9IEpTT04uc3RyaW5naWZ5KG5ld1BhY2thZ2VKc29uLCBudWxsLCAyKTtcbiAgICB9XG5cbiAgICB3cml0ZUZpbGUob3V0cHV0UmVsYXRpdmVQYXRoLCBjb250ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIG9yIGVkaXRzIHByb3BlcnRpZXMgaW50byB0aGUgcGFja2FnZS5qc29uIGZpbGUocykgaW4gdGhlIHBhY2thZ2Ugc28gdGhhdFxuICAgKiB0aGV5IHBvaW50IHRvIGFsbCB0aGUgcmlnaHQgZ2VuZXJhdGVkIGFydGlmYWN0cy5cbiAgICpcbiAgICogQHBhcmFtIHBhY2thZ2VKc29uT3V0UmVsYXRpdmVQYXRoIFBhdGggd2hlcmUgdGhlIGBwYWNrYWdlLmpzb25gIGlzIHN0b3JlZCBpblxuICAgKiAgIHRoZSBwYWNrYWdlIG91dHB1dC5cbiAgICogQHBhcmFtIHBhcnNlZFBhY2thZ2UgUGFyc2VkIHBhY2thZ2UuanNvbiBjb250ZW50XG4gICAqIEBwYXJhbSBpc0dlbmVyYXRlZFBhY2thZ2VKc29uIFdoZXRoZXIgdGhlIHBhc3NlZCBwYWNrYWdlLmpzb24gaGFzIGJlZW4gZ2VuZXJhdGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gaW5zZXJ0Rm9ybWF0RmllbGRzSW50b1BhY2thZ2VKc29uKFxuICAgIHBhY2thZ2VKc29uT3V0UmVsYXRpdmVQYXRoOiBzdHJpbmcsXG4gICAgcGFyc2VkUGFja2FnZTogUmVhZG9ubHk8UGFja2FnZUpzb24+LFxuICAgIGlzR2VuZXJhdGVkUGFja2FnZUpzb246IGJvb2xlYW4sXG4gICk6IFBhY2thZ2VKc29uIHtcbiAgICBjb25zdCBwYWNrYWdlSnNvbjogUGFja2FnZUpzb24gPSB7Li4ucGFyc2VkUGFja2FnZX07XG4gICAgY29uc3QgcGFja2FnZU5hbWUgPSBwYWNrYWdlSnNvblsnbmFtZSddO1xuICAgIGNvbnN0IGVudHJ5UG9pbnRJbmZvID0gbWV0YWRhdGEuZW50cnlQb2ludHNbcGFja2FnZU5hbWVdO1xuICAgIGNvbnN0IHBhY2thZ2VKc29uQ29udGFpbmluZ0RpciA9IHBhdGguZGlybmFtZShwYWNrYWdlSnNvbk91dFJlbGF0aXZlUGF0aCk7XG5cbiAgICAvLyBJZiBhIHBhY2thZ2UganNvbiBmaWxlIGhhcyBiZWVuIGRpc2NvdmVyZWQgdGhhdCBkb2VzIG5vdCBtYXRjaCBhbnlcbiAgICAvLyBlbnRyeS1wb2ludCBpbiB0aGUgbWV0YWRhdGEsIHdlIHJlcG9ydCBhIHdhcm5pbmcgYXMgbW9zdCBsaWtlbHkgdGhlIHRhcmdldFxuICAgIC8vIGlzIGNvbmZpZ3VyZWQgaW5jb3JyZWN0bHkgKGUuZy4gbWlzc2luZyBgbW9kdWxlX25hbWVgIGF0dHJpYnV0ZSkuXG4gICAgaWYgKCFlbnRyeVBvaW50SW5mbykge1xuICAgICAgLy8gSWRlYWxseSB3ZSBzaG91bGQgdGhyb3cgaGVyZSwgYXMgd2UgZ290IGFuIGVudHJ5IHBvaW50IHRoYXQgZG9lc24ndFxuICAgICAgLy8gaGF2ZSBmbGF0IG1vZHVsZSBtZXRhZGF0YSAvIGJ1bmRsZSBpbmRleCwgc28gaXQgbWF5IGhhdmUgYmVlbiBhblxuICAgICAgLy8gbmdfbW9kdWxlIHRoYXQncyBtaXNzaW5nIGEgbW9kdWxlX25hbWUgYXR0cmlidXRlLlxuICAgICAgLy8gSG93ZXZlciwgQGFuZ3VsYXIvY29tcGlsZXIgY2FuJ3QgYmUgYW4gbmdfbW9kdWxlLCBhcyBpdCdzIHRoZSBpbnRlcm5hbHNcbiAgICAgIC8vIG9mIHRoZSBuZ2MgY29tcGlsZXIsIHlldCB3ZSB3YW50IHRvIGJ1aWxkIGFuIG5nX3BhY2thZ2UgZm9yIGl0LlxuICAgICAgLy8gU28gaWdub3JlIHBhY2thZ2UuanNvbiBmaWxlcyB3aGVuIHdlIGFyZSBtaXNzaW5nIGRhdGEuXG4gICAgICBjb25zb2xlLmVycm9yKCdXQVJOSU5HOiBubyBtb2R1bGUgbWV0YWRhdGEgZm9yIHBhY2thZ2UnLCBwYWNrYWdlTmFtZSk7XG4gICAgICBjb25zb2xlLmVycm9yKCcgICBOb3QgdXBkYXRpbmcgdGhlIHBhY2thZ2UuanNvbiBmaWxlIHRvIHBvaW50IHRvIGl0Jyk7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAnICAgVGhlIG5nX21vZHVsZSBmb3IgdGhpcyBwYWNrYWdlIGlzIHBvc3NpYmx5IG1pc3NpbmcgdGhlIG1vZHVsZV9uYW1lIGF0dHJpYnV0ZSAnLFxuICAgICAgKTtcbiAgICAgIHJldHVybiBwYWNrYWdlSnNvbjtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBndWVzc2VkIHRoZSBpbmRleCBwYXRocyBmb3IgYSBtb2R1bGUsIGFuZCBpdCBjb250YWlucyBhbiBleHBsaWNpdCBgcGFja2FnZS5qc29uYFxuICAgIC8vIGZpbGUgdGhhdCBhbHJlYWR5IHNldHMgZm9ybWF0IHByb3BlcnRpZXMsIHdlIHNraXAgYXV0b21hdGljIGluc2VydGlvbiBvZiBmb3JtYXRcbiAgICAvLyBwcm9wZXJ0aWVzIGJ1dCByZXBvcnQgYSB3YXJuaW5nIGluIGNhc2UgcHJvcGVydGllcyBoYXZlIGJlZW4gc2V0IGJ5IGFjY2lkZW50LlxuICAgIGlmIChcbiAgICAgIGVudHJ5UG9pbnRJbmZvLmd1ZXNzZWRQYXRocyAmJlxuICAgICAgIWlzR2VuZXJhdGVkUGFja2FnZUpzb24gJiZcbiAgICAgIGhhc0V4cGxpY2l0Rm9ybWF0UHJvcGVydGllcyhwYWNrYWdlSnNvbilcbiAgICApIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1dBUk5JTkc6IGBwYWNrYWdlLmpzb25gIGV4cGxpY2l0bHkgc2V0cyBmb3JtYXQgcHJvcGVydGllcyAobGlrZSBgbWFpbmApLicpO1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgJyAgICBTa2lwcGluZyBhdXRvbWF0aWMgaW5zZXJ0aW9uIG9mIGZvcm1hdCBwcm9wZXJ0aWVzIGFzIGV4cGxpY2l0ICcgK1xuICAgICAgICAgICdmb3JtYXQgcHJvcGVydGllcyBhcmUgc2V0LicsXG4gICAgICApO1xuICAgICAgY29uc29sZS5lcnJvcignICAgIElnbm9yZSB0aGlzIHdhcm5pbmcgaWYgZXhwbGljaXQgcHJvcGVydGllcyBhcmUgc2V0IGludGVudGlvbmFsbHkuJyk7XG4gICAgICByZXR1cm4gcGFja2FnZUpzb247XG4gICAgfVxuXG4gICAgY29uc3QgZmVzbTIwMjJSZWxhdGl2ZU91dFBhdGggPSBnZXRGbGF0RXNtT3V0cHV0UmVsYXRpdmVQYXRoKGVudHJ5UG9pbnRJbmZvLmZlc20yMDIyQnVuZGxlKTtcbiAgICBjb25zdCB0eXBpbmdzUmVsYXRpdmVPdXRQYXRoID0gZ2V0VHlwaW5nT3V0cHV0UmVsYXRpdmVQYXRoKGVudHJ5UG9pbnRJbmZvLnR5cGluZ3MpO1xuXG4gICAgcGFja2FnZUpzb24ubW9kdWxlID0gbm9ybWFsaXplUGF0aChcbiAgICAgIHBhdGgucmVsYXRpdmUocGFja2FnZUpzb25Db250YWluaW5nRGlyLCBmZXNtMjAyMlJlbGF0aXZlT3V0UGF0aCksXG4gICAgKTtcbiAgICBwYWNrYWdlSnNvbi50eXBpbmdzID0gbm9ybWFsaXplUGF0aChcbiAgICAgIHBhdGgucmVsYXRpdmUocGFja2FnZUpzb25Db250YWluaW5nRGlyLCB0eXBpbmdzUmVsYXRpdmVPdXRQYXRoKSxcbiAgICApO1xuXG4gICAgcmV0dXJuIHBhY2thZ2VKc29uO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHByaW1hcnkgYHBhY2thZ2UuanNvbmAgZmlsZSBvZiB0aGUgTlBNIHBhY2thZ2UgdG8gc3BlY2lmeVxuICAgKiB0aGUgbW9kdWxlIGNvbmRpdGlvbmFsIGV4cG9ydHMgYW5kIHRoZSBFU00gbW9kdWxlIHR5cGUuXG4gICAqL1xuICBmdW5jdGlvbiB1cGRhdGVQcmltYXJ5UGFja2FnZUpzb24ocGFja2FnZUpzb246IFJlYWRvbmx5PFBhY2thZ2VKc29uPik6IFBhY2thZ2VKc29uIHtcbiAgICBpZiAocGFja2FnZUpzb24udHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgJ1RoZSBwcmltYXJ5IFwicGFja2FnZS5qc29uXCIgZmlsZSBvZiB0aGUgcGFja2FnZSBzZXRzIHRoZSBcInR5cGVcIiBmaWVsZCAnICtcbiAgICAgICAgICAndGhhdCBpcyBjb250cm9sbGVkIGJ5IHRoZSBwYWNrYWdlci4gUGxlYXNlIHVuc2V0IGl0LicsXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld1BhY2thZ2VKc29uOiBQYWNrYWdlSnNvbiA9IHsuLi5wYWNrYWdlSnNvbn07XG5cbiAgICBuZXdQYWNrYWdlSnNvbi50eXBlID0gJ21vZHVsZSc7XG5cbiAgICAvLyBUaGUgYHBhY2thZ2UuanNvbmAgZmlsZSBpcyBtYWRlIHB1YmxpY2x5IGFjY2Vzc2libGUgZm9yIHRvb2xzIHRoYXRcbiAgICAvLyBtaWdodCB3YW50IHRvIHF1ZXJ5IGluZm9ybWF0aW9uIGZyb20gdGhlIEFuZ3VsYXIgTlBNIHBhY2thZ2UuXG4gICAgaW5zZXJ0RXhwb3J0TWFwcGluZ09yRXJyb3IobmV3UGFja2FnZUpzb24sICcuL3BhY2thZ2UuanNvbicsIHtkZWZhdWx0OiAnLi9wYWNrYWdlLmpzb24nfSk7XG5cbiAgICAvLyBDYXB0dXJlIGFsbCBlbnRyeS1wb2ludHMgaW4gdGhlIGBleHBvcnRzYCBmaWVsZCB1c2luZyB0aGUgc3VicGF0aCBleHBvcnQgZGVjbGFyYXRpb25zOlxuICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvcGFja2FnZXMuaHRtbCNwYWNrYWdlc19zdWJwYXRoX2V4cG9ydHMuXG4gICAgZm9yIChjb25zdCBbbW9kdWxlTmFtZSwgZW50cnlQb2ludF0gb2YgT2JqZWN0LmVudHJpZXMobWV0YWRhdGEuZW50cnlQb2ludHMpKSB7XG4gICAgICBjb25zdCBzdWJwYXRoID0gaXNTZWNvbmRhcnlFbnRyeVBvaW50KG1vZHVsZU5hbWUpXG4gICAgICAgID8gYC4vJHtnZXRFbnRyeVBvaW50U3VicGF0aChtb2R1bGVOYW1lKX1gXG4gICAgICAgIDogJy4nO1xuICAgICAgY29uc3QgZXNtSW5kZXhPdXRSZWxhdGl2ZVBhdGggPSBnZXRFc20yMDIyT3V0cHV0UmVsYXRpdmVQYXRoKGVudHJ5UG9pbnQuaW5kZXgpO1xuICAgICAgY29uc3QgZmVzbTIwMjJPdXRSZWxhdGl2ZVBhdGggPSBnZXRGbGF0RXNtT3V0cHV0UmVsYXRpdmVQYXRoKGVudHJ5UG9pbnQuZmVzbTIwMjJCdW5kbGUpO1xuICAgICAgY29uc3QgdHlwZXNPdXRSZWxhdGl2ZVBhdGggPSBnZXRUeXBpbmdPdXRwdXRSZWxhdGl2ZVBhdGgoZW50cnlQb2ludC50eXBpbmdzKTtcblxuICAgICAgLy8gSW5zZXJ0IHRoZSBleHBvcnQgbWFwcGluZyBmb3IgdGhlIGVudHJ5LXBvaW50LiBXZSBzZXQgYGRlZmF1bHRgIHRvIHRoZSBGRVNNIDIwMjJcbiAgICAgIC8vIG91dHB1dCwgYW5kIGFsc28gc2V0IHRoZSBgdHlwZXNgIGNvbmRpdGlvbiB3aGljaCB3aWxsIGJlIHJlc3BlY3RlZCBieSBUUyA0LjUuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvcHVsbC80NTg4NC5cbiAgICAgIGluc2VydEV4cG9ydE1hcHBpbmdPckVycm9yKG5ld1BhY2thZ2VKc29uLCBzdWJwYXRoLCB7XG4gICAgICAgIHR5cGVzOiBub3JtYWxpemVQYXRoKHR5cGVzT3V0UmVsYXRpdmVQYXRoKSxcbiAgICAgICAgZXNtMjAyMjogbm9ybWFsaXplUGF0aChlc21JbmRleE91dFJlbGF0aXZlUGF0aCksXG4gICAgICAgIGVzbTogbm9ybWFsaXplUGF0aChlc21JbmRleE91dFJlbGF0aXZlUGF0aCksXG4gICAgICAgIC8vIE5vdGU6IFRoZSBkZWZhdWx0IGNvbmRpdGlvbnMgbmVlZHMgdG8gYmUgdGhlIGxhc3Qgb25lLlxuICAgICAgICBkZWZhdWx0OiBub3JtYWxpemVQYXRoKGZlc20yMDIyT3V0UmVsYXRpdmVQYXRoKSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdQYWNrYWdlSnNvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIGEgc3VicGF0aCBleHBvcnQgbWFwcGluZyBpbnRvIHRoZSBzcGVjaWZpZWQgYHBhY2thZ2UuanNvbmAgb2JqZWN0LlxuICAgKiBAdGhyb3dzIEFuIGVycm9yIGlmIHRoZSBtYXBwaW5nIGlzIGFscmVhZHkgZGVmaW5lZCBhbmQgd291bGQgY29uZmxpY3QuXG4gICAqL1xuICBmdW5jdGlvbiBpbnNlcnRFeHBvcnRNYXBwaW5nT3JFcnJvcihcbiAgICBwYWNrYWdlSnNvbjogUGFja2FnZUpzb24sXG4gICAgc3VicGF0aDogc3RyaW5nLFxuICAgIG1hcHBpbmc6IENvbmRpdGlvbmFsRXhwb3J0LFxuICApIHtcbiAgICBpZiAocGFja2FnZUpzb24uZXhwb3J0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYWNrYWdlSnNvbi5leHBvcnRzID0ge307XG4gICAgfVxuICAgIGlmIChwYWNrYWdlSnNvbi5leHBvcnRzW3N1YnBhdGhdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhY2thZ2VKc29uLmV4cG9ydHNbc3VicGF0aF0gPSB7fTtcbiAgICB9XG5cbiAgICBjb25zdCBzdWJwYXRoRXhwb3J0ID0gcGFja2FnZUpzb24uZXhwb3J0c1tzdWJwYXRoXTtcblxuICAgIC8vIEdvIHRocm91Z2ggYWxsIGNvbmRpdGlvbnMgdGhhdCBzaG91bGQgYmUgaW5zZXJ0ZWQuIElmIHRoZSBjb25kaXRpb24gaXMgYWxyZWFkeVxuICAgIC8vIG1hbnVhbGx5IHNldCBvZiB0aGUgc3VicGF0aCBleHBvcnQsIHdlIHRocm93IGFuIGVycm9yLiBJbiBnZW5lcmFsLCB3ZSBhbGxvdyBmb3JcbiAgICAvLyBhZGRpdGlvbmFsIGNvbmRpdGlvbnMgdG8gYmUgc2V0LiBUaGVzZSB3aWxsIGFsd2F5cyBwcmVjZWRlIHRoZSBnZW5lcmF0ZWQgb25lcy5cbiAgICBmb3IgKGNvbnN0IGNvbmRpdGlvbk5hbWUgb2YgT2JqZWN0LmtleXMobWFwcGluZykgYXMgW2tleW9mIENvbmRpdGlvbmFsRXhwb3J0XSkge1xuICAgICAgaWYgKHN1YnBhdGhFeHBvcnRbY29uZGl0aW9uTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBgRm91bmQgYSBjb25mbGljdGluZyBleHBvcnQgY29uZGl0aW9uIGZvciBcIiR7c3VicGF0aH1cIi4gVGhlIFwiJHtjb25kaXRpb25OYW1lfVwiIGAgK1xuICAgICAgICAgICAgYGNvbmRpdGlvbiB3b3VsZCBiZSBvdmVycmlkZGVuIGJ5IHRoZSBwYWNrYWdlci4gUGxlYXNlIHVuc2V0IGl0LmAsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vICoqTm90ZSoqOiBUaGUgb3JkZXIgb2YgdGhlIGNvbmRpdGlvbnMgaXMgcHJlc2VydmVkIGV2ZW4gdGhvdWdoIHdlIGFyZSBzZXR0aW5nXG4gICAgICAvLyB0aGUgY29uZGl0aW9ucyBvbmNlIGF0IGEgdGltZSAodGhlIGxhdGVzdCBhc3NpZ25tZW50IHdpbGwgYmUgYXQgdGhlIGVuZCkuXG4gICAgICBzdWJwYXRoRXhwb3J0W2NvbmRpdGlvbk5hbWVdID0gbWFwcGluZ1tjb25kaXRpb25OYW1lXTtcbiAgICB9XG4gIH1cblxuICAvKiogV2hldGhlciB0aGUgcGFja2FnZSBleHBsaWNpdGx5IHNldHMgYW55IG9mIHRoZSBmb3JtYXQgcHJvcGVydGllcyAobGlrZSBgbWFpbmApLiAqL1xuICBmdW5jdGlvbiBoYXNFeHBsaWNpdEZvcm1hdFByb3BlcnRpZXMocGFyc2VkUGFja2FnZTogUmVhZG9ubHk8UGFja2FnZUpzb24+KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHBhcnNlZFBhY2thZ2UpLnNvbWUoKGZpZWxkTmFtZTogc3RyaW5nKSA9PlxuICAgICAga25vd25Gb3JtYXRQYWNrYWdlSnNvbkZvcm1hdEZpZWxkcy5pbmNsdWRlcyhmaWVsZE5hbWUgYXMgS25vd25QYWNrYWdlSnNvbkZvcm1hdEZpZWxkcyksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemVzIHRoZSBzcGVjaWZpZWQgcGF0aCBieSByZXBsYWNpbmcgYmFja3NsYXNoIHNlcGFyYXRvcnMgd2l0aCBQb3NpeFxuICAgKiBmb3J3YXJkIHNsYXNoIHNlcGFyYXRvcnMuXG4gICAqL1xuICBmdW5jdGlvbiBub3JtYWxpemVQYXRoKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgcmVzdWx0ID0gcGF0aC5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG4gICAgcmV0dXJuIHJlc3VsdC5zdGFydHNXaXRoKCcuJykgPyByZXN1bHQgOiBgLi8ke3Jlc3VsdH1gO1xuICB9XG59XG4iXX0=