/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("angular/packages/bazel/src/ng_package/packager", ["require", "exports", "fs", "path", "shelljs"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const fs = require("fs");
    const path = require("path");
    const shx = require("shelljs");
    /**
     * List of known `package.json` fields which provide information about
     * supported package formats and their associated entry paths.
     */
    const knownFormatPackageJsonFormatFields = ['main', 'fesm2020', 'esm2020', 'es2020', 'typings', 'module', 'fesm2015'];
    function main(args) {
        // Exit immediately when encountering an error.
        shx.set('-e');
        // This utility expects all of its arguments to be specified in a params file generated by
        // bazel (see https://docs.bazel.build/versions/master/skylark/lib/Args.html#use_param_file).
        const paramFilePath = args[0];
        // Bazel params may be surrounded with quotes
        function unquoteParameter(s) {
            return s.replace(/^'(.*)'$/, '$1');
        }
        // Parameters are specified in the file one per line.
        const params = fs.readFileSync(paramFilePath, 'utf-8').split('\n').map(unquoteParameter);
        const [
        // Output directory for the npm package.
        outputDirExecPath, 
        // The package segment of the ng_package rule's label (e.g. 'package/common').
        owningPackageName, 
        // JSON data capturing metadata of the package being built. See `PackageMetadata`.
        metadataArg, 
        // Path to the package's README.md.
        readmeMd, 
        // List of rolled-up flat ES2020 modules
        fesm2020Arg, 
        // List of individual ES2020 modules
        esm2020Arg, 
        // List of rolled-up flat ES2015 modules
        fesm2015Arg, 
        // List of all files in the ng_package rule's `srcs` attribute.
        srcsArg, 
        // List of all type definitions that need to packaged into the ng_package.
        typeDefinitionsArg, 
        // List of all files in the ng_package rule's data.
        dataArg, 
        // Path to the package's LICENSE.
        licenseFile, 
        // List of all dts bundles generated by the API extractor.
        dtsBundleArg, 
        // The dts bundle file suffix example: '.bundle.d.ts'
        dtsBundleFileSuffix,] = params;
        const fesm2020 = JSON.parse(fesm2020Arg);
        const esm2020 = JSON.parse(esm2020Arg);
        const fesm2015 = JSON.parse(fesm2015Arg);
        const typeDefinitions = JSON.parse(typeDefinitionsArg);
        const srcs = JSON.parse(srcsArg);
        const dataFiles = JSON.parse(dataArg);
        const metadata = JSON.parse(metadataArg);
        const dtsBundles = JSON.parse(dtsBundleArg);
        if (readmeMd) {
            copyFile(readmeMd, 'README.md');
        }
        /**
         * Writes a file with the specified content into the package output.
         * @param outputRelativePath Relative path in the output directory where the
         *   file is written to.
         * @param fileContent Content of the file.
         */
        function writeFile(outputRelativePath, fileContent) {
            const outputPath = path.join(outputDirExecPath, outputRelativePath);
            // Always ensure that the target directory exists.
            shx.mkdir('-p', path.dirname(outputPath));
            fs.writeFileSync(outputPath, fileContent);
        }
        /**
         * Copies a file into the package output to the specified location.
         * @param inputPath File that should be copied.
         * @param outputRelativePath Relative path in the output directory where the
         *   file is written to.
         */
        function copyFile(inputPath, outputRelativePath) {
            const fileContent = fs.readFileSync(inputPath, 'utf8');
            writeFile(outputRelativePath, fileContent);
        }
        /**
         * Gets the relative path for the given file within the owning package. This
         * assumes the file is contained in the owning package.
         *
         * e.g. consider the owning package is `packages/core` and the input file
         * is `packages/core/testing/index.d.ts`. This function would return the
         * relative path as followed: `testing/index.d.ts`.
         */
        function getOwningPackageRelativePath(file) {
            return path.relative(owningPackageName, file.shortPath);
        }
        /** Writes an ESM file into the `esm2020` output directory. */
        function writeEsm2020File(file) {
            // Note: files which do not belong to the owning package of this `ng_package` are omitted.
            // this prevents us from accidentally bringing in transitive node module dependencies.
            const packageRelativePath = getOwningPackageRelativePath(file);
            if (!packageRelativePath.startsWith('..')) {
                copyFile(file.path, getEsm2020OutputRelativePath(file));
            }
        }
        /** Gets the output-relative path where the given flat ESM file should be written to. */
        function getFlatEsmOutputRelativePath(file) {
            // Flat ESM files should be put into their owning package relative sub-path. e.g. if
            // there is a bundle in `packages/animations/fesm2020/browser/testing.mjs` then we
            // want the bundle to be stored in `fesm2020/browser/testing.mjs`. Same thing applies
            // for the `fesm2015` bundles. The directory name for `fesm` is already declared as
            // part of the Bazel action generating these files. See `ng_package.bzl`.
            return getOwningPackageRelativePath(file);
        }
        /** Gets the output-relative path where a non-flat ESM2020 file should be written to. */
        function getEsm2020OutputRelativePath(file) {
            // Path computed relative to the current package in bazel-bin. e.g. a ES2020 output file
            // in `bazel-out/<..>/packages/core/src/di.mjs` should be stored in `esm2020/src/di.mjs`.
            return path.join('esm2020', getOwningPackageRelativePath(file));
        }
        /** Gets the output-relative path where the typing file is being written to. */
        function getTypingOutputRelativePath(file) {
            // Type definitions are intended to be copied into the package output while preserving the
            // sub-path from the owning package. e.g. a file like `packages/animations/browser/index.d.ts`
            // will end up being written to `<pkg-out>/browser/index.d.ts`
            return getOwningPackageRelativePath(file);
        }
        /**
         * Gets the entry-point sub-path from the package root. e.g. if the package name
         * is `@angular/cdk`, then for `@angular/cdk/a11y` just `a11y` would be returned.
         */
        function getEntryPointSubpath(moduleName) {
            return moduleName.substr(`${metadata.npmPackageName}/`.length);
        }
        /**
         * Gets whether the given module name resolves to a secondary entry-point.
         * e.g. if the package name is `@angular/cdk`, then for `@angular/cdk/a11y`
         * this would return `true`.
         */
        function isSecondaryEntryPoint(moduleName) {
            return getEntryPointSubpath(moduleName) !== '';
        }
        esm2020.forEach(file => writeEsm2020File(file));
        // Copy all FESM files into the package output.
        fesm2020.forEach(f => copyFile(f.path, getFlatEsmOutputRelativePath(f)));
        fesm2015.forEach(f => copyFile(f.path, getFlatEsmOutputRelativePath(f)));
        // Copy all type definitions into the package, preserving the sub-path from the
        // owning package. e.g. a file like `packages/animations/browser/index.d.ts` will
        // end up in `browser/index.d.ts`
        typeDefinitions.forEach(f => writeFile(getTypingOutputRelativePath(f), readTypingsAndStripAmdModule(f.path)));
        // Copy all `data` files into the package, preserving the sub-path from the owning
        // package. These are files that aren't built by the ng_package rule, but instead are
        // just straight copied into the package, e.g. global CSS assets or migration JSON file.
        dataFiles.forEach(f => copyFile(f.path, getOwningPackageRelativePath(f)));
        const licenseBanner = licenseFile ? fs.readFileSync(licenseFile, 'utf8') : '';
        dtsBundles.forEach(bundleDtsFile => {
            // We copy the `d.ts` bundles while preserving the sub-path from the owning
            // package. e.g. `packages/animations/animations.bundle.d.ts` will end up being
            // copied into `<pkg-out>/animations.d.ts`. Notice how the `.bundle` suffix
            // has been removed. The `ng_module` appends this to avoid conflicts with the
            // actual typings files being generated by the TS/Angular compilation.
            const outputRelativePath = getTypingOutputRelativePath(bundleDtsFile).replace(dtsBundleFileSuffix, '.d.ts');
            // API extractor will not dedupe license comments from various files
            // this will remove all the license comments and append the license banner.
            const content = licenseBanner + '\n' +
                readTypingsAndStripAmdModule(bundleDtsFile.path)
                    .replace(/(\/\*\*\s+\*\s\@license(((?!\*\/).|\s)*)\*\/)/gm, '');
            writeFile(outputRelativePath, content);
        });
        const modulesWithExistingPackageJson = new Set();
        for (const srcFile of srcs) {
            // We copy all source files into the package output while preserving the sub-path from
            // the owning package. e.g. `packages/core/package.json` ends up `<pkg-out>/package.json`.
            const outputRelativePath = getOwningPackageRelativePath(srcFile);
            let content = fs.readFileSync(srcFile.path, 'utf8');
            // Modify package.json files as necessary for publishing
            if (path.basename(srcFile.path) === 'package.json') {
                const isPrimaryPackageJson = outputRelativePath === 'package.json';
                const sourcePackageJson = JSON.parse(content);
                const packageName = sourcePackageJson['name'];
                // Check if the `name` field of the `package.json` files are matching with
                // name of the NPM package. This is an additional safety check.
                if (isPrimaryPackageJson && packageName !== metadata.npmPackageName) {
                    throw Error(`Primary "package.json" has mismatching package name. Expected the ` +
                        `package to be named "${metadata.npmPackageName}", but is set to: ${packageName}.`);
                }
                if (!isPrimaryPackageJson && !packageName.startsWith(`${metadata.npmPackageName}/`)) {
                    throw Error(`Found a "package.json" which does not start with the name of the primary ` +
                        `entry-point. Secondary entry-points need to start with "${metadata.npmPackageName}/", ` +
                        `but is set to: ${packageName}.`);
                }
                let newPackageJson = insertFormatFieldsIntoPackageJson(outputRelativePath, sourcePackageJson, false);
                if (isPrimaryPackageJson) {
                    newPackageJson = updatePrimaryPackageJson(newPackageJson);
                }
                // Keep track of the modules we have `package.json` files provided as part of
                // the sources. We use this later to skip generation of `package.json` files
                // for the modules the consumer already created a file.
                modulesWithExistingPackageJson.add(packageName);
                // Update the content with the new `package.json` file content.
                content = JSON.stringify(newPackageJson, null, 2);
            }
            writeFile(outputRelativePath, content);
        }
        // Generate extra files for secondary entry-points.
        Object.keys(metadata.entryPoints).forEach(moduleName => {
            if (!isSecondaryEntryPoint(moduleName)) {
                return;
            }
            // If there is a `package.json` already defined as part of the sources,
            // skip generation of the secondary `package.json` file.
            if (modulesWithExistingPackageJson.has(moduleName)) {
                return;
            }
            const packageJsonDir = getEntryPointSubpath(moduleName);
            createSecondaryEntryPointPackageJson(packageJsonDir, moduleName);
        });
        /**
         * Inserts or edits properties into the package.json file(s) in the package so that
         * they point to all the right generated artifacts.
         *
         * @param packageJsonOutRelativePath Path where the `package.json` is stored in
         *   the package output.
         * @param parsedPackage Parsed package.json content
         * @param isGeneratedPackageJson Whether the passed package.json has been generated.
         */
        function insertFormatFieldsIntoPackageJson(packageJsonOutRelativePath, parsedPackage, isGeneratedPackageJson) {
            const packageJson = Object.assign({}, parsedPackage);
            const packageName = packageJson['name'];
            const entryPointInfo = metadata.entryPoints[packageName];
            const packageJsonContainingDir = path.dirname(packageJsonOutRelativePath);
            // If a package json file has been discovered that does not match any
            // entry-point in the metadata, we report a warning as most likely the target
            // is configured incorrectly (e.g. missing `module_name` attribute).
            if (!entryPointInfo) {
                // Ideally we should throw here, as we got an entry point that doesn't
                // have flat module metadata / bundle index, so it may have been an
                // ng_module that's missing a module_name attribute.
                // However, @angular/compiler can't be an ng_module, as it's the internals
                // of the ngc compiler, yet we want to build an ng_package for it.
                // So ignore package.json files when we are missing data.
                console.error('WARNING: no module metadata for package', packageName);
                console.error('   Not updating the package.json file to point to it');
                console.error('   The ng_module for this package is possibly missing the module_name attribute ');
                return packageJson;
            }
            // If we guessed the index paths for a module, and it contains an explicit `package.json`
            // file that already sets format properties, we skip automatic insertion of format
            // properties but report a warning in case properties have been set by accident.
            if (entryPointInfo.guessedPaths && !isGeneratedPackageJson &&
                hasExplicitFormatProperties(packageJson)) {
                console.error('WARNING: `package.json` explicitly sets format properties (like `main`).');
                console.error('    Skipping automatic insertion of format properties as explicit ' +
                    'format properties are set.');
                console.error('    Ignore this warning if explicit properties are set intentionally.');
                return packageJson;
            }
            const fesm2020RelativeOutPath = getFlatEsmOutputRelativePath(entryPointInfo.fesm2020Bundle);
            const fesm2015RelativeOutPath = getFlatEsmOutputRelativePath(entryPointInfo.fesm2015Bundle);
            const esm2020RelativeOutPath = getEsm2020OutputRelativePath(entryPointInfo.index);
            const typingsRelativeOutPath = getTypingOutputRelativePath(entryPointInfo.typings);
            packageJson.fesm2020 =
                normalizePath(path.relative(packageJsonContainingDir, fesm2020RelativeOutPath));
            packageJson.fesm2015 =
                normalizePath(path.relative(packageJsonContainingDir, fesm2015RelativeOutPath));
            packageJson.esm2020 =
                normalizePath(path.relative(packageJsonContainingDir, esm2020RelativeOutPath));
            packageJson.typings =
                normalizePath(path.relative(packageJsonContainingDir, typingsRelativeOutPath));
            // For now, we point the primary entry points at the fesm files, because of Webpack
            // performance issues with a large number of individual files.
            packageJson.module = packageJson.fesm2015;
            packageJson.es2020 = packageJson.fesm2020;
            return packageJson;
        }
        /**
         * Updates the primary `package.json` file of the NPM package to specify
         * the module conditional exports and the ESM module type.
         */
        function updatePrimaryPackageJson(packageJson) {
            if (packageJson.type !== undefined) {
                throw Error('The primary "package.json" file of the package sets the "type" field ' +
                    'that is controlled by the packager. Please unset it.');
            }
            const newPackageJson = Object.assign({}, packageJson);
            newPackageJson.type = 'module';
            // The `package.json` file is made publicly accessible for tools that
            // might want to query information from the Angular NPM package.
            insertExportMappingOrError(newPackageJson, './package.json', { default: './package.json' });
            // Capture all entry-points in the `exports` field using the subpath export declarations:
            // https://nodejs.org/api/packages.html#packages_subpath_exports.
            for (const [moduleName, entryPoint] of Object.entries(metadata.entryPoints)) {
                const subpath = isSecondaryEntryPoint(moduleName) ? `./${getEntryPointSubpath(moduleName)}` : '.';
                const esm2020IndexOutRelativePath = getEsm2020OutputRelativePath(entryPoint.index);
                const fesm2020OutRelativePath = getFlatEsmOutputRelativePath(entryPoint.fesm2020Bundle);
                const fesm2015OutRelativePath = getFlatEsmOutputRelativePath(entryPoint.fesm2015Bundle);
                const typesOutRelativePath = getTypingOutputRelativePath(entryPoint.typings);
                // Insert the export mapping for the entry-point. We set `default` to the FESM 2020
                // output, and also set the `types` condition which will be respected by TS 4.5.
                // https://github.com/microsoft/TypeScript/pull/45884.
                insertExportMappingOrError(newPackageJson, subpath, {
                    types: normalizePath(typesOutRelativePath),
                    esm2020: normalizePath(esm2020IndexOutRelativePath),
                    es2020: normalizePath(fesm2020OutRelativePath),
                    // We also expose a non-standard condition that would allow consumers to resolve
                    // to the `ES2015` output outside of NodeJS, if desired.
                    // TODO(devversion): remove/replace this if NodeJS v12 is no longer supported.
                    es2015: normalizePath(fesm2015OutRelativePath),
                    // We declare the `node` condition and point to the ES2015 output as we currently still
                    // support NodeJS v12 which does not fully support ES2020 output. We chose ES2015 over
                    // ES2020 because we wan async/await downleveled as this allows for patching withZoneJS.
                    // TODO(devversion): remove/replace this if NodeJS v12 is no longer supported.
                    node: normalizePath(fesm2015OutRelativePath),
                    // Note: The default conditions needs to be the last one.
                    default: normalizePath(fesm2020OutRelativePath),
                });
            }
            return newPackageJson;
        }
        /**
         * Inserts a subpath export mapping into the specified `package.json` object.
         * @throws An error if the mapping is already defined and would conflict.
         */
        function insertExportMappingOrError(packageJson, subpath, mapping) {
            if (packageJson.exports === undefined) {
                packageJson.exports = {};
            }
            if (packageJson.exports[subpath] === undefined) {
                packageJson.exports[subpath] = {};
            }
            const subpathExport = packageJson.exports[subpath];
            // Go through all conditions that should be inserted. If the condition is already
            // manually set of the subpath export, we throw an error. In general, we allow for
            // additional conditions to be set. These will always precede the generated ones.
            for (const conditionName of Object.keys(mapping)) {
                if (subpathExport[conditionName] !== undefined) {
                    throw Error(`Found a conflicting export condition for "${subpath}". The "${conditionName}" ` +
                        `condition would be overridden by the packager. Please unset it.`);
                }
                // **Note**: The order of the conditions is preserved even though we are setting
                // the conditions once at a time (the latest assignment will be at the end).
                subpathExport[conditionName] = mapping[conditionName];
            }
        }
        /** Whether the package explicitly sets any of the format properties (like `main`). */
        function hasExplicitFormatProperties(parsedPackage) {
            return Object.keys(parsedPackage)
                .some((fieldName) => knownFormatPackageJsonFormatFields.includes(fieldName));
        }
        /**
         * Creates a package.json for a secondary entry-point.
         * @param dir The directory under which the package.json should be written.
         * @param entryPointPackageName The full package name for the entry point,
         *     e.g. '@angular/common/http'.
         */
        function createSecondaryEntryPointPackageJson(dir, entryPointPackageName) {
            const relativeOutPath = path.join(dir, 'package.json');
            const content = insertFormatFieldsIntoPackageJson(relativeOutPath, { name: entryPointPackageName }, true);
            writeFile(relativeOutPath, JSON.stringify(content, null, 2));
        }
        /**
         * Normalizes the specified path by replacing backslash separators with Posix
         * forward slash separators.
         */
        function normalizePath(path) {
            const result = path.replace(/\\/g, '/');
            return result.startsWith('.') ? result : `./${result}`;
        }
        /**
         * Strip the named AMD module for compatibility with non-bazel users from typings content
         * @param filePath dts file path
         */
        function readTypingsAndStripAmdModule(filePath) {
            return fs
                .readFileSync(filePath, 'utf-8')
                // Strip the named AMD module for compatibility with non-bazel users
                .replace(/^\/\/\/ <amd-module name=.*\/>[\r\n]+/gm, '');
        }
    }
    if (require.main === module) {
        main(process.argv.slice(2));
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFja2FnZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9iYXplbC9zcmMvbmdfcGFja2FnZS9wYWNrYWdlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7Ozs7Ozs7Ozs7OztJQUVILHlCQUF5QjtJQUN6Qiw2QkFBNkI7SUFDN0IsK0JBQStCO0lBdUMvQjs7O09BR0c7SUFDSCxNQUFNLGtDQUFrQyxHQUNwQyxDQUFDLE1BQU0sRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLFVBQVUsQ0FBVSxDQUFDO0lBMkJ4RixTQUFTLElBQUksQ0FBQyxJQUFjO1FBQzFCLCtDQUErQztRQUMvQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRWQsMEZBQTBGO1FBQzFGLDZGQUE2RjtRQUM3RixNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFOUIsNkNBQTZDO1FBQzdDLFNBQVMsZ0JBQWdCLENBQUMsQ0FBUztZQUNqQyxPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ3JDLENBQUM7UUFFRCxxREFBcUQ7UUFDckQsTUFBTSxNQUFNLEdBQUcsRUFBRSxDQUFDLFlBQVksQ0FBQyxhQUFhLEVBQUUsT0FBTyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1FBRXpGLE1BQU07UUFDRix3Q0FBd0M7UUFDeEMsaUJBQWlCO1FBRWpCLDhFQUE4RTtRQUM5RSxpQkFBaUI7UUFFakIsa0ZBQWtGO1FBQ2xGLFdBQVc7UUFFWCxtQ0FBbUM7UUFDbkMsUUFBUTtRQUVSLHdDQUF3QztRQUN4QyxXQUFXO1FBRVgsb0NBQW9DO1FBQ3BDLFVBQVU7UUFFVix3Q0FBd0M7UUFDeEMsV0FBVztR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LENBQUM7WUFDeEMsT0FBTyxNQUFNLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssTUFBTSxFQUFFLENBQUM7UUFDekQsQ0FBQztRQUVEOzs7V0FHRztRQUNILFNBQVMsNEJBQTRCLENBQUMsUUFBZ0I7WUFDcEQsT0FBTyxFQUFFO2lCQUNKLFlBQVksQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDO2dCQUNoQyxvRUFBb0U7aUJBQ25FLE9BQU8sQ0FBQyx5Q0FBeUMsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUM5RCxDQUFDO0lBQ0gsQ0FBQztJQUVELElBQUksT0FBTyxDQUFDLElBQUksS0FBSyxNQUFNLEVBQUU7UUFDM0IsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDN0IiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCAqIGFzIHNoeCBmcm9tICdzaGVsbGpzJztcblxuLyoqXG4gKiBJbnRlcmZhY2UgZGVzY3JpYmluZyBhIGZpbGUgY2FwdHVyZWQgaW4gdGhlIEJhemVsIGFjdGlvbi5cbiAqIGh0dHBzOi8vZG9jcy5iYXplbC5idWlsZC92ZXJzaW9ucy9tYWluL3NreWxhcmsvbGliL0ZpbGUuaHRtbC5cbiAqL1xuaW50ZXJmYWNlIEJhemVsRmlsZUluZm8ge1xuICAvKiogRXhlY3Jvb3QtcmVsYXRpdmUgcGF0aCBwb2ludGluZyB0byB0aGUgZmlsZS4gKi9cbiAgcGF0aDogc3RyaW5nO1xuICAvKiogVGhlIHBhdGggb2YgdGhpcyBmaWxlIHJlbGF0aXZlIHRvIGl0cyByb290LiBlLmcuIG9taXR0aW5nIGBiYXplbC1vdXQvPC4uPi9iaW5gLiAqL1xuICBzaG9ydFBhdGg6IHN0cmluZztcbn1cblxuLyoqIEludGVyZmFjZSBkZXNjcmliaW5nIGFuIGVudHJ5LXBvaW50LiAqL1xuaW50ZXJmYWNlIEVudHJ5UG9pbnRJbmZvIHtcbiAgLyoqIEVTMjAyMCBpbmRleCBmaWxlIGZvciB0aGUgQVBGIGVudHJ5LXBvaW50LiAqL1xuICBpbmRleDogQmF6ZWxGaWxlSW5mbztcbiAgLyoqIEZsYXQgRVMyMDIwIEVTIG1vZHVsZSBidW5kbGUgZmlsZS4gKi9cbiAgZmVzbTIwMjBCdW5kbGU6IEJhemVsRmlsZUluZm87XG4gIC8qKiBGbGF0IEVTMjAxNSBFUyBtb2R1bGUgYnVuZGxlIGZpbGUuICovXG4gIGZlc20yMDE1QnVuZGxlOiBCYXplbEZpbGVJbmZvO1xuICAvKiogSW5kZXggdHlwZSBkZWZpbml0aW9uIGZpbGUgZm9yIHRoZSBBUEYgZW50cnktcG9pbnQuICovXG4gIHR5cGluZ3M6IEJhemVsRmlsZUluZm87XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBpbmRleCBvciB0eXBpbmcgcGF0aHMgaGF2ZSBiZWVuIGd1ZXNzZWQuIEZvciBlbnRyeS1wb2ludHMgYnVpbHRcbiAgICogdGhyb3VnaCBgdHNfbGlicmFyeWAsIHRoZXJlIGlzIG5vIGV4cGxpY2l0IHNldHRpbmcgdGhhdCBkZWNsYXJlcyB0aGUgZW50cnktcG9pbnRcbiAgICogc28gdGhlIGluZGV4IGZpbGUgaXMgZ3Vlc3NlZC5cbiAgICovXG4gIGd1ZXNzZWRQYXRoczogYm9vbGVhbjtcbn1cblxuLyoqIEludGVyZmFjZSBjYXB0dXJpbmcgcmVsZXZhbnQgbWV0YWRhdGEgZm9yIHBhY2thZ2luZy4gKi9cbmludGVyZmFjZSBQYWNrYWdlTWV0YWRhdGEge1xuICAvKiogTlBNIHBhY2thZ2UgbmFtZSBvZiB0aGUgb3V0cHV0LiAqL1xuICBucG1QYWNrYWdlTmFtZTogc3RyaW5nO1xuICAvKiogUmVjb3JkIG9mIGVudHJ5LXBvaW50cyAoaW5jbHVkaW5nIHRoZSBwcmltYXJ5IG9uZSkgYW5kIHRoZWlyIGluZm8uICovXG4gIGVudHJ5UG9pbnRzOiBSZWNvcmQ8c3RyaW5nLCBFbnRyeVBvaW50SW5mbz47XG59XG5cbi8qKlxuICogTGlzdCBvZiBrbm93biBgcGFja2FnZS5qc29uYCBmaWVsZHMgd2hpY2ggcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dFxuICogc3VwcG9ydGVkIHBhY2thZ2UgZm9ybWF0cyBhbmQgdGhlaXIgYXNzb2NpYXRlZCBlbnRyeSBwYXRocy5cbiAqL1xuY29uc3Qga25vd25Gb3JtYXRQYWNrYWdlSnNvbkZvcm1hdEZpZWxkcyA9XG4gICAgWydtYWluJywgJ2Zlc20yMDIwJywgJ2VzbTIwMjAnLCAnZXMyMDIwJywgJ3R5cGluZ3MnLCAnbW9kdWxlJywgJ2Zlc20yMDE1J10gYXMgY29uc3Q7XG5cbi8qKiBVbmlvbiB0eXBlIG1hdGNoaW5nIGtub3duIGBwYWNrYWdlLmpzb25gIGZvcm1hdCBmaWVsZHMuICovXG50eXBlIEtub3duUGFja2FnZUpzb25Gb3JtYXRGaWVsZHMgPSB0eXBlb2Yga25vd25Gb3JtYXRQYWNrYWdlSnNvbkZvcm1hdEZpZWxkc1tudW1iZXJdO1xuXG4vKipcbiAqIFR5cGUgZGVzY3JpYmluZyB0aGUgY29uZGl0aW9uYWwgZXhwb3J0cyBkZXNjcmlwdG9yIGZvciBhbiBlbnRyeS1wb2ludC5cbiAqIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvcGFja2FnZXMuaHRtbCNwYWNrYWdlc19jb25kaXRpb25hbF9leHBvcnRzXG4gKi9cbnR5cGUgQ29uZGl0aW9uYWxFeHBvcnQgPSB7XG4gIG5vZGU/OiBzdHJpbmc7XG4gIHR5cGVzPzogc3RyaW5nO1xuICBlc20yMDIwPzogc3RyaW5nO1xuICBlczIwMjA/OiBzdHJpbmc7XG4gIGVzMjAxNT86IHN0cmluZztcbiAgZGVmYXVsdD86IHN0cmluZztcbn07XG5cbi8qKiBUeXBlIGRlc2NyaWJpbmcgYSBgcGFja2FnZS5qc29uYCB0aGUgcGFja2FnZXIgZGVhbHMgd2l0aC4gKi9cbnR5cGUgUGFja2FnZUpzb24gPSB7XG4gIFtrZXkgaW4gS25vd25QYWNrYWdlSnNvbkZvcm1hdEZpZWxkc10/OiBzdHJpbmdcbn0me1xuICBuYW1lOiBzdHJpbmc7XG4gIHR5cGU/OiBzdHJpbmc7XG4gIGV4cG9ydHM/OiBSZWNvcmQ8c3RyaW5nLCBDb25kaXRpb25hbEV4cG9ydD47XG59O1xuXG5mdW5jdGlvbiBtYWluKGFyZ3M6IHN0cmluZ1tdKTogdm9pZCB7XG4gIC8vIEV4aXQgaW1tZWRpYXRlbHkgd2hlbiBlbmNvdW50ZXJpbmcgYW4gZXJyb3IuXG4gIHNoeC5zZXQoJy1lJyk7XG5cbiAgLy8gVGhpcyB1dGlsaXR5IGV4cGVjdHMgYWxsIG9mIGl0cyBhcmd1bWVudHMgdG8gYmUgc3BlY2lmaWVkIGluIGEgcGFyYW1zIGZpbGUgZ2VuZXJhdGVkIGJ5XG4gIC8vIGJhemVsIChzZWUgaHR0cHM6Ly9kb2NzLmJhemVsLmJ1aWxkL3ZlcnNpb25zL21hc3Rlci9za3lsYXJrL2xpYi9BcmdzLmh0bWwjdXNlX3BhcmFtX2ZpbGUpLlxuICBjb25zdCBwYXJhbUZpbGVQYXRoID0gYXJnc1swXTtcblxuICAvLyBCYXplbCBwYXJhbXMgbWF5IGJlIHN1cnJvdW5kZWQgd2l0aCBxdW90ZXNcbiAgZnVuY3Rpb24gdW5xdW90ZVBhcmFtZXRlcihzOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKC9eJyguKiknJC8sICckMScpO1xuICB9XG5cbiAgLy8gUGFyYW1ldGVycyBhcmUgc3BlY2lmaWVkIGluIHRoZSBmaWxlIG9uZSBwZXIgbGluZS5cbiAgY29uc3QgcGFyYW1zID0gZnMucmVhZEZpbGVTeW5jKHBhcmFtRmlsZVBhdGgsICd1dGYtOCcpLnNwbGl0KCdcXG4nKS5tYXAodW5xdW90ZVBhcmFtZXRlcik7XG5cbiAgY29uc3QgW1xuICAgICAgLy8gT3V0cHV0IGRpcmVjdG9yeSBmb3IgdGhlIG5wbSBwYWNrYWdlLlxuICAgICAgb3V0cHV0RGlyRXhlY1BhdGgsXG5cbiAgICAgIC8vIFRoZSBwYWNrYWdlIHNlZ21lbnQgb2YgdGhlIG5nX3BhY2thZ2UgcnVsZSdzIGxhYmVsIChlLmcuICdwYWNrYWdlL2NvbW1vbicpLlxuICAgICAgb3duaW5nUGFja2FnZU5hbWUsXG5cbiAgICAgIC8vIEpTT04gZGF0YSBjYXB0dXJpbmcgbWV0YWRhdGEgb2YgdGhlIHBhY2thZ2UgYmVpbmcgYnVpbHQuIFNlZSBgUGFja2FnZU1ldGFkYXRhYC5cbiAgICAgIG1ldGFkYXRhQXJnLFxuXG4gICAgICAvLyBQYXRoIHRvIHRoZSBwYWNrYWdlJ3MgUkVBRE1FLm1kLlxuICAgICAgcmVhZG1lTWQsXG5cbiAgICAgIC8vIExpc3Qgb2Ygcm9sbGVkLXVwIGZsYXQgRVMyMDIwIG1vZHVsZXNcbiAgICAgIGZlc20yMDIwQXJnLFxuXG4gICAgICAvLyBMaXN0IG9mIGluZGl2aWR1YWwgRVMyMDIwIG1vZHVsZXNcbiAgICAgIGVzbTIwMjBBcmcsXG5cbiAgICAgIC8vIExpc3Qgb2Ygcm9sbGVkLXVwIGZsYXQgRVMyMDE1IG1vZHVsZXNcbiAgICAgIGZlc20yMDE1QXJnLFxuXG4gICAgICAvLyBMaXN0IG9mIGFsbCBmaWxlcyBpbiB0aGUgbmdfcGFja2FnZSBydWxlJ3MgYHNyY3NgIGF0dHJpYnV0ZS5cbiAgICAgIHNyY3NBcmcsXG5cbiAgICAgIC8vIExpc3Qgb2YgYWxsIHR5cGUgZGVmaW5pdGlvbnMgdGhhdCBuZWVkIHRvIHBhY2thZ2VkIGludG8gdGhlIG5nX3BhY2thZ2UuXG4gICAgICB0eXBlRGVmaW5pdGlvbnNBcmcsXG5cbiAgICAgIC8vIExpc3Qgb2YgYWxsIGZpbGVzIGluIHRoZSBuZ19wYWNrYWdlIHJ1bGUncyBkYXRhLlxuICAgICAgZGF0YUFyZyxcblxuICAgICAgLy8gUGF0aCB0byB0aGUgcGFja2FnZSdzIExJQ0VOU0UuXG4gICAgICBsaWNlbnNlRmlsZSxcblxuICAgICAgLy8gTGlzdCBvZiBhbGwgZHRzIGJ1bmRsZXMgZ2VuZXJhdGVkIGJ5IHRoZSBBUEkgZXh0cmFjdG9yLlxuICAgICAgZHRzQnVuZGxlQXJnLFxuXG4gICAgICAvLyBUaGUgZHRzIGJ1bmRsZSBmaWxlIHN1ZmZpeCBleGFtcGxlOiAnLmJ1bmRsZS5kLnRzJ1xuICAgICAgZHRzQnVuZGxlRmlsZVN1ZmZpeCxcbiAgXSA9IHBhcmFtcztcblxuICBjb25zdCBmZXNtMjAyMCA9IEpTT04ucGFyc2UoZmVzbTIwMjBBcmcpIGFzIEJhemVsRmlsZUluZm9bXTtcbiAgY29uc3QgZXNtMjAyMCA9IEpTT04ucGFyc2UoZXNtMjAyMEFyZykgYXMgQmF6ZWxGaWxlSW5mb1tdO1xuICBjb25zdCBmZXNtMjAxNSA9IEpTT04ucGFyc2UoZmVzbTIwMTVBcmcpIGFzIEJhemVsRmlsZUluZm9bXTtcbiAgY29uc3QgdHlwZURlZmluaXRpb25zID0gSlNPTi5wYXJzZSh0eXBlRGVmaW5pdGlvbnNBcmcpIGFzIEJhemVsRmlsZUluZm9bXTtcbiAgY29uc3Qgc3JjcyA9IEpTT04ucGFyc2Uoc3Jjc0FyZykgYXMgQmF6ZWxGaWxlSW5mb1tdO1xuICBjb25zdCBkYXRhRmlsZXMgPSBKU09OLnBhcnNlKGRhdGFBcmcpIGFzIEJhemVsRmlsZUluZm9bXTtcbiAgY29uc3QgbWV0YWRhdGEgPSBKU09OLnBhcnNlKG1ldGFkYXRhQXJnKSBhcyBQYWNrYWdlTWV0YWRhdGE7XG4gIGNvbnN0IGR0c0J1bmRsZXMgPSBKU09OLnBhcnNlKGR0c0J1bmRsZUFyZykgYXMgQmF6ZWxGaWxlSW5mb1tdO1xuXG4gIGlmIChyZWFkbWVNZCkge1xuICAgIGNvcHlGaWxlKHJlYWRtZU1kLCAnUkVBRE1FLm1kJyk7XG4gIH1cblxuICAvKipcbiAgICogV3JpdGVzIGEgZmlsZSB3aXRoIHRoZSBzcGVjaWZpZWQgY29udGVudCBpbnRvIHRoZSBwYWNrYWdlIG91dHB1dC5cbiAgICogQHBhcmFtIG91dHB1dFJlbGF0aXZlUGF0aCBSZWxhdGl2ZSBwYXRoIGluIHRoZSBvdXRwdXQgZGlyZWN0b3J5IHdoZXJlIHRoZVxuICAgKiAgIGZpbGUgaXMgd3JpdHRlbiB0by5cbiAgICogQHBhcmFtIGZpbGVDb250ZW50IENvbnRlbnQgb2YgdGhlIGZpbGUuXG4gICAqL1xuICBmdW5jdGlvbiB3cml0ZUZpbGUob3V0cHV0UmVsYXRpdmVQYXRoOiBzdHJpbmcsIGZpbGVDb250ZW50OiBzdHJpbmd8QnVmZmVyKSB7XG4gICAgY29uc3Qgb3V0cHV0UGF0aCA9IHBhdGguam9pbihvdXRwdXREaXJFeGVjUGF0aCwgb3V0cHV0UmVsYXRpdmVQYXRoKTtcblxuICAgIC8vIEFsd2F5cyBlbnN1cmUgdGhhdCB0aGUgdGFyZ2V0IGRpcmVjdG9yeSBleGlzdHMuXG4gICAgc2h4Lm1rZGlyKCctcCcsIHBhdGguZGlybmFtZShvdXRwdXRQYXRoKSk7XG4gICAgZnMud3JpdGVGaWxlU3luYyhvdXRwdXRQYXRoLCBmaWxlQ29udGVudCk7XG4gIH1cblxuICAvKipcbiAgICogQ29waWVzIGEgZmlsZSBpbnRvIHRoZSBwYWNrYWdlIG91dHB1dCB0byB0aGUgc3BlY2lmaWVkIGxvY2F0aW9uLlxuICAgKiBAcGFyYW0gaW5wdXRQYXRoIEZpbGUgdGhhdCBzaG91bGQgYmUgY29waWVkLlxuICAgKiBAcGFyYW0gb3V0cHV0UmVsYXRpdmVQYXRoIFJlbGF0aXZlIHBhdGggaW4gdGhlIG91dHB1dCBkaXJlY3Rvcnkgd2hlcmUgdGhlXG4gICAqICAgZmlsZSBpcyB3cml0dGVuIHRvLlxuICAgKi9cbiAgZnVuY3Rpb24gY29weUZpbGUoaW5wdXRQYXRoOiBzdHJpbmcsIG91dHB1dFJlbGF0aXZlUGF0aDogc3RyaW5nKSB7XG4gICAgY29uc3QgZmlsZUNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoaW5wdXRQYXRoLCAndXRmOCcpO1xuICAgIHdyaXRlRmlsZShvdXRwdXRSZWxhdGl2ZVBhdGgsIGZpbGVDb250ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSByZWxhdGl2ZSBwYXRoIGZvciB0aGUgZ2l2ZW4gZmlsZSB3aXRoaW4gdGhlIG93bmluZyBwYWNrYWdlLiBUaGlzXG4gICAqIGFzc3VtZXMgdGhlIGZpbGUgaXMgY29udGFpbmVkIGluIHRoZSBvd25pbmcgcGFja2FnZS5cbiAgICpcbiAgICogZS5nLiBjb25zaWRlciB0aGUgb3duaW5nIHBhY2thZ2UgaXMgYHBhY2thZ2VzL2NvcmVgIGFuZCB0aGUgaW5wdXQgZmlsZVxuICAgKiBpcyBgcGFja2FnZXMvY29yZS90ZXN0aW5nL2luZGV4LmQudHNgLiBUaGlzIGZ1bmN0aW9uIHdvdWxkIHJldHVybiB0aGVcbiAgICogcmVsYXRpdmUgcGF0aCBhcyBmb2xsb3dlZDogYHRlc3RpbmcvaW5kZXguZC50c2AuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRPd25pbmdQYWNrYWdlUmVsYXRpdmVQYXRoKGZpbGU6IEJhemVsRmlsZUluZm8pOiBzdHJpbmcge1xuICAgIHJldHVybiBwYXRoLnJlbGF0aXZlKG93bmluZ1BhY2thZ2VOYW1lLCBmaWxlLnNob3J0UGF0aCk7XG4gIH1cblxuICAvKiogV3JpdGVzIGFuIEVTTSBmaWxlIGludG8gdGhlIGBlc20yMDIwYCBvdXRwdXQgZGlyZWN0b3J5LiAqL1xuICBmdW5jdGlvbiB3cml0ZUVzbTIwMjBGaWxlKGZpbGU6IEJhemVsRmlsZUluZm8pIHtcbiAgICAvLyBOb3RlOiBmaWxlcyB3aGljaCBkbyBub3QgYmVsb25nIHRvIHRoZSBvd25pbmcgcGFja2FnZSBvZiB0aGlzIGBuZ19wYWNrYWdlYCBhcmUgb21pdHRlZC5cbiAgICAvLyB0aGlzIHByZXZlbnRzIHVzIGZyb20gYWNjaWRlbnRhbGx5IGJyaW5naW5nIGluIHRyYW5zaXRpdmUgbm9kZSBtb2R1bGUgZGVwZW5kZW5jaWVzLlxuICAgIGNvbnN0IHBhY2thZ2VSZWxhdGl2ZVBhdGggPSBnZXRPd25pbmdQYWNrYWdlUmVsYXRpdmVQYXRoKGZpbGUpO1xuICAgIGlmICghcGFja2FnZVJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKCcuLicpKSB7XG4gICAgICBjb3B5RmlsZShmaWxlLnBhdGgsIGdldEVzbTIwMjBPdXRwdXRSZWxhdGl2ZVBhdGgoZmlsZSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBHZXRzIHRoZSBvdXRwdXQtcmVsYXRpdmUgcGF0aCB3aGVyZSB0aGUgZ2l2ZW4gZmxhdCBFU00gZmlsZSBzaG91bGQgYmUgd3JpdHRlbiB0by4gKi9cbiAgZnVuY3Rpb24gZ2V0RmxhdEVzbU91dHB1dFJlbGF0aXZlUGF0aChmaWxlOiBCYXplbEZpbGVJbmZvKSB7XG4gICAgLy8gRmxhdCBFU00gZmlsZXMgc2hvdWxkIGJlIHB1dCBpbnRvIHRoZWlyIG93bmluZyBwYWNrYWdlIHJlbGF0aXZlIHN1Yi1wYXRoLiBlLmcuIGlmXG4gICAgLy8gdGhlcmUgaXMgYSBidW5kbGUgaW4gYHBhY2thZ2VzL2FuaW1hdGlvbnMvZmVzbTIwMjAvYnJvd3Nlci90ZXN0aW5nLm1qc2AgdGhlbiB3ZVxuICAgIC8vIHdhbnQgdGhlIGJ1bmRsZSB0byBiZSBzdG9yZWQgaW4gYGZlc20yMDIwL2Jyb3dzZXIvdGVzdGluZy5tanNgLiBTYW1lIHRoaW5nIGFwcGxpZXNcbiAgICAvLyBmb3IgdGhlIGBmZXNtMjAxNWAgYnVuZGxlcy4gVGhlIGRpcmVjdG9yeSBuYW1lIGZvciBgZmVzbWAgaXMgYWxyZWFkeSBkZWNsYXJlZCBhc1xuICAgIC8vIHBhcnQgb2YgdGhlIEJhemVsIGFjdGlvbiBnZW5lcmF0aW5nIHRoZXNlIGZpbGVzLiBTZWUgYG5nX3BhY2thZ2UuYnpsYC5cbiAgICByZXR1cm4gZ2V0T3duaW5nUGFja2FnZVJlbGF0aXZlUGF0aChmaWxlKTtcbiAgfVxuXG4gIC8qKiBHZXRzIHRoZSBvdXRwdXQtcmVsYXRpdmUgcGF0aCB3aGVyZSBhIG5vbi1mbGF0IEVTTTIwMjAgZmlsZSBzaG91bGQgYmUgd3JpdHRlbiB0by4gKi9cbiAgZnVuY3Rpb24gZ2V0RXNtMjAyME91dHB1dFJlbGF0aXZlUGF0aChmaWxlOiBCYXplbEZpbGVJbmZvKSB7XG4gICAgLy8gUGF0aCBjb21wdXRlZCByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBwYWNrYWdlIGluIGJhemVsLWJpbi4gZS5nLiBhIEVTMjAyMCBvdXRwdXQgZmlsZVxuICAgIC8vIGluIGBiYXplbC1vdXQvPC4uPi9wYWNrYWdlcy9jb3JlL3NyYy9kaS5tanNgIHNob3VsZCBiZSBzdG9yZWQgaW4gYGVzbTIwMjAvc3JjL2RpLm1qc2AuXG4gICAgcmV0dXJuIHBhdGguam9pbignZXNtMjAyMCcsIGdldE93bmluZ1BhY2thZ2VSZWxhdGl2ZVBhdGgoZmlsZSkpO1xuICB9XG5cbiAgLyoqIEdldHMgdGhlIG91dHB1dC1yZWxhdGl2ZSBwYXRoIHdoZXJlIHRoZSB0eXBpbmcgZmlsZSBpcyBiZWluZyB3cml0dGVuIHRvLiAqL1xuICBmdW5jdGlvbiBnZXRUeXBpbmdPdXRwdXRSZWxhdGl2ZVBhdGgoZmlsZTogQmF6ZWxGaWxlSW5mbykge1xuICAgIC8vIFR5cGUgZGVmaW5pdGlvbnMgYXJlIGludGVuZGVkIHRvIGJlIGNvcGllZCBpbnRvIHRoZSBwYWNrYWdlIG91dHB1dCB3aGlsZSBwcmVzZXJ2aW5nIHRoZVxuICAgIC8vIHN1Yi1wYXRoIGZyb20gdGhlIG93bmluZyBwYWNrYWdlLiBlLmcuIGEgZmlsZSBsaWtlIGBwYWNrYWdlcy9hbmltYXRpb25zL2Jyb3dzZXIvaW5kZXguZC50c2BcbiAgICAvLyB3aWxsIGVuZCB1cCBiZWluZyB3cml0dGVuIHRvIGA8cGtnLW91dD4vYnJvd3Nlci9pbmRleC5kLnRzYFxuICAgIHJldHVybiBnZXRPd25pbmdQYWNrYWdlUmVsYXRpdmVQYXRoKGZpbGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGVudHJ5LXBvaW50IHN1Yi1wYXRoIGZyb20gdGhlIHBhY2thZ2Ugcm9vdC4gZS5nLiBpZiB0aGUgcGFja2FnZSBuYW1lXG4gICAqIGlzIGBAYW5ndWxhci9jZGtgLCB0aGVuIGZvciBgQGFuZ3VsYXIvY2RrL2ExMXlgIGp1c3QgYGExMXlgIHdvdWxkIGJlIHJldHVybmVkLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0RW50cnlQb2ludFN1YnBhdGgobW9kdWxlTmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gbW9kdWxlTmFtZS5zdWJzdHIoYCR7bWV0YWRhdGEubnBtUGFja2FnZU5hbWV9L2AubGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHdoZXRoZXIgdGhlIGdpdmVuIG1vZHVsZSBuYW1lIHJlc29sdmVzIHRvIGEgc2Vjb25kYXJ5IGVudHJ5LXBvaW50LlxuICAgKiBlLmcuIGlmIHRoZSBwYWNrYWdlIG5hbWUgaXMgYEBhbmd1bGFyL2Nka2AsIHRoZW4gZm9yIGBAYW5ndWxhci9jZGsvYTExeWBcbiAgICogdGhpcyB3b3VsZCByZXR1cm4gYHRydWVgLlxuICAgKi9cbiAgZnVuY3Rpb24gaXNTZWNvbmRhcnlFbnRyeVBvaW50KG1vZHVsZU5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBnZXRFbnRyeVBvaW50U3VicGF0aChtb2R1bGVOYW1lKSAhPT0gJyc7XG4gIH1cblxuICBlc20yMDIwLmZvckVhY2goZmlsZSA9PiB3cml0ZUVzbTIwMjBGaWxlKGZpbGUpKTtcblxuICAvLyBDb3B5IGFsbCBGRVNNIGZpbGVzIGludG8gdGhlIHBhY2thZ2Ugb3V0cHV0LlxuICBmZXNtMjAyMC5mb3JFYWNoKGYgPT4gY29weUZpbGUoZi5wYXRoLCBnZXRGbGF0RXNtT3V0cHV0UmVsYXRpdmVQYXRoKGYpKSk7XG4gIGZlc20yMDE1LmZvckVhY2goZiA9PiBjb3B5RmlsZShmLnBhdGgsIGdldEZsYXRFc21PdXRwdXRSZWxhdGl2ZVBhdGgoZikpKTtcblxuICAvLyBDb3B5IGFsbCB0eXBlIGRlZmluaXRpb25zIGludG8gdGhlIHBhY2thZ2UsIHByZXNlcnZpbmcgdGhlIHN1Yi1wYXRoIGZyb20gdGhlXG4gIC8vIG93bmluZyBwYWNrYWdlLiBlLmcuIGEgZmlsZSBsaWtlIGBwYWNrYWdlcy9hbmltYXRpb25zL2Jyb3dzZXIvaW5kZXguZC50c2Agd2lsbFxuICAvLyBlbmQgdXAgaW4gYGJyb3dzZXIvaW5kZXguZC50c2BcbiAgdHlwZURlZmluaXRpb25zLmZvckVhY2goXG4gICAgICBmID0+IHdyaXRlRmlsZShnZXRUeXBpbmdPdXRwdXRSZWxhdGl2ZVBhdGgoZiksIHJlYWRUeXBpbmdzQW5kU3RyaXBBbWRNb2R1bGUoZi5wYXRoKSkpO1xuXG4gIC8vIENvcHkgYWxsIGBkYXRhYCBmaWxlcyBpbnRvIHRoZSBwYWNrYWdlLCBwcmVzZXJ2aW5nIHRoZSBzdWItcGF0aCBmcm9tIHRoZSBvd25pbmdcbiAgLy8gcGFja2FnZS4gVGhlc2UgYXJlIGZpbGVzIHRoYXQgYXJlbid0IGJ1aWx0IGJ5IHRoZSBuZ19wYWNrYWdlIHJ1bGUsIGJ1dCBpbnN0ZWFkIGFyZVxuICAvLyBqdXN0IHN0cmFpZ2h0IGNvcGllZCBpbnRvIHRoZSBwYWNrYWdlLCBlLmcuIGdsb2JhbCBDU1MgYXNzZXRzIG9yIG1pZ3JhdGlvbiBKU09OIGZpbGUuXG4gIGRhdGFGaWxlcy5mb3JFYWNoKGYgPT4gY29weUZpbGUoZi5wYXRoLCBnZXRPd25pbmdQYWNrYWdlUmVsYXRpdmVQYXRoKGYpKSk7XG5cbiAgY29uc3QgbGljZW5zZUJhbm5lciA9IGxpY2Vuc2VGaWxlID8gZnMucmVhZEZpbGVTeW5jKGxpY2Vuc2VGaWxlLCAndXRmOCcpIDogJyc7XG5cbiAgZHRzQnVuZGxlcy5mb3JFYWNoKGJ1bmRsZUR0c0ZpbGUgPT4ge1xuICAgIC8vIFdlIGNvcHkgdGhlIGBkLnRzYCBidW5kbGVzIHdoaWxlIHByZXNlcnZpbmcgdGhlIHN1Yi1wYXRoIGZyb20gdGhlIG93bmluZ1xuICAgIC8vIHBhY2thZ2UuIGUuZy4gYHBhY2thZ2VzL2FuaW1hdGlvbnMvYW5pbWF0aW9ucy5idW5kbGUuZC50c2Agd2lsbCBlbmQgdXAgYmVpbmdcbiAgICAvLyBjb3BpZWQgaW50byBgPHBrZy1vdXQ+L2FuaW1hdGlvbnMuZC50c2AuIE5vdGljZSBob3cgdGhlIGAuYnVuZGxlYCBzdWZmaXhcbiAgICAvLyBoYXMgYmVlbiByZW1vdmVkLiBUaGUgYG5nX21vZHVsZWAgYXBwZW5kcyB0aGlzIHRvIGF2b2lkIGNvbmZsaWN0cyB3aXRoIHRoZVxuICAgIC8vIGFjdHVhbCB0eXBpbmdzIGZpbGVzIGJlaW5nIGdlbmVyYXRlZCBieSB0aGUgVFMvQW5ndWxhciBjb21waWxhdGlvbi5cbiAgICBjb25zdCBvdXRwdXRSZWxhdGl2ZVBhdGggPVxuICAgICAgICBnZXRUeXBpbmdPdXRwdXRSZWxhdGl2ZVBhdGgoYnVuZGxlRHRzRmlsZSkucmVwbGFjZShkdHNCdW5kbGVGaWxlU3VmZml4LCAnLmQudHMnKTtcbiAgICAvLyBBUEkgZXh0cmFjdG9yIHdpbGwgbm90IGRlZHVwZSBsaWNlbnNlIGNvbW1lbnRzIGZyb20gdmFyaW91cyBmaWxlc1xuICAgIC8vIHRoaXMgd2lsbCByZW1vdmUgYWxsIHRoZSBsaWNlbnNlIGNvbW1lbnRzIGFuZCBhcHBlbmQgdGhlIGxpY2Vuc2UgYmFubmVyLlxuICAgIGNvbnN0IGNvbnRlbnQgPSBsaWNlbnNlQmFubmVyICsgJ1xcbicgK1xuICAgICAgICByZWFkVHlwaW5nc0FuZFN0cmlwQW1kTW9kdWxlKGJ1bmRsZUR0c0ZpbGUucGF0aClcbiAgICAgICAgICAgIC5yZXBsYWNlKC8oXFwvXFwqXFwqXFxzK1xcKlxcc1xcQGxpY2Vuc2UoKCg/IVxcKlxcLykufFxccykqKVxcKlxcLykvZ20sICcnKTtcblxuICAgIHdyaXRlRmlsZShvdXRwdXRSZWxhdGl2ZVBhdGgsIGNvbnRlbnQpO1xuICB9KTtcblxuICBjb25zdCBtb2R1bGVzV2l0aEV4aXN0aW5nUGFja2FnZUpzb24gPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICBmb3IgKGNvbnN0IHNyY0ZpbGUgb2Ygc3Jjcykge1xuICAgIC8vIFdlIGNvcHkgYWxsIHNvdXJjZSBmaWxlcyBpbnRvIHRoZSBwYWNrYWdlIG91dHB1dCB3aGlsZSBwcmVzZXJ2aW5nIHRoZSBzdWItcGF0aCBmcm9tXG4gICAgLy8gdGhlIG93bmluZyBwYWNrYWdlLiBlLmcuIGBwYWNrYWdlcy9jb3JlL3BhY2thZ2UuanNvbmAgZW5kcyB1cCBgPHBrZy1vdXQ+L3BhY2thZ2UuanNvbmAuXG4gICAgY29uc3Qgb3V0cHV0UmVsYXRpdmVQYXRoID0gZ2V0T3duaW5nUGFja2FnZVJlbGF0aXZlUGF0aChzcmNGaWxlKTtcbiAgICBsZXQgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhzcmNGaWxlLnBhdGgsICd1dGY4Jyk7XG5cbiAgICAvLyBNb2RpZnkgcGFja2FnZS5qc29uIGZpbGVzIGFzIG5lY2Vzc2FyeSBmb3IgcHVibGlzaGluZ1xuICAgIGlmIChwYXRoLmJhc2VuYW1lKHNyY0ZpbGUucGF0aCkgPT09ICdwYWNrYWdlLmpzb24nKSB7XG4gICAgICBjb25zdCBpc1ByaW1hcnlQYWNrYWdlSnNvbiA9IG91dHB1dFJlbGF0aXZlUGF0aCA9PT0gJ3BhY2thZ2UuanNvbic7XG4gICAgICBjb25zdCBzb3VyY2VQYWNrYWdlSnNvbiA9IEpTT04ucGFyc2UoY29udGVudCkgYXMgUGFja2FnZUpzb247XG4gICAgICBjb25zdCBwYWNrYWdlTmFtZSA9IHNvdXJjZVBhY2thZ2VKc29uWyduYW1lJ107XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBgbmFtZWAgZmllbGQgb2YgdGhlIGBwYWNrYWdlLmpzb25gIGZpbGVzIGFyZSBtYXRjaGluZyB3aXRoXG4gICAgICAvLyBuYW1lIG9mIHRoZSBOUE0gcGFja2FnZS4gVGhpcyBpcyBhbiBhZGRpdGlvbmFsIHNhZmV0eSBjaGVjay5cbiAgICAgIGlmIChpc1ByaW1hcnlQYWNrYWdlSnNvbiAmJiBwYWNrYWdlTmFtZSAhPT0gbWV0YWRhdGEubnBtUGFja2FnZU5hbWUpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBgUHJpbWFyeSBcInBhY2thZ2UuanNvblwiIGhhcyBtaXNtYXRjaGluZyBwYWNrYWdlIG5hbWUuIEV4cGVjdGVkIHRoZSBgICtcbiAgICAgICAgICAgIGBwYWNrYWdlIHRvIGJlIG5hbWVkIFwiJHttZXRhZGF0YS5ucG1QYWNrYWdlTmFtZX1cIiwgYnV0IGlzIHNldCB0bzogJHtwYWNrYWdlTmFtZX0uYCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNQcmltYXJ5UGFja2FnZUpzb24gJiYgIXBhY2thZ2VOYW1lLnN0YXJ0c1dpdGgoYCR7bWV0YWRhdGEubnBtUGFja2FnZU5hbWV9L2ApKSB7XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgYEZvdW5kIGEgXCJwYWNrYWdlLmpzb25cIiB3aGljaCBkb2VzIG5vdCBzdGFydCB3aXRoIHRoZSBuYW1lIG9mIHRoZSBwcmltYXJ5IGAgK1xuICAgICAgICAgICAgYGVudHJ5LXBvaW50LiBTZWNvbmRhcnkgZW50cnktcG9pbnRzIG5lZWQgdG8gc3RhcnQgd2l0aCBcIiR7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEubnBtUGFja2FnZU5hbWV9L1wiLCBgICtcbiAgICAgICAgICAgIGBidXQgaXMgc2V0IHRvOiAke3BhY2thZ2VOYW1lfS5gKTtcbiAgICAgIH1cblxuICAgICAgbGV0IG5ld1BhY2thZ2VKc29uID1cbiAgICAgICAgICBpbnNlcnRGb3JtYXRGaWVsZHNJbnRvUGFja2FnZUpzb24ob3V0cHV0UmVsYXRpdmVQYXRoLCBzb3VyY2VQYWNrYWdlSnNvbiwgZmFsc2UpO1xuXG4gICAgICBpZiAoaXNQcmltYXJ5UGFja2FnZUpzb24pIHtcbiAgICAgICAgbmV3UGFja2FnZUpzb24gPSB1cGRhdGVQcmltYXJ5UGFja2FnZUpzb24obmV3UGFja2FnZUpzb24pO1xuICAgICAgfVxuXG4gICAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBtb2R1bGVzIHdlIGhhdmUgYHBhY2thZ2UuanNvbmAgZmlsZXMgcHJvdmlkZWQgYXMgcGFydCBvZlxuICAgICAgLy8gdGhlIHNvdXJjZXMuIFdlIHVzZSB0aGlzIGxhdGVyIHRvIHNraXAgZ2VuZXJhdGlvbiBvZiBgcGFja2FnZS5qc29uYCBmaWxlc1xuICAgICAgLy8gZm9yIHRoZSBtb2R1bGVzIHRoZSBjb25zdW1lciBhbHJlYWR5IGNyZWF0ZWQgYSBmaWxlLlxuICAgICAgbW9kdWxlc1dpdGhFeGlzdGluZ1BhY2thZ2VKc29uLmFkZChwYWNrYWdlTmFtZSk7XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgY29udGVudCB3aXRoIHRoZSBuZXcgYHBhY2thZ2UuanNvbmAgZmlsZSBjb250ZW50LlxuICAgICAgY29udGVudCA9IEpTT04uc3RyaW5naWZ5KG5ld1BhY2thZ2VKc29uLCBudWxsLCAyKTtcbiAgICB9XG5cbiAgICB3cml0ZUZpbGUob3V0cHV0UmVsYXRpdmVQYXRoLCBjb250ZW50KTtcbiAgfVxuXG4gIC8vIEdlbmVyYXRlIGV4dHJhIGZpbGVzIGZvciBzZWNvbmRhcnkgZW50cnktcG9pbnRzLlxuICBPYmplY3Qua2V5cyhtZXRhZGF0YS5lbnRyeVBvaW50cykuZm9yRWFjaChtb2R1bGVOYW1lID0+IHtcbiAgICBpZiAoIWlzU2Vjb25kYXJ5RW50cnlQb2ludChtb2R1bGVOYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGlzIGEgYHBhY2thZ2UuanNvbmAgYWxyZWFkeSBkZWZpbmVkIGFzIHBhcnQgb2YgdGhlIHNvdXJjZXMsXG4gICAgLy8gc2tpcCBnZW5lcmF0aW9uIG9mIHRoZSBzZWNvbmRhcnkgYHBhY2thZ2UuanNvbmAgZmlsZS5cbiAgICBpZiAobW9kdWxlc1dpdGhFeGlzdGluZ1BhY2thZ2VKc29uLmhhcyhtb2R1bGVOYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBhY2thZ2VKc29uRGlyID0gZ2V0RW50cnlQb2ludFN1YnBhdGgobW9kdWxlTmFtZSk7XG4gICAgY3JlYXRlU2Vjb25kYXJ5RW50cnlQb2ludFBhY2thZ2VKc29uKHBhY2thZ2VKc29uRGlyLCBtb2R1bGVOYW1lKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEluc2VydHMgb3IgZWRpdHMgcHJvcGVydGllcyBpbnRvIHRoZSBwYWNrYWdlLmpzb24gZmlsZShzKSBpbiB0aGUgcGFja2FnZSBzbyB0aGF0XG4gICAqIHRoZXkgcG9pbnQgdG8gYWxsIHRoZSByaWdodCBnZW5lcmF0ZWQgYXJ0aWZhY3RzLlxuICAgKlxuICAgKiBAcGFyYW0gcGFja2FnZUpzb25PdXRSZWxhdGl2ZVBhdGggUGF0aCB3aGVyZSB0aGUgYHBhY2thZ2UuanNvbmAgaXMgc3RvcmVkIGluXG4gICAqICAgdGhlIHBhY2thZ2Ugb3V0cHV0LlxuICAgKiBAcGFyYW0gcGFyc2VkUGFja2FnZSBQYXJzZWQgcGFja2FnZS5qc29uIGNvbnRlbnRcbiAgICogQHBhcmFtIGlzR2VuZXJhdGVkUGFja2FnZUpzb24gV2hldGhlciB0aGUgcGFzc2VkIHBhY2thZ2UuanNvbiBoYXMgYmVlbiBnZW5lcmF0ZWQuXG4gICAqL1xuICBmdW5jdGlvbiBpbnNlcnRGb3JtYXRGaWVsZHNJbnRvUGFja2FnZUpzb24oXG4gICAgICBwYWNrYWdlSnNvbk91dFJlbGF0aXZlUGF0aDogc3RyaW5nLCBwYXJzZWRQYWNrYWdlOiBSZWFkb25seTxQYWNrYWdlSnNvbj4sXG4gICAgICBpc0dlbmVyYXRlZFBhY2thZ2VKc29uOiBib29sZWFuKTogUGFja2FnZUpzb24ge1xuICAgIGNvbnN0IHBhY2thZ2VKc29uOiBQYWNrYWdlSnNvbiA9IHsuLi5wYXJzZWRQYWNrYWdlfTtcbiAgICBjb25zdCBwYWNrYWdlTmFtZSA9IHBhY2thZ2VKc29uWyduYW1lJ107XG4gICAgY29uc3QgZW50cnlQb2ludEluZm8gPSBtZXRhZGF0YS5lbnRyeVBvaW50c1twYWNrYWdlTmFtZV07XG4gICAgY29uc3QgcGFja2FnZUpzb25Db250YWluaW5nRGlyID0gcGF0aC5kaXJuYW1lKHBhY2thZ2VKc29uT3V0UmVsYXRpdmVQYXRoKTtcblxuICAgIC8vIElmIGEgcGFja2FnZSBqc29uIGZpbGUgaGFzIGJlZW4gZGlzY292ZXJlZCB0aGF0IGRvZXMgbm90IG1hdGNoIGFueVxuICAgIC8vIGVudHJ5LXBvaW50IGluIHRoZSBtZXRhZGF0YSwgd2UgcmVwb3J0IGEgd2FybmluZyBhcyBtb3N0IGxpa2VseSB0aGUgdGFyZ2V0XG4gICAgLy8gaXMgY29uZmlndXJlZCBpbmNvcnJlY3RseSAoZS5nLiBtaXNzaW5nIGBtb2R1bGVfbmFtZWAgYXR0cmlidXRlKS5cbiAgICBpZiAoIWVudHJ5UG9pbnRJbmZvKSB7XG4gICAgICAvLyBJZGVhbGx5IHdlIHNob3VsZCB0aHJvdyBoZXJlLCBhcyB3ZSBnb3QgYW4gZW50cnkgcG9pbnQgdGhhdCBkb2Vzbid0XG4gICAgICAvLyBoYXZlIGZsYXQgbW9kdWxlIG1ldGFkYXRhIC8gYnVuZGxlIGluZGV4LCBzbyBpdCBtYXkgaGF2ZSBiZWVuIGFuXG4gICAgICAvLyBuZ19tb2R1bGUgdGhhdCdzIG1pc3NpbmcgYSBtb2R1bGVfbmFtZSBhdHRyaWJ1dGUuXG4gICAgICAvLyBIb3dldmVyLCBAYW5ndWxhci9jb21waWxlciBjYW4ndCBiZSBhbiBuZ19tb2R1bGUsIGFzIGl0J3MgdGhlIGludGVybmFsc1xuICAgICAgLy8gb2YgdGhlIG5nYyBjb21waWxlciwgeWV0IHdlIHdhbnQgdG8gYnVpbGQgYW4gbmdfcGFja2FnZSBmb3IgaXQuXG4gICAgICAvLyBTbyBpZ25vcmUgcGFja2FnZS5qc29uIGZpbGVzIHdoZW4gd2UgYXJlIG1pc3NpbmcgZGF0YS5cbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1dBUk5JTkc6IG5vIG1vZHVsZSBtZXRhZGF0YSBmb3IgcGFja2FnZScsIHBhY2thZ2VOYW1lKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyAgIE5vdCB1cGRhdGluZyB0aGUgcGFja2FnZS5qc29uIGZpbGUgdG8gcG9pbnQgdG8gaXQnKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgJyAgIFRoZSBuZ19tb2R1bGUgZm9yIHRoaXMgcGFja2FnZSBpcyBwb3NzaWJseSBtaXNzaW5nIHRoZSBtb2R1bGVfbmFtZSBhdHRyaWJ1dGUgJyk7XG4gICAgICByZXR1cm4gcGFja2FnZUpzb247XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZ3Vlc3NlZCB0aGUgaW5kZXggcGF0aHMgZm9yIGEgbW9kdWxlLCBhbmQgaXQgY29udGFpbnMgYW4gZXhwbGljaXQgYHBhY2thZ2UuanNvbmBcbiAgICAvLyBmaWxlIHRoYXQgYWxyZWFkeSBzZXRzIGZvcm1hdCBwcm9wZXJ0aWVzLCB3ZSBza2lwIGF1dG9tYXRpYyBpbnNlcnRpb24gb2YgZm9ybWF0XG4gICAgLy8gcHJvcGVydGllcyBidXQgcmVwb3J0IGEgd2FybmluZyBpbiBjYXNlIHByb3BlcnRpZXMgaGF2ZSBiZWVuIHNldCBieSBhY2NpZGVudC5cbiAgICBpZiAoZW50cnlQb2ludEluZm8uZ3Vlc3NlZFBhdGhzICYmICFpc0dlbmVyYXRlZFBhY2thZ2VKc29uICYmXG4gICAgICAgIGhhc0V4cGxpY2l0Rm9ybWF0UHJvcGVydGllcyhwYWNrYWdlSnNvbikpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1dBUk5JTkc6IGBwYWNrYWdlLmpzb25gIGV4cGxpY2l0bHkgc2V0cyBmb3JtYXQgcHJvcGVydGllcyAobGlrZSBgbWFpbmApLicpO1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAnICAgIFNraXBwaW5nIGF1dG9tYXRpYyBpbnNlcnRpb24gb2YgZm9ybWF0IHByb3BlcnRpZXMgYXMgZXhwbGljaXQgJyArXG4gICAgICAgICAgJ2Zvcm1hdCBwcm9wZXJ0aWVzIGFyZSBzZXQuJyk7XG4gICAgICBjb25zb2xlLmVycm9yKCcgICAgSWdub3JlIHRoaXMgd2FybmluZyBpZiBleHBsaWNpdCBwcm9wZXJ0aWVzIGFyZSBzZXQgaW50ZW50aW9uYWxseS4nKTtcbiAgICAgIHJldHVybiBwYWNrYWdlSnNvbjtcbiAgICB9XG5cbiAgICBjb25zdCBmZXNtMjAyMFJlbGF0aXZlT3V0UGF0aCA9IGdldEZsYXRFc21PdXRwdXRSZWxhdGl2ZVBhdGgoZW50cnlQb2ludEluZm8uZmVzbTIwMjBCdW5kbGUpO1xuICAgIGNvbnN0IGZlc20yMDE1UmVsYXRpdmVPdXRQYXRoID0gZ2V0RmxhdEVzbU91dHB1dFJlbGF0aXZlUGF0aChlbnRyeVBvaW50SW5mby5mZXNtMjAxNUJ1bmRsZSk7XG4gICAgY29uc3QgZXNtMjAyMFJlbGF0aXZlT3V0UGF0aCA9IGdldEVzbTIwMjBPdXRwdXRSZWxhdGl2ZVBhdGgoZW50cnlQb2ludEluZm8uaW5kZXgpO1xuICAgIGNvbnN0IHR5cGluZ3NSZWxhdGl2ZU91dFBhdGggPSBnZXRUeXBpbmdPdXRwdXRSZWxhdGl2ZVBhdGgoZW50cnlQb2ludEluZm8udHlwaW5ncyk7XG5cbiAgICBwYWNrYWdlSnNvbi5mZXNtMjAyMCA9XG4gICAgICAgIG5vcm1hbGl6ZVBhdGgocGF0aC5yZWxhdGl2ZShwYWNrYWdlSnNvbkNvbnRhaW5pbmdEaXIsIGZlc20yMDIwUmVsYXRpdmVPdXRQYXRoKSk7XG4gICAgcGFja2FnZUpzb24uZmVzbTIwMTUgPVxuICAgICAgICBub3JtYWxpemVQYXRoKHBhdGgucmVsYXRpdmUocGFja2FnZUpzb25Db250YWluaW5nRGlyLCBmZXNtMjAxNVJlbGF0aXZlT3V0UGF0aCkpO1xuICAgIHBhY2thZ2VKc29uLmVzbTIwMjAgPVxuICAgICAgICBub3JtYWxpemVQYXRoKHBhdGgucmVsYXRpdmUocGFja2FnZUpzb25Db250YWluaW5nRGlyLCBlc20yMDIwUmVsYXRpdmVPdXRQYXRoKSk7XG4gICAgcGFja2FnZUpzb24udHlwaW5ncyA9XG4gICAgICAgIG5vcm1hbGl6ZVBhdGgocGF0aC5yZWxhdGl2ZShwYWNrYWdlSnNvbkNvbnRhaW5pbmdEaXIsIHR5cGluZ3NSZWxhdGl2ZU91dFBhdGgpKTtcblxuICAgIC8vIEZvciBub3csIHdlIHBvaW50IHRoZSBwcmltYXJ5IGVudHJ5IHBvaW50cyBhdCB0aGUgZmVzbSBmaWxlcywgYmVjYXVzZSBvZiBXZWJwYWNrXG4gICAgLy8gcGVyZm9ybWFuY2UgaXNzdWVzIHdpdGggYSBsYXJnZSBudW1iZXIgb2YgaW5kaXZpZHVhbCBmaWxlcy5cbiAgICBwYWNrYWdlSnNvbi5tb2R1bGUgPSBwYWNrYWdlSnNvbi5mZXNtMjAxNTtcbiAgICBwYWNrYWdlSnNvbi5lczIwMjAgPSBwYWNrYWdlSnNvbi5mZXNtMjAyMDtcblxuICAgIHJldHVybiBwYWNrYWdlSnNvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBwcmltYXJ5IGBwYWNrYWdlLmpzb25gIGZpbGUgb2YgdGhlIE5QTSBwYWNrYWdlIHRvIHNwZWNpZnlcbiAgICogdGhlIG1vZHVsZSBjb25kaXRpb25hbCBleHBvcnRzIGFuZCB0aGUgRVNNIG1vZHVsZSB0eXBlLlxuICAgKi9cbiAgZnVuY3Rpb24gdXBkYXRlUHJpbWFyeVBhY2thZ2VKc29uKHBhY2thZ2VKc29uOiBSZWFkb25seTxQYWNrYWdlSnNvbj4pOiBQYWNrYWdlSnNvbiB7XG4gICAgaWYgKHBhY2thZ2VKc29uLnR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgJ1RoZSBwcmltYXJ5IFwicGFja2FnZS5qc29uXCIgZmlsZSBvZiB0aGUgcGFja2FnZSBzZXRzIHRoZSBcInR5cGVcIiBmaWVsZCAnICtcbiAgICAgICAgICAndGhhdCBpcyBjb250cm9sbGVkIGJ5IHRoZSBwYWNrYWdlci4gUGxlYXNlIHVuc2V0IGl0LicpO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld1BhY2thZ2VKc29uOiBQYWNrYWdlSnNvbiA9IHsuLi5wYWNrYWdlSnNvbn07XG5cbiAgICBuZXdQYWNrYWdlSnNvbi50eXBlID0gJ21vZHVsZSc7XG5cbiAgICAvLyBUaGUgYHBhY2thZ2UuanNvbmAgZmlsZSBpcyBtYWRlIHB1YmxpY2x5IGFjY2Vzc2libGUgZm9yIHRvb2xzIHRoYXRcbiAgICAvLyBtaWdodCB3YW50IHRvIHF1ZXJ5IGluZm9ybWF0aW9uIGZyb20gdGhlIEFuZ3VsYXIgTlBNIHBhY2thZ2UuXG4gICAgaW5zZXJ0RXhwb3J0TWFwcGluZ09yRXJyb3IobmV3UGFja2FnZUpzb24sICcuL3BhY2thZ2UuanNvbicsIHtkZWZhdWx0OiAnLi9wYWNrYWdlLmpzb24nfSk7XG5cbiAgICAvLyBDYXB0dXJlIGFsbCBlbnRyeS1wb2ludHMgaW4gdGhlIGBleHBvcnRzYCBmaWVsZCB1c2luZyB0aGUgc3VicGF0aCBleHBvcnQgZGVjbGFyYXRpb25zOlxuICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvcGFja2FnZXMuaHRtbCNwYWNrYWdlc19zdWJwYXRoX2V4cG9ydHMuXG4gICAgZm9yIChjb25zdCBbbW9kdWxlTmFtZSwgZW50cnlQb2ludF0gb2YgT2JqZWN0LmVudHJpZXMobWV0YWRhdGEuZW50cnlQb2ludHMpKSB7XG4gICAgICBjb25zdCBzdWJwYXRoID1cbiAgICAgICAgICBpc1NlY29uZGFyeUVudHJ5UG9pbnQobW9kdWxlTmFtZSkgPyBgLi8ke2dldEVudHJ5UG9pbnRTdWJwYXRoKG1vZHVsZU5hbWUpfWAgOiAnLic7XG4gICAgICBjb25zdCBlc20yMDIwSW5kZXhPdXRSZWxhdGl2ZVBhdGggPSBnZXRFc20yMDIwT3V0cHV0UmVsYXRpdmVQYXRoKGVudHJ5UG9pbnQuaW5kZXgpO1xuICAgICAgY29uc3QgZmVzbTIwMjBPdXRSZWxhdGl2ZVBhdGggPSBnZXRGbGF0RXNtT3V0cHV0UmVsYXRpdmVQYXRoKGVudHJ5UG9pbnQuZmVzbTIwMjBCdW5kbGUpO1xuICAgICAgY29uc3QgZmVzbTIwMTVPdXRSZWxhdGl2ZVBhdGggPSBnZXRGbGF0RXNtT3V0cHV0UmVsYXRpdmVQYXRoKGVudHJ5UG9pbnQuZmVzbTIwMTVCdW5kbGUpO1xuICAgICAgY29uc3QgdHlwZXNPdXRSZWxhdGl2ZVBhdGggPSBnZXRUeXBpbmdPdXRwdXRSZWxhdGl2ZVBhdGgoZW50cnlQb2ludC50eXBpbmdzKTtcblxuICAgICAgLy8gSW5zZXJ0IHRoZSBleHBvcnQgbWFwcGluZyBmb3IgdGhlIGVudHJ5LXBvaW50LiBXZSBzZXQgYGRlZmF1bHRgIHRvIHRoZSBGRVNNIDIwMjBcbiAgICAgIC8vIG91dHB1dCwgYW5kIGFsc28gc2V0IHRoZSBgdHlwZXNgIGNvbmRpdGlvbiB3aGljaCB3aWxsIGJlIHJlc3BlY3RlZCBieSBUUyA0LjUuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvcHVsbC80NTg4NC5cbiAgICAgIGluc2VydEV4cG9ydE1hcHBpbmdPckVycm9yKG5ld1BhY2thZ2VKc29uLCBzdWJwYXRoLCB7XG4gICAgICAgIHR5cGVzOiBub3JtYWxpemVQYXRoKHR5cGVzT3V0UmVsYXRpdmVQYXRoKSxcbiAgICAgICAgZXNtMjAyMDogbm9ybWFsaXplUGF0aChlc20yMDIwSW5kZXhPdXRSZWxhdGl2ZVBhdGgpLFxuICAgICAgICBlczIwMjA6IG5vcm1hbGl6ZVBhdGgoZmVzbTIwMjBPdXRSZWxhdGl2ZVBhdGgpLFxuICAgICAgICAvLyBXZSBhbHNvIGV4cG9zZSBhIG5vbi1zdGFuZGFyZCBjb25kaXRpb24gdGhhdCB3b3VsZCBhbGxvdyBjb25zdW1lcnMgdG8gcmVzb2x2ZVxuICAgICAgICAvLyB0byB0aGUgYEVTMjAxNWAgb3V0cHV0IG91dHNpZGUgb2YgTm9kZUpTLCBpZiBkZXNpcmVkLlxuICAgICAgICAvLyBUT0RPKGRldnZlcnNpb24pOiByZW1vdmUvcmVwbGFjZSB0aGlzIGlmIE5vZGVKUyB2MTIgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC5cbiAgICAgICAgZXMyMDE1OiBub3JtYWxpemVQYXRoKGZlc20yMDE1T3V0UmVsYXRpdmVQYXRoKSxcbiAgICAgICAgLy8gV2UgZGVjbGFyZSB0aGUgYG5vZGVgIGNvbmRpdGlvbiBhbmQgcG9pbnQgdG8gdGhlIEVTMjAxNSBvdXRwdXQgYXMgd2UgY3VycmVudGx5IHN0aWxsXG4gICAgICAgIC8vIHN1cHBvcnQgTm9kZUpTIHYxMiB3aGljaCBkb2VzIG5vdCBmdWxseSBzdXBwb3J0IEVTMjAyMCBvdXRwdXQuIFdlIGNob3NlIEVTMjAxNSBvdmVyXG4gICAgICAgIC8vIEVTMjAyMCBiZWNhdXNlIHdlIHdhbiBhc3luYy9hd2FpdCBkb3dubGV2ZWxlZCBhcyB0aGlzIGFsbG93cyBmb3IgcGF0Y2hpbmcgd2l0aFpvbmVKUy5cbiAgICAgICAgLy8gVE9ETyhkZXZ2ZXJzaW9uKTogcmVtb3ZlL3JlcGxhY2UgdGhpcyBpZiBOb2RlSlMgdjEyIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuXG4gICAgICAgIG5vZGU6IG5vcm1hbGl6ZVBhdGgoZmVzbTIwMTVPdXRSZWxhdGl2ZVBhdGgpLFxuICAgICAgICAvLyBOb3RlOiBUaGUgZGVmYXVsdCBjb25kaXRpb25zIG5lZWRzIHRvIGJlIHRoZSBsYXN0IG9uZS5cbiAgICAgICAgZGVmYXVsdDogbm9ybWFsaXplUGF0aChmZXNtMjAyME91dFJlbGF0aXZlUGF0aCksXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3UGFja2FnZUpzb247XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0cyBhIHN1YnBhdGggZXhwb3J0IG1hcHBpbmcgaW50byB0aGUgc3BlY2lmaWVkIGBwYWNrYWdlLmpzb25gIG9iamVjdC5cbiAgICogQHRocm93cyBBbiBlcnJvciBpZiB0aGUgbWFwcGluZyBpcyBhbHJlYWR5IGRlZmluZWQgYW5kIHdvdWxkIGNvbmZsaWN0LlxuICAgKi9cbiAgZnVuY3Rpb24gaW5zZXJ0RXhwb3J0TWFwcGluZ09yRXJyb3IoXG4gICAgICBwYWNrYWdlSnNvbjogUGFja2FnZUpzb24sIHN1YnBhdGg6IHN0cmluZywgbWFwcGluZzogQ29uZGl0aW9uYWxFeHBvcnQpIHtcbiAgICBpZiAocGFja2FnZUpzb24uZXhwb3J0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYWNrYWdlSnNvbi5leHBvcnRzID0ge307XG4gICAgfVxuICAgIGlmIChwYWNrYWdlSnNvbi5leHBvcnRzW3N1YnBhdGhdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhY2thZ2VKc29uLmV4cG9ydHNbc3VicGF0aF0gPSB7fTtcbiAgICB9XG5cbiAgICBjb25zdCBzdWJwYXRoRXhwb3J0ID0gcGFja2FnZUpzb24uZXhwb3J0c1tzdWJwYXRoXTtcblxuICAgIC8vIEdvIHRocm91Z2ggYWxsIGNvbmRpdGlvbnMgdGhhdCBzaG91bGQgYmUgaW5zZXJ0ZWQuIElmIHRoZSBjb25kaXRpb24gaXMgYWxyZWFkeVxuICAgIC8vIG1hbnVhbGx5IHNldCBvZiB0aGUgc3VicGF0aCBleHBvcnQsIHdlIHRocm93IGFuIGVycm9yLiBJbiBnZW5lcmFsLCB3ZSBhbGxvdyBmb3JcbiAgICAvLyBhZGRpdGlvbmFsIGNvbmRpdGlvbnMgdG8gYmUgc2V0LiBUaGVzZSB3aWxsIGFsd2F5cyBwcmVjZWRlIHRoZSBnZW5lcmF0ZWQgb25lcy5cbiAgICBmb3IgKGNvbnN0IGNvbmRpdGlvbk5hbWUgb2YgT2JqZWN0LmtleXMobWFwcGluZykgYXMgW2tleW9mIENvbmRpdGlvbmFsRXhwb3J0XSkge1xuICAgICAgaWYgKHN1YnBhdGhFeHBvcnRbY29uZGl0aW9uTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIGBGb3VuZCBhIGNvbmZsaWN0aW5nIGV4cG9ydCBjb25kaXRpb24gZm9yIFwiJHtzdWJwYXRofVwiLiBUaGUgXCIke2NvbmRpdGlvbk5hbWV9XCIgYCArXG4gICAgICAgICAgICBgY29uZGl0aW9uIHdvdWxkIGJlIG92ZXJyaWRkZW4gYnkgdGhlIHBhY2thZ2VyLiBQbGVhc2UgdW5zZXQgaXQuYCk7XG4gICAgICB9XG5cbiAgICAgIC8vICoqTm90ZSoqOiBUaGUgb3JkZXIgb2YgdGhlIGNvbmRpdGlvbnMgaXMgcHJlc2VydmVkIGV2ZW4gdGhvdWdoIHdlIGFyZSBzZXR0aW5nXG4gICAgICAvLyB0aGUgY29uZGl0aW9ucyBvbmNlIGF0IGEgdGltZSAodGhlIGxhdGVzdCBhc3NpZ25tZW50IHdpbGwgYmUgYXQgdGhlIGVuZCkuXG4gICAgICBzdWJwYXRoRXhwb3J0W2NvbmRpdGlvbk5hbWVdID0gbWFwcGluZ1tjb25kaXRpb25OYW1lXTtcbiAgICB9XG4gIH1cblxuICAvKiogV2hldGhlciB0aGUgcGFja2FnZSBleHBsaWNpdGx5IHNldHMgYW55IG9mIHRoZSBmb3JtYXQgcHJvcGVydGllcyAobGlrZSBgbWFpbmApLiAqL1xuICBmdW5jdGlvbiBoYXNFeHBsaWNpdEZvcm1hdFByb3BlcnRpZXMocGFyc2VkUGFja2FnZTogUmVhZG9ubHk8UGFja2FnZUpzb24+KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHBhcnNlZFBhY2thZ2UpXG4gICAgICAgIC5zb21lKFxuICAgICAgICAgICAgKGZpZWxkTmFtZTogS25vd25QYWNrYWdlSnNvbkZvcm1hdEZpZWxkcykgPT5cbiAgICAgICAgICAgICAgICBrbm93bkZvcm1hdFBhY2thZ2VKc29uRm9ybWF0RmllbGRzLmluY2x1ZGVzKGZpZWxkTmFtZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBwYWNrYWdlLmpzb24gZm9yIGEgc2Vjb25kYXJ5IGVudHJ5LXBvaW50LlxuICAgKiBAcGFyYW0gZGlyIFRoZSBkaXJlY3RvcnkgdW5kZXIgd2hpY2ggdGhlIHBhY2thZ2UuanNvbiBzaG91bGQgYmUgd3JpdHRlbi5cbiAgICogQHBhcmFtIGVudHJ5UG9pbnRQYWNrYWdlTmFtZSBUaGUgZnVsbCBwYWNrYWdlIG5hbWUgZm9yIHRoZSBlbnRyeSBwb2ludCxcbiAgICogICAgIGUuZy4gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJy5cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZVNlY29uZGFyeUVudHJ5UG9pbnRQYWNrYWdlSnNvbihkaXI6IHN0cmluZywgZW50cnlQb2ludFBhY2thZ2VOYW1lOiBzdHJpbmcpIHtcbiAgICBjb25zdCByZWxhdGl2ZU91dFBhdGggPSBwYXRoLmpvaW4oZGlyLCAncGFja2FnZS5qc29uJyk7XG4gICAgY29uc3QgY29udGVudCA9XG4gICAgICAgIGluc2VydEZvcm1hdEZpZWxkc0ludG9QYWNrYWdlSnNvbihyZWxhdGl2ZU91dFBhdGgsIHtuYW1lOiBlbnRyeVBvaW50UGFja2FnZU5hbWV9LCB0cnVlKTtcbiAgICB3cml0ZUZpbGUocmVsYXRpdmVPdXRQYXRoLCBKU09OLnN0cmluZ2lmeShjb250ZW50LCBudWxsLCAyKSk7XG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplcyB0aGUgc3BlY2lmaWVkIHBhdGggYnkgcmVwbGFjaW5nIGJhY2tzbGFzaCBzZXBhcmF0b3JzIHdpdGggUG9zaXhcbiAgICogZm9yd2FyZCBzbGFzaCBzZXBhcmF0b3JzLlxuICAgKi9cbiAgZnVuY3Rpb24gbm9ybWFsaXplUGF0aChwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhdGgucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuICAgIHJldHVybiByZXN1bHQuc3RhcnRzV2l0aCgnLicpID8gcmVzdWx0IDogYC4vJHtyZXN1bHR9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdHJpcCB0aGUgbmFtZWQgQU1EIG1vZHVsZSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1iYXplbCB1c2VycyBmcm9tIHR5cGluZ3MgY29udGVudFxuICAgKiBAcGFyYW0gZmlsZVBhdGggZHRzIGZpbGUgcGF0aFxuICAgKi9cbiAgZnVuY3Rpb24gcmVhZFR5cGluZ3NBbmRTdHJpcEFtZE1vZHVsZShmaWxlUGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gZnNcbiAgICAgICAgLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgJ3V0Zi04JylcbiAgICAgICAgLy8gU3RyaXAgdGhlIG5hbWVkIEFNRCBtb2R1bGUgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24tYmF6ZWwgdXNlcnNcbiAgICAgICAgLnJlcGxhY2UoL15cXC9cXC9cXC8gPGFtZC1tb2R1bGUgbmFtZT0uKlxcLz5bXFxyXFxuXSsvZ20sICcnKTtcbiAgfVxufVxuXG5pZiAocmVxdWlyZS5tYWluID09PSBtb2R1bGUpIHtcbiAgbWFpbihwcm9jZXNzLmFyZ3Yuc2xpY2UoMikpO1xufVxuIl19