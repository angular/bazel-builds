/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("angular/packages/bazel/src/ng_package/packager", ["require", "exports", "fs", "path", "shelljs"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const fs = require("fs");
    const path = require("path");
    const shx = require("shelljs");
    /**
     * List of known `package.json` fields which provide information about
     * supported package formats and their associated entry paths.
     */
    const knownFormatPackageJsonFormatFields = ['main', 'fesm2020', 'esm2020', 'es2020', 'typings', 'module', 'fesm2015'];
    function main(args) {
        // Exit immediately when encountering an error.
        shx.set('-e');
        // This utility expects all of its arguments to be specified in a params file generated by
        // bazel (see https://docs.bazel.build/versions/master/skylark/lib/Args.html#use_param_file).
        const paramFilePath = args[0];
        // Bazel params may be surrounded with quotes
        function unquoteParameter(s) {
            return s.replace(/^'(.*)'$/, '$1');
        }
        // Parameters are specified in the file one per line.
        const params = fs.readFileSync(paramFilePath, 'utf-8').split('\n').map(unquoteParameter);
        const [
        // Output directory for the npm package.
        outputDirExecPath, 
        // The package segment of the ng_package rule's label (e.g. 'package/common').
        owningPackageName, 
        // JSON data capturing metadata of the package being built. See `PackageMetadata`.
        metadataArg, 
        // Path to the package's README.md.
        readmeMd, 
        // List of rolled-up flat ES2020 modules
        fesm2020Arg, 
        // List of individual ES2020 modules
        esm2020Arg, 
        // List of rolled-up flat ES2015 modules
        fesm2015Arg, 
        // List of all files in the ng_package rule's `srcs` attribute.
        srcsArg, 
        // List of all type definitions that need to packaged into the ng_package.
        typeDefinitionsArg, 
        // List of all files in the ng_package rule's data.
        dataArg, 
        // Path to the package's LICENSE.
        licenseFile, 
        // List of all dts bundles generated by the API extractor.
        dtsBundleArg, 
        // The dts bundle file suffix example: '.bundle.d.ts'
        dtsBundleFileSuffix,] = params;
        const fesm2020 = JSON.parse(fesm2020Arg);
        const esm2020 = JSON.parse(esm2020Arg);
        const fesm2015 = JSON.parse(fesm2015Arg);
        const typeDefinitions = JSON.parse(typeDefinitionsArg);
        const srcs = JSON.parse(srcsArg);
        const dataFiles = JSON.parse(dataArg);
        const metadata = JSON.parse(metadataArg);
        const dtsBundles = JSON.parse(dtsBundleArg);
        if (readmeMd) {
            copyFile(readmeMd, 'README.md');
        }
        /**
         * Writes a file with the specified content into the package output.
         * @param outputRelativePath Relative path in the output directory where the
         *   file is written to.
         * @param fileContent Content of the file.
         */
        function writeFile(outputRelativePath, fileContent) {
            const outputPath = path.join(outputDirExecPath, outputRelativePath);
            // Always ensure that the target directory exists.
            shx.mkdir('-p', path.dirname(outputPath));
            fs.writeFileSync(outputPath, fileContent);
        }
        /**
         * Copies a file into the package output to the specified location.
         * @param inputPath File that should be copied.
         * @param outputRelativePath Relative path in the output directory where the
         *   file is written to.
         */
        function copyFile(inputPath, outputRelativePath) {
            const fileContent = fs.readFileSync(inputPath, 'utf8');
            writeFile(outputRelativePath, fileContent);
        }
        /**
         * Gets the relative path for the given file within the owning package. This
         * assumes the file is contained in the owning package.
         *
         * e.g. consider the owning package is `packages/core` and the input file
         * is `packages/core/testing/index.d.ts`. This function would return the
         * relative path as followed: `testing/index.d.ts`.
         */
        function getOwningPackageRelativePath(file) {
            return path.relative(owningPackageName, file.shortPath);
        }
        /** Writes an ESM file into the `esm2020` output directory. */
        function writeEsm2020File(file) {
            // Note: files which do not belong to the owning package of this `ng_package` are omitted.
            // this prevents us from accidentally bringing in transitive node module dependencies.
            const packageRelativePath = getOwningPackageRelativePath(file);
            if (!packageRelativePath.startsWith('..')) {
                copyFile(file.path, getEsm2020OutputRelativePath(file));
            }
        }
        /** Gets the output-relative path where the given flat ESM file should be written to. */
        function getFlatEsmOutputRelativePath(file) {
            // Flat ESM files should be put into their owning package relative sub-path. e.g. if
            // there is a bundle in `packages/animations/fesm2020/browser/testing.mjs` then we
            // want the bundle to be stored in `fesm2020/browser/testing.mjs`. Same thing applies
            // for the `fesm2015` bundles. The directory name for `fesm` is already declared as
            // part of the Bazel action generating these files. See `ng_package.bzl`.
            return getOwningPackageRelativePath(file);
        }
        /** Gets the output-relative path where a non-flat ESM2020 file should be written to. */
        function getEsm2020OutputRelativePath(file) {
            // Path computed relative to the current package in bazel-bin. e.g. a ES2020 output file
            // in `bazel-out/<..>/packages/core/src/di.mjs` should be stored in `esm2020/src/di.mjs`.
            return path.join('esm2020', getOwningPackageRelativePath(file));
        }
        /** Gets the output-relative path where the typing file is being written to. */
        function getTypingOutputRelativePath(file) {
            // Type definitions are intended to be copied into the package output while preserving the
            // sub-path from the owning package. e.g. a file like `packages/animations/browser/index.d.ts`
            // will end up being written to `<pkg-out>/browser/index.d.ts`
            return getOwningPackageRelativePath(file);
        }
        /**
         * Gets the entry-point sub-path from the package root. e.g. if the package name
         * is `@angular/cdk`, then for `@angular/cdk/a11y` just `a11y` would be returned.
         */
        function getEntryPointSubpath(moduleName) {
            return moduleName.substr(`${metadata.npmPackageName}/`.length);
        }
        /**
         * Gets whether the given module name resolves to a secondary entry-point.
         * e.g. if the package name is `@angular/cdk`, then for `@angular/cdk/a11y`
         * this would return `true`.
         */
        function isSecondaryEntryPoint(moduleName) {
            return getEntryPointSubpath(moduleName) !== '';
        }
        esm2020.forEach(file => writeEsm2020File(file));
        // Copy all FESM files into the package output.
        fesm2020.forEach(f => copyFile(f.path, getFlatEsmOutputRelativePath(f)));
        fesm2015.forEach(f => copyFile(f.path, getFlatEsmOutputRelativePath(f)));
        // Copy all type definitions into the package, preserving the sub-path from the
        // owning package. e.g. a file like `packages/animations/browser/index.d.ts` will
        // end up in `browser/index.d.ts`
        typeDefinitions.forEach(f => writeFile(getTypingOutputRelativePath(f), readTypingsAndStripAmdModule(f.path)));
        // Copy all `data` files into the package, preserving the sub-path from the owning
        // package. These are files that aren't built by the ng_package rule, but instead are
        // just straight copied into the package, e.g. global CSS assets or migration JSON file.
        dataFiles.forEach(f => copyFile(f.path, getOwningPackageRelativePath(f)));
        const licenseBanner = licenseFile ? fs.readFileSync(licenseFile, 'utf8') : '';
        dtsBundles.forEach(bundleDtsFile => {
            // We copy the `d.ts` bundles while preserving the sub-path from the owning
            // package. e.g. `packages/animations/animations.bundle.d.ts` will end up being
            // copied into `<pkg-out>/animations.d.ts`. Notice how the `.bundle` suffix
            // has been removed. The `ng_module` appends this to avoid conflicts with the
            // actual typings files being generated by the TS/Angular compilation.
            const outputRelativePath = getTypingOutputRelativePath(bundleDtsFile).replace(dtsBundleFileSuffix, '.d.ts');
            // API extractor will not dedupe license comments from various files
            // this will remove all the license comments and append the license banner.
            const content = licenseBanner + '\n' +
                readTypingsAndStripAmdModule(bundleDtsFile.path)
                    .replace(/(\/\*\*\s+\*\s\@license(((?!\*\/).|\s)*)\*\/)/gm, '');
            writeFile(outputRelativePath, content);
        });
        const modulesWithExistingPackageJson = new Set();
        for (const srcFile of srcs) {
            // We copy all source files into the package output while preserving the sub-path from
            // the owning package. e.g. `packages/core/package.json` ends up `<pkg-out>/package.json`.
            const outputRelativePath = getOwningPackageRelativePath(srcFile);
            let content = fs.readFileSync(srcFile.path, 'utf8');
            // Modify package.json files as necessary for publishing
            if (path.basename(srcFile.path) === 'package.json') {
                const isPrimaryPackageJson = outputRelativePath === 'package.json';
                const sourcePackageJson = JSON.parse(content);
                const packageName = sourcePackageJson['name'];
                // Check if the `name` field of the `package.json` files are matching with
                // name of the NPM package. This is an additional safety check.
                if (isPrimaryPackageJson && packageName !== metadata.npmPackageName) {
                    throw Error(`Primary "package.json" has mismatching package name. Expected the ` +
                        `package to be named "${metadata.npmPackageName}", but is set to: ${packageName}.`);
                }
                if (!isPrimaryPackageJson && !packageName.startsWith(`${metadata.npmPackageName}/`)) {
                    throw Error(`Found a "package.json" which does not start with the name of the primary ` +
                        `entry-point. Secondary entry-points need to start with "${metadata.npmPackageName}/", ` +
                        `but is set to: ${packageName}.`);
                }
                let newPackageJson = insertFormatFieldsIntoPackageJson(outputRelativePath, sourcePackageJson, false);
                if (isPrimaryPackageJson) {
                    newPackageJson = updatePrimaryPackageJson(newPackageJson);
                }
                // Keep track of the modules we have `package.json` files provided as part of
                // the sources. We use this later to skip generation of `package.json` files
                // for the modules the consumer already created a file.
                modulesWithExistingPackageJson.add(packageName);
                // Update the content with the new `package.json` file content.
                content = JSON.stringify(newPackageJson, null, 2);
            }
            writeFile(outputRelativePath, content);
        }
        // Generate extra files for secondary entry-points.
        Object.keys(metadata.entryPoints).forEach(moduleName => {
            if (!isSecondaryEntryPoint(moduleName)) {
                return;
            }
            // If there is a `package.json` already defined as part of the sources,
            // skip generation of the secondary `package.json` file.
            if (modulesWithExistingPackageJson.has(moduleName)) {
                return;
            }
            const packageJsonDir = getEntryPointSubpath(moduleName);
            createSecondaryEntryPointPackageJson(packageJsonDir, moduleName);
        });
        /**
         * Inserts or edits properties into the package.json file(s) in the package so that
         * they point to all the right generated artifacts.
         *
         * @param packageJsonOutRelativePath Path where the `package.json` is stored in
         *   the package output.
         * @param parsedPackage Parsed package.json content
         * @param isGeneratedPackageJson Whether the passed package.json has been generated.
         */
        function insertFormatFieldsIntoPackageJson(packageJsonOutRelativePath, parsedPackage, isGeneratedPackageJson) {
            const packageJson = Object.assign({}, parsedPackage);
            const packageName = packageJson['name'];
            const entryPointInfo = metadata.entryPoints[packageName];
            const packageJsonContainingDir = path.dirname(packageJsonOutRelativePath);
            // If a package json file has been discovered that does not match any
            // entry-point in the metadata, we report a warning as most likely the target
            // is configured incorrectly (e.g. missing `module_name` attribute).
            if (!entryPointInfo) {
                // Ideally we should throw here, as we got an entry point that doesn't
                // have flat module metadata / bundle index, so it may have been an
                // ng_module that's missing a module_name attribute.
                // However, @angular/compiler can't be an ng_module, as it's the internals
                // of the ngc compiler, yet we want to build an ng_package for it.
                // So ignore package.json files when we are missing data.
                console.error('WARNING: no module metadata for package', packageName);
                console.error('   Not updating the package.json file to point to it');
                console.error('   The ng_module for this package is possibly missing the module_name attribute ');
                return packageJson;
            }
            // If we guessed the index paths for a module, and it contains an explicit `package.json`
            // file that already sets format properties, we skip automatic insertion of format
            // properties but report a warning in case properties have been set by accident.
            if (entryPointInfo.guessedPaths && !isGeneratedPackageJson &&
                hasExplicitFormatProperties(packageJson)) {
                console.error('WARNING: `package.json` explicitly sets format properties (like `main`).');
                console.error('    Skipping automatic insertion of format properties as explicit ' +
                    'format properties are set.');
                console.error('    Ignore this warning if explicit properties are set intentionally.');
                return packageJson;
            }
            const fesm2020RelativeOutPath = getFlatEsmOutputRelativePath(entryPointInfo.fesm2020Bundle);
            const fesm2015RelativeOutPath = getFlatEsmOutputRelativePath(entryPointInfo.fesm2015Bundle);
            const esm2020RelativeOutPath = getEsm2020OutputRelativePath(entryPointInfo.index);
            const typingsRelativeOutPath = getTypingOutputRelativePath(entryPointInfo.typings);
            packageJson.fesm2020 =
                normalizePath(path.relative(packageJsonContainingDir, fesm2020RelativeOutPath));
            packageJson.fesm2015 =
                normalizePath(path.relative(packageJsonContainingDir, fesm2015RelativeOutPath));
            packageJson.esm2020 =
                normalizePath(path.relative(packageJsonContainingDir, esm2020RelativeOutPath));
            packageJson.typings =
                normalizePath(path.relative(packageJsonContainingDir, typingsRelativeOutPath));
            // For now, we point the primary entry points at the fesm files, because of Webpack
            // performance issues with a large number of individual files.
            packageJson.module = packageJson.fesm2015;
            packageJson.es2020 = packageJson.fesm2020;
            return packageJson;
        }
        /**
         * Updates the primary `package.json` file of the NPM package to specify
         * the module conditional exports and the ESM module type.
         */
        function updatePrimaryPackageJson(packageJson) {
            if (packageJson.type !== undefined) {
                throw Error('The primary "package.json" file of the package sets the "type" field ' +
                    'that is controlled by the packager. Please unset it.');
            }
            const newPackageJson = Object.assign({}, packageJson);
            newPackageJson.type = 'module';
            // The `package.json` file is made publicly accessible for tools that
            // might want to query information from the Angular NPM package.
            insertExportMappingOrError(newPackageJson, './package.json', { default: './package.json' });
            // Capture all entry-points in the `exports` field using the subpath export declarations:
            // https://nodejs.org/api/packages.html#packages_subpath_exports.
            for (const [moduleName, entryPoint] of Object.entries(metadata.entryPoints)) {
                const subpath = isSecondaryEntryPoint(moduleName) ? `./${getEntryPointSubpath(moduleName)}` : '.';
                const esm2020IndexOutRelativePath = getEsm2020OutputRelativePath(entryPoint.index);
                const fesm2020OutRelativePath = getFlatEsmOutputRelativePath(entryPoint.fesm2020Bundle);
                const fesm2015OutRelativePath = getFlatEsmOutputRelativePath(entryPoint.fesm2015Bundle);
                const typesOutRelativePath = getTypingOutputRelativePath(entryPoint.typings);
                // Insert the export mapping for the entry-point. We set `default` to the FESM 2020
                // output, and also set the `types` condition which will be respected by TS 4.5.
                // https://github.com/microsoft/TypeScript/pull/45884.
                insertExportMappingOrError(newPackageJson, subpath, {
                    types: normalizePath(typesOutRelativePath),
                    esm2020: normalizePath(esm2020IndexOutRelativePath),
                    es2020: normalizePath(fesm2020OutRelativePath),
                    // We also expose a non-standard condition that would allow consumers to resolve
                    // to the `ES2015` output outside of NodeJS, if desired.
                    // TODO(devversion): remove/replace this if NodeJS v12 is no longer supported.
                    es2015: normalizePath(fesm2015OutRelativePath),
                    // We declare the `node` condition and point to the ES2015 output as we currently still
                    // support NodeJS v12 which does not fully support ES2020 output. We chose ES2015 over
                    // ES2029 because we wan async/await downleveled as this allows for patching withZoneJS.
                    // TODO(devversion): remove/replace this if NodeJS v12 is no longer supported.
                    node: normalizePath(fesm2015OutRelativePath),
                    // Note: The default conditions needs to be the last one.
                    default: normalizePath(fesm2020OutRelativePath),
                });
            }
            return newPackageJson;
        }
        /**
         * Inserts a subpath export mapping into the specified `package.json` object.
         * @throws An error if the mapping is already defined and would conflict.
         */
        function insertExportMappingOrError(packageJson, subpath, mapping) {
            var _a;
            if (((_a = packageJson.exports) === null || _a === void 0 ? void 0 : _a[subpath]) !== undefined) {
                throw Error('Found a conflicting subpath export in the `package.json` file that would be overridden by the ' +
                    `packager. Please unset the mapping for: "${subpath}".`);
            }
            if (packageJson.exports === undefined) {
                packageJson.exports = {};
            }
            packageJson.exports[subpath] = mapping;
        }
        /** Whether the package explicitly sets any of the format properties (like `main`). */
        function hasExplicitFormatProperties(parsedPackage) {
            return Object.keys(parsedPackage)
                .some((fieldName) => knownFormatPackageJsonFormatFields.includes(fieldName));
        }
        /**
         * Creates a package.json for a secondary entry-point.
         * @param dir The directory under which the package.json should be written.
         * @param entryPointPackageName The full package name for the entry point,
         *     e.g. '@angular/common/http'.
         */
        function createSecondaryEntryPointPackageJson(dir, entryPointPackageName) {
            const relativeOutPath = path.join(dir, 'package.json');
            const content = insertFormatFieldsIntoPackageJson(relativeOutPath, { name: entryPointPackageName }, true);
            writeFile(relativeOutPath, JSON.stringify(content, null, 2));
        }
        /**
         * Normalizes the specified path by replacing backslash separators with Posix
         * forward slash separators.
         */
        function normalizePath(path) {
            const result = path.replace(/\\/g, '/');
            return result.startsWith('.') ? result : `./${result}`;
        }
        /**
         * Strip the named AMD module for compatibility with non-bazel users from typings content
         * @param filePath dts file path
         */
        function readTypingsAndStripAmdModule(filePath) {
            return fs
                .readFileSync(filePath, 'utf-8')
                // Strip the named AMD module for compatibility with non-bazel users
                .replace(/^\/\/\/ <amd-module name=.*\/>[\r\n]+/gm, '');
        }
    }
    if (require.main === module) {
        main(process.argv.slice(2));
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFja2FnZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9iYXplbC9zcmMvbmdfcGFja2FnZS9wYWNrYWdlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7Ozs7Ozs7Ozs7OztJQUVILHlCQUF5QjtJQUN6Qiw2QkFBNkI7SUFDN0IsK0JBQStCO0lBdUMvQjs7O09BR0c7SUFDSCxNQUFNLGtDQUFrQyxHQUNwQyxDQUFDLE1BQU0sRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLFVBQVUsQ0FBVSxDQUFDO0lBMkJ4RixTQUFTLElBQUksQ0FBQyxJQUFjO1FBQzFCLCtDQUErQztRQUMvQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRWQsMEZBQTBGO1FBQzFGLDZGQUE2RjtRQUM3RixNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFOUIsNkNBQTZDO1FBQzdDLFNBQVMsZ0JBQWdCLENBQUMsQ0FBUztZQUNqQyxPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ3JDLENBQUM7UUFFRCxxREFBcUQ7UUFDckQsTUFBTSxNQUFNLEdBQUcsRUFBRSxDQUFDLFlBQVksQ0FBQyxhQUFhLEVBQUUsT0FBTyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1FBRXpGLE1BQU07UUFDRix3Q0FBd0M7UUFDeEMsaUJBQWlCO1FBRWpCLDhFQUE4RTtRQUM5RSxpQkFBaUI7UUFFakIsa0ZBQWtGO1FBQ2xGLFdBQVc7UUFFWCxtQ0FBbUM7UUFDbkMsUUFBUTtRQUVSLHdDQUF3QztRQUN4QyxXQUFXO1FBRVgsb0NBQW9DO1FBQ3BDLFVBQVU7UUFFVix3Q0FBd0M7UUFDeEMsV0FBVztR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Q0FBQyxJQUFJLEtBQUssTUFBTSxFQUFFO1FBQzNCLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQzdCIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyBzaHggZnJvbSAnc2hlbGxqcyc7XG5cbi8qKlxuICogSW50ZXJmYWNlIGRlc2NyaWJpbmcgYSBmaWxlIGNhcHR1cmVkIGluIHRoZSBCYXplbCBhY3Rpb24uXG4gKiBodHRwczovL2RvY3MuYmF6ZWwuYnVpbGQvdmVyc2lvbnMvbWFpbi9za3lsYXJrL2xpYi9GaWxlLmh0bWwuXG4gKi9cbmludGVyZmFjZSBCYXplbEZpbGVJbmZvIHtcbiAgLyoqIEV4ZWNyb290LXJlbGF0aXZlIHBhdGggcG9pbnRpbmcgdG8gdGhlIGZpbGUuICovXG4gIHBhdGg6IHN0cmluZztcbiAgLyoqIFRoZSBwYXRoIG9mIHRoaXMgZmlsZSByZWxhdGl2ZSB0byBpdHMgcm9vdC4gZS5nLiBvbWl0dGluZyBgYmF6ZWwtb3V0LzwuLj4vYmluYC4gKi9cbiAgc2hvcnRQYXRoOiBzdHJpbmc7XG59XG5cbi8qKiBJbnRlcmZhY2UgZGVzY3JpYmluZyBhbiBlbnRyeS1wb2ludC4gKi9cbmludGVyZmFjZSBFbnRyeVBvaW50SW5mbyB7XG4gIC8qKiBFUzIwMjAgaW5kZXggZmlsZSBmb3IgdGhlIEFQRiBlbnRyeS1wb2ludC4gKi9cbiAgaW5kZXg6IEJhemVsRmlsZUluZm87XG4gIC8qKiBGbGF0IEVTMjAyMCBFUyBtb2R1bGUgYnVuZGxlIGZpbGUuICovXG4gIGZlc20yMDIwQnVuZGxlOiBCYXplbEZpbGVJbmZvO1xuICAvKiogRmxhdCBFUzIwMTUgRVMgbW9kdWxlIGJ1bmRsZSBmaWxlLiAqL1xuICBmZXNtMjAxNUJ1bmRsZTogQmF6ZWxGaWxlSW5mbztcbiAgLyoqIEluZGV4IHR5cGUgZGVmaW5pdGlvbiBmaWxlIGZvciB0aGUgQVBGIGVudHJ5LXBvaW50LiAqL1xuICB0eXBpbmdzOiBCYXplbEZpbGVJbmZvO1xuICAvKipcbiAgICogV2hldGhlciB0aGUgaW5kZXggb3IgdHlwaW5nIHBhdGhzIGhhdmUgYmVlbiBndWVzc2VkLiBGb3IgZW50cnktcG9pbnRzIGJ1aWx0XG4gICAqIHRocm91Z2ggYHRzX2xpYnJhcnlgLCB0aGVyZSBpcyBubyBleHBsaWNpdCBzZXR0aW5nIHRoYXQgZGVjbGFyZXMgdGhlIGVudHJ5LXBvaW50XG4gICAqIHNvIHRoZSBpbmRleCBmaWxlIGlzIGd1ZXNzZWQuXG4gICAqL1xuICBndWVzc2VkUGF0aHM6IGJvb2xlYW47XG59XG5cbi8qKiBJbnRlcmZhY2UgY2FwdHVyaW5nIHJlbGV2YW50IG1ldGFkYXRhIGZvciBwYWNrYWdpbmcuICovXG5pbnRlcmZhY2UgUGFja2FnZU1ldGFkYXRhIHtcbiAgLyoqIE5QTSBwYWNrYWdlIG5hbWUgb2YgdGhlIG91dHB1dC4gKi9cbiAgbnBtUGFja2FnZU5hbWU6IHN0cmluZztcbiAgLyoqIFJlY29yZCBvZiBlbnRyeS1wb2ludHMgKGluY2x1ZGluZyB0aGUgcHJpbWFyeSBvbmUpIGFuZCB0aGVpciBpbmZvLiAqL1xuICBlbnRyeVBvaW50czogUmVjb3JkPHN0cmluZywgRW50cnlQb2ludEluZm8+O1xufVxuXG4vKipcbiAqIExpc3Qgb2Yga25vd24gYHBhY2thZ2UuanNvbmAgZmllbGRzIHdoaWNoIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXRcbiAqIHN1cHBvcnRlZCBwYWNrYWdlIGZvcm1hdHMgYW5kIHRoZWlyIGFzc29jaWF0ZWQgZW50cnkgcGF0aHMuXG4gKi9cbmNvbnN0IGtub3duRm9ybWF0UGFja2FnZUpzb25Gb3JtYXRGaWVsZHMgPVxuICAgIFsnbWFpbicsICdmZXNtMjAyMCcsICdlc20yMDIwJywgJ2VzMjAyMCcsICd0eXBpbmdzJywgJ21vZHVsZScsICdmZXNtMjAxNSddIGFzIGNvbnN0O1xuXG4vKiogVW5pb24gdHlwZSBtYXRjaGluZyBrbm93biBgcGFja2FnZS5qc29uYCBmb3JtYXQgZmllbGRzLiAqL1xudHlwZSBLbm93blBhY2thZ2VKc29uRm9ybWF0RmllbGRzID0gdHlwZW9mIGtub3duRm9ybWF0UGFja2FnZUpzb25Gb3JtYXRGaWVsZHNbbnVtYmVyXTtcblxuLyoqXG4gKiBUeXBlIGRlc2NyaWJpbmcgdGhlIGNvbmRpdGlvbmFsIGV4cG9ydHMgZGVzY3JpcHRvciBmb3IgYW4gZW50cnktcG9pbnQuXG4gKiBodHRwczovL25vZGVqcy5vcmcvYXBpL3BhY2thZ2VzLmh0bWwjcGFja2FnZXNfY29uZGl0aW9uYWxfZXhwb3J0c1xuICovXG50eXBlIENvbmRpdGlvbmFsRXhwb3J0ID0ge1xuICBub2RlPzogc3RyaW5nO1xuICB0eXBlcz86IHN0cmluZztcbiAgZXNtMjAyMD86IHN0cmluZztcbiAgZXMyMDIwPzogc3RyaW5nO1xuICBlczIwMTU/OiBzdHJpbmc7XG4gIGRlZmF1bHQ/OiBzdHJpbmc7XG59O1xuXG4vKiogVHlwZSBkZXNjcmliaW5nIGEgYHBhY2thZ2UuanNvbmAgdGhlIHBhY2thZ2VyIGRlYWxzIHdpdGguICovXG50eXBlIFBhY2thZ2VKc29uID0ge1xuICBba2V5IGluIEtub3duUGFja2FnZUpzb25Gb3JtYXRGaWVsZHNdPzogc3RyaW5nXG59JntcbiAgbmFtZTogc3RyaW5nO1xuICB0eXBlPzogc3RyaW5nO1xuICBleHBvcnRzPzogUmVjb3JkPHN0cmluZywgQ29uZGl0aW9uYWxFeHBvcnQ+O1xufTtcblxuZnVuY3Rpb24gbWFpbihhcmdzOiBzdHJpbmdbXSk6IHZvaWQge1xuICAvLyBFeGl0IGltbWVkaWF0ZWx5IHdoZW4gZW5jb3VudGVyaW5nIGFuIGVycm9yLlxuICBzaHguc2V0KCctZScpO1xuXG4gIC8vIFRoaXMgdXRpbGl0eSBleHBlY3RzIGFsbCBvZiBpdHMgYXJndW1lbnRzIHRvIGJlIHNwZWNpZmllZCBpbiBhIHBhcmFtcyBmaWxlIGdlbmVyYXRlZCBieVxuICAvLyBiYXplbCAoc2VlIGh0dHBzOi8vZG9jcy5iYXplbC5idWlsZC92ZXJzaW9ucy9tYXN0ZXIvc2t5bGFyay9saWIvQXJncy5odG1sI3VzZV9wYXJhbV9maWxlKS5cbiAgY29uc3QgcGFyYW1GaWxlUGF0aCA9IGFyZ3NbMF07XG5cbiAgLy8gQmF6ZWwgcGFyYW1zIG1heSBiZSBzdXJyb3VuZGVkIHdpdGggcXVvdGVzXG4gIGZ1bmN0aW9uIHVucXVvdGVQYXJhbWV0ZXIoczogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZSgvXicoLiopJyQvLCAnJDEnKTtcbiAgfVxuXG4gIC8vIFBhcmFtZXRlcnMgYXJlIHNwZWNpZmllZCBpbiB0aGUgZmlsZSBvbmUgcGVyIGxpbmUuXG4gIGNvbnN0IHBhcmFtcyA9IGZzLnJlYWRGaWxlU3luYyhwYXJhbUZpbGVQYXRoLCAndXRmLTgnKS5zcGxpdCgnXFxuJykubWFwKHVucXVvdGVQYXJhbWV0ZXIpO1xuXG4gIGNvbnN0IFtcbiAgICAgIC8vIE91dHB1dCBkaXJlY3RvcnkgZm9yIHRoZSBucG0gcGFja2FnZS5cbiAgICAgIG91dHB1dERpckV4ZWNQYXRoLFxuXG4gICAgICAvLyBUaGUgcGFja2FnZSBzZWdtZW50IG9mIHRoZSBuZ19wYWNrYWdlIHJ1bGUncyBsYWJlbCAoZS5nLiAncGFja2FnZS9jb21tb24nKS5cbiAgICAgIG93bmluZ1BhY2thZ2VOYW1lLFxuXG4gICAgICAvLyBKU09OIGRhdGEgY2FwdHVyaW5nIG1ldGFkYXRhIG9mIHRoZSBwYWNrYWdlIGJlaW5nIGJ1aWx0LiBTZWUgYFBhY2thZ2VNZXRhZGF0YWAuXG4gICAgICBtZXRhZGF0YUFyZyxcblxuICAgICAgLy8gUGF0aCB0byB0aGUgcGFja2FnZSdzIFJFQURNRS5tZC5cbiAgICAgIHJlYWRtZU1kLFxuXG4gICAgICAvLyBMaXN0IG9mIHJvbGxlZC11cCBmbGF0IEVTMjAyMCBtb2R1bGVzXG4gICAgICBmZXNtMjAyMEFyZyxcblxuICAgICAgLy8gTGlzdCBvZiBpbmRpdmlkdWFsIEVTMjAyMCBtb2R1bGVzXG4gICAgICBlc20yMDIwQXJnLFxuXG4gICAgICAvLyBMaXN0IG9mIHJvbGxlZC11cCBmbGF0IEVTMjAxNSBtb2R1bGVzXG4gICAgICBmZXNtMjAxNUFyZyxcblxuICAgICAgLy8gTGlzdCBvZiBhbGwgZmlsZXMgaW4gdGhlIG5nX3BhY2thZ2UgcnVsZSdzIGBzcmNzYCBhdHRyaWJ1dGUuXG4gICAgICBzcmNzQXJnLFxuXG4gICAgICAvLyBMaXN0IG9mIGFsbCB0eXBlIGRlZmluaXRpb25zIHRoYXQgbmVlZCB0byBwYWNrYWdlZCBpbnRvIHRoZSBuZ19wYWNrYWdlLlxuICAgICAgdHlwZURlZmluaXRpb25zQXJnLFxuXG4gICAgICAvLyBMaXN0IG9mIGFsbCBmaWxlcyBpbiB0aGUgbmdfcGFja2FnZSBydWxlJ3MgZGF0YS5cbiAgICAgIGRhdGFBcmcsXG5cbiAgICAgIC8vIFBhdGggdG8gdGhlIHBhY2thZ2UncyBMSUNFTlNFLlxuICAgICAgbGljZW5zZUZpbGUsXG5cbiAgICAgIC8vIExpc3Qgb2YgYWxsIGR0cyBidW5kbGVzIGdlbmVyYXRlZCBieSB0aGUgQVBJIGV4dHJhY3Rvci5cbiAgICAgIGR0c0J1bmRsZUFyZyxcblxuICAgICAgLy8gVGhlIGR0cyBidW5kbGUgZmlsZSBzdWZmaXggZXhhbXBsZTogJy5idW5kbGUuZC50cydcbiAgICAgIGR0c0J1bmRsZUZpbGVTdWZmaXgsXG4gIF0gPSBwYXJhbXM7XG5cbiAgY29uc3QgZmVzbTIwMjAgPSBKU09OLnBhcnNlKGZlc20yMDIwQXJnKSBhcyBCYXplbEZpbGVJbmZvW107XG4gIGNvbnN0IGVzbTIwMjAgPSBKU09OLnBhcnNlKGVzbTIwMjBBcmcpIGFzIEJhemVsRmlsZUluZm9bXTtcbiAgY29uc3QgZmVzbTIwMTUgPSBKU09OLnBhcnNlKGZlc20yMDE1QXJnKSBhcyBCYXplbEZpbGVJbmZvW107XG4gIGNvbnN0IHR5cGVEZWZpbml0aW9ucyA9IEpTT04ucGFyc2UodHlwZURlZmluaXRpb25zQXJnKSBhcyBCYXplbEZpbGVJbmZvW107XG4gIGNvbnN0IHNyY3MgPSBKU09OLnBhcnNlKHNyY3NBcmcpIGFzIEJhemVsRmlsZUluZm9bXTtcbiAgY29uc3QgZGF0YUZpbGVzID0gSlNPTi5wYXJzZShkYXRhQXJnKSBhcyBCYXplbEZpbGVJbmZvW107XG4gIGNvbnN0IG1ldGFkYXRhID0gSlNPTi5wYXJzZShtZXRhZGF0YUFyZykgYXMgUGFja2FnZU1ldGFkYXRhO1xuICBjb25zdCBkdHNCdW5kbGVzID0gSlNPTi5wYXJzZShkdHNCdW5kbGVBcmcpIGFzIEJhemVsRmlsZUluZm9bXTtcblxuICBpZiAocmVhZG1lTWQpIHtcbiAgICBjb3B5RmlsZShyZWFkbWVNZCwgJ1JFQURNRS5tZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlcyBhIGZpbGUgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbnRlbnQgaW50byB0aGUgcGFja2FnZSBvdXRwdXQuXG4gICAqIEBwYXJhbSBvdXRwdXRSZWxhdGl2ZVBhdGggUmVsYXRpdmUgcGF0aCBpbiB0aGUgb3V0cHV0IGRpcmVjdG9yeSB3aGVyZSB0aGVcbiAgICogICBmaWxlIGlzIHdyaXR0ZW4gdG8uXG4gICAqIEBwYXJhbSBmaWxlQ29udGVudCBDb250ZW50IG9mIHRoZSBmaWxlLlxuICAgKi9cbiAgZnVuY3Rpb24gd3JpdGVGaWxlKG91dHB1dFJlbGF0aXZlUGF0aDogc3RyaW5nLCBmaWxlQ29udGVudDogc3RyaW5nfEJ1ZmZlcikge1xuICAgIGNvbnN0IG91dHB1dFBhdGggPSBwYXRoLmpvaW4ob3V0cHV0RGlyRXhlY1BhdGgsIG91dHB1dFJlbGF0aXZlUGF0aCk7XG5cbiAgICAvLyBBbHdheXMgZW5zdXJlIHRoYXQgdGhlIHRhcmdldCBkaXJlY3RvcnkgZXhpc3RzLlxuICAgIHNoeC5ta2RpcignLXAnLCBwYXRoLmRpcm5hbWUob3V0cHV0UGF0aCkpO1xuICAgIGZzLndyaXRlRmlsZVN5bmMob3V0cHV0UGF0aCwgZmlsZUNvbnRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvcGllcyBhIGZpbGUgaW50byB0aGUgcGFja2FnZSBvdXRwdXQgdG8gdGhlIHNwZWNpZmllZCBsb2NhdGlvbi5cbiAgICogQHBhcmFtIGlucHV0UGF0aCBGaWxlIHRoYXQgc2hvdWxkIGJlIGNvcGllZC5cbiAgICogQHBhcmFtIG91dHB1dFJlbGF0aXZlUGF0aCBSZWxhdGl2ZSBwYXRoIGluIHRoZSBvdXRwdXQgZGlyZWN0b3J5IHdoZXJlIHRoZVxuICAgKiAgIGZpbGUgaXMgd3JpdHRlbiB0by5cbiAgICovXG4gIGZ1bmN0aW9uIGNvcHlGaWxlKGlucHV0UGF0aDogc3RyaW5nLCBvdXRwdXRSZWxhdGl2ZVBhdGg6IHN0cmluZykge1xuICAgIGNvbnN0IGZpbGVDb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKGlucHV0UGF0aCwgJ3V0ZjgnKTtcbiAgICB3cml0ZUZpbGUob3V0cHV0UmVsYXRpdmVQYXRoLCBmaWxlQ29udGVudCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgcmVsYXRpdmUgcGF0aCBmb3IgdGhlIGdpdmVuIGZpbGUgd2l0aGluIHRoZSBvd25pbmcgcGFja2FnZS4gVGhpc1xuICAgKiBhc3N1bWVzIHRoZSBmaWxlIGlzIGNvbnRhaW5lZCBpbiB0aGUgb3duaW5nIHBhY2thZ2UuXG4gICAqXG4gICAqIGUuZy4gY29uc2lkZXIgdGhlIG93bmluZyBwYWNrYWdlIGlzIGBwYWNrYWdlcy9jb3JlYCBhbmQgdGhlIGlucHV0IGZpbGVcbiAgICogaXMgYHBhY2thZ2VzL2NvcmUvdGVzdGluZy9pbmRleC5kLnRzYC4gVGhpcyBmdW5jdGlvbiB3b3VsZCByZXR1cm4gdGhlXG4gICAqIHJlbGF0aXZlIHBhdGggYXMgZm9sbG93ZWQ6IGB0ZXN0aW5nL2luZGV4LmQudHNgLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0T3duaW5nUGFja2FnZVJlbGF0aXZlUGF0aChmaWxlOiBCYXplbEZpbGVJbmZvKTogc3RyaW5nIHtcbiAgICByZXR1cm4gcGF0aC5yZWxhdGl2ZShvd25pbmdQYWNrYWdlTmFtZSwgZmlsZS5zaG9ydFBhdGgpO1xuICB9XG5cbiAgLyoqIFdyaXRlcyBhbiBFU00gZmlsZSBpbnRvIHRoZSBgZXNtMjAyMGAgb3V0cHV0IGRpcmVjdG9yeS4gKi9cbiAgZnVuY3Rpb24gd3JpdGVFc20yMDIwRmlsZShmaWxlOiBCYXplbEZpbGVJbmZvKSB7XG4gICAgLy8gTm90ZTogZmlsZXMgd2hpY2ggZG8gbm90IGJlbG9uZyB0byB0aGUgb3duaW5nIHBhY2thZ2Ugb2YgdGhpcyBgbmdfcGFja2FnZWAgYXJlIG9taXR0ZWQuXG4gICAgLy8gdGhpcyBwcmV2ZW50cyB1cyBmcm9tIGFjY2lkZW50YWxseSBicmluZ2luZyBpbiB0cmFuc2l0aXZlIG5vZGUgbW9kdWxlIGRlcGVuZGVuY2llcy5cbiAgICBjb25zdCBwYWNrYWdlUmVsYXRpdmVQYXRoID0gZ2V0T3duaW5nUGFja2FnZVJlbGF0aXZlUGF0aChmaWxlKTtcbiAgICBpZiAoIXBhY2thZ2VSZWxhdGl2ZVBhdGguc3RhcnRzV2l0aCgnLi4nKSkge1xuICAgICAgY29weUZpbGUoZmlsZS5wYXRoLCBnZXRFc20yMDIwT3V0cHV0UmVsYXRpdmVQYXRoKGZpbGUpKTtcbiAgICB9XG4gIH1cblxuICAvKiogR2V0cyB0aGUgb3V0cHV0LXJlbGF0aXZlIHBhdGggd2hlcmUgdGhlIGdpdmVuIGZsYXQgRVNNIGZpbGUgc2hvdWxkIGJlIHdyaXR0ZW4gdG8uICovXG4gIGZ1bmN0aW9uIGdldEZsYXRFc21PdXRwdXRSZWxhdGl2ZVBhdGgoZmlsZTogQmF6ZWxGaWxlSW5mbykge1xuICAgIC8vIEZsYXQgRVNNIGZpbGVzIHNob3VsZCBiZSBwdXQgaW50byB0aGVpciBvd25pbmcgcGFja2FnZSByZWxhdGl2ZSBzdWItcGF0aC4gZS5nLiBpZlxuICAgIC8vIHRoZXJlIGlzIGEgYnVuZGxlIGluIGBwYWNrYWdlcy9hbmltYXRpb25zL2Zlc20yMDIwL2Jyb3dzZXIvdGVzdGluZy5tanNgIHRoZW4gd2VcbiAgICAvLyB3YW50IHRoZSBidW5kbGUgdG8gYmUgc3RvcmVkIGluIGBmZXNtMjAyMC9icm93c2VyL3Rlc3RpbmcubWpzYC4gU2FtZSB0aGluZyBhcHBsaWVzXG4gICAgLy8gZm9yIHRoZSBgZmVzbTIwMTVgIGJ1bmRsZXMuIFRoZSBkaXJlY3RvcnkgbmFtZSBmb3IgYGZlc21gIGlzIGFscmVhZHkgZGVjbGFyZWQgYXNcbiAgICAvLyBwYXJ0IG9mIHRoZSBCYXplbCBhY3Rpb24gZ2VuZXJhdGluZyB0aGVzZSBmaWxlcy4gU2VlIGBuZ19wYWNrYWdlLmJ6bGAuXG4gICAgcmV0dXJuIGdldE93bmluZ1BhY2thZ2VSZWxhdGl2ZVBhdGgoZmlsZSk7XG4gIH1cblxuICAvKiogR2V0cyB0aGUgb3V0cHV0LXJlbGF0aXZlIHBhdGggd2hlcmUgYSBub24tZmxhdCBFU00yMDIwIGZpbGUgc2hvdWxkIGJlIHdyaXR0ZW4gdG8uICovXG4gIGZ1bmN0aW9uIGdldEVzbTIwMjBPdXRwdXRSZWxhdGl2ZVBhdGgoZmlsZTogQmF6ZWxGaWxlSW5mbykge1xuICAgIC8vIFBhdGggY29tcHV0ZWQgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcGFja2FnZSBpbiBiYXplbC1iaW4uIGUuZy4gYSBFUzIwMjAgb3V0cHV0IGZpbGVcbiAgICAvLyBpbiBgYmF6ZWwtb3V0LzwuLj4vcGFja2FnZXMvY29yZS9zcmMvZGkubWpzYCBzaG91bGQgYmUgc3RvcmVkIGluIGBlc20yMDIwL3NyYy9kaS5tanNgLlxuICAgIHJldHVybiBwYXRoLmpvaW4oJ2VzbTIwMjAnLCBnZXRPd25pbmdQYWNrYWdlUmVsYXRpdmVQYXRoKGZpbGUpKTtcbiAgfVxuXG4gIC8qKiBHZXRzIHRoZSBvdXRwdXQtcmVsYXRpdmUgcGF0aCB3aGVyZSB0aGUgdHlwaW5nIGZpbGUgaXMgYmVpbmcgd3JpdHRlbiB0by4gKi9cbiAgZnVuY3Rpb24gZ2V0VHlwaW5nT3V0cHV0UmVsYXRpdmVQYXRoKGZpbGU6IEJhemVsRmlsZUluZm8pIHtcbiAgICAvLyBUeXBlIGRlZmluaXRpb25zIGFyZSBpbnRlbmRlZCB0byBiZSBjb3BpZWQgaW50byB0aGUgcGFja2FnZSBvdXRwdXQgd2hpbGUgcHJlc2VydmluZyB0aGVcbiAgICAvLyBzdWItcGF0aCBmcm9tIHRoZSBvd25pbmcgcGFja2FnZS4gZS5nLiBhIGZpbGUgbGlrZSBgcGFja2FnZXMvYW5pbWF0aW9ucy9icm93c2VyL2luZGV4LmQudHNgXG4gICAgLy8gd2lsbCBlbmQgdXAgYmVpbmcgd3JpdHRlbiB0byBgPHBrZy1vdXQ+L2Jyb3dzZXIvaW5kZXguZC50c2BcbiAgICByZXR1cm4gZ2V0T3duaW5nUGFja2FnZVJlbGF0aXZlUGF0aChmaWxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBlbnRyeS1wb2ludCBzdWItcGF0aCBmcm9tIHRoZSBwYWNrYWdlIHJvb3QuIGUuZy4gaWYgdGhlIHBhY2thZ2UgbmFtZVxuICAgKiBpcyBgQGFuZ3VsYXIvY2RrYCwgdGhlbiBmb3IgYEBhbmd1bGFyL2Nkay9hMTF5YCBqdXN0IGBhMTF5YCB3b3VsZCBiZSByZXR1cm5lZC5cbiAgICovXG4gIGZ1bmN0aW9uIGdldEVudHJ5UG9pbnRTdWJwYXRoKG1vZHVsZU5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIG1vZHVsZU5hbWUuc3Vic3RyKGAke21ldGFkYXRhLm5wbVBhY2thZ2VOYW1lfS9gLmxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB3aGV0aGVyIHRoZSBnaXZlbiBtb2R1bGUgbmFtZSByZXNvbHZlcyB0byBhIHNlY29uZGFyeSBlbnRyeS1wb2ludC5cbiAgICogZS5nLiBpZiB0aGUgcGFja2FnZSBuYW1lIGlzIGBAYW5ndWxhci9jZGtgLCB0aGVuIGZvciBgQGFuZ3VsYXIvY2RrL2ExMXlgXG4gICAqIHRoaXMgd291bGQgcmV0dXJuIGB0cnVlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGlzU2Vjb25kYXJ5RW50cnlQb2ludChtb2R1bGVOYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZ2V0RW50cnlQb2ludFN1YnBhdGgobW9kdWxlTmFtZSkgIT09ICcnO1xuICB9XG5cbiAgZXNtMjAyMC5mb3JFYWNoKGZpbGUgPT4gd3JpdGVFc20yMDIwRmlsZShmaWxlKSk7XG5cbiAgLy8gQ29weSBhbGwgRkVTTSBmaWxlcyBpbnRvIHRoZSBwYWNrYWdlIG91dHB1dC5cbiAgZmVzbTIwMjAuZm9yRWFjaChmID0+IGNvcHlGaWxlKGYucGF0aCwgZ2V0RmxhdEVzbU91dHB1dFJlbGF0aXZlUGF0aChmKSkpO1xuICBmZXNtMjAxNS5mb3JFYWNoKGYgPT4gY29weUZpbGUoZi5wYXRoLCBnZXRGbGF0RXNtT3V0cHV0UmVsYXRpdmVQYXRoKGYpKSk7XG5cbiAgLy8gQ29weSBhbGwgdHlwZSBkZWZpbml0aW9ucyBpbnRvIHRoZSBwYWNrYWdlLCBwcmVzZXJ2aW5nIHRoZSBzdWItcGF0aCBmcm9tIHRoZVxuICAvLyBvd25pbmcgcGFja2FnZS4gZS5nLiBhIGZpbGUgbGlrZSBgcGFja2FnZXMvYW5pbWF0aW9ucy9icm93c2VyL2luZGV4LmQudHNgIHdpbGxcbiAgLy8gZW5kIHVwIGluIGBicm93c2VyL2luZGV4LmQudHNgXG4gIHR5cGVEZWZpbml0aW9ucy5mb3JFYWNoKFxuICAgICAgZiA9PiB3cml0ZUZpbGUoZ2V0VHlwaW5nT3V0cHV0UmVsYXRpdmVQYXRoKGYpLCByZWFkVHlwaW5nc0FuZFN0cmlwQW1kTW9kdWxlKGYucGF0aCkpKTtcblxuICAvLyBDb3B5IGFsbCBgZGF0YWAgZmlsZXMgaW50byB0aGUgcGFja2FnZSwgcHJlc2VydmluZyB0aGUgc3ViLXBhdGggZnJvbSB0aGUgb3duaW5nXG4gIC8vIHBhY2thZ2UuIFRoZXNlIGFyZSBmaWxlcyB0aGF0IGFyZW4ndCBidWlsdCBieSB0aGUgbmdfcGFja2FnZSBydWxlLCBidXQgaW5zdGVhZCBhcmVcbiAgLy8ganVzdCBzdHJhaWdodCBjb3BpZWQgaW50byB0aGUgcGFja2FnZSwgZS5nLiBnbG9iYWwgQ1NTIGFzc2V0cyBvciBtaWdyYXRpb24gSlNPTiBmaWxlLlxuICBkYXRhRmlsZXMuZm9yRWFjaChmID0+IGNvcHlGaWxlKGYucGF0aCwgZ2V0T3duaW5nUGFja2FnZVJlbGF0aXZlUGF0aChmKSkpO1xuXG4gIGNvbnN0IGxpY2Vuc2VCYW5uZXIgPSBsaWNlbnNlRmlsZSA/IGZzLnJlYWRGaWxlU3luYyhsaWNlbnNlRmlsZSwgJ3V0ZjgnKSA6ICcnO1xuXG4gIGR0c0J1bmRsZXMuZm9yRWFjaChidW5kbGVEdHNGaWxlID0+IHtcbiAgICAvLyBXZSBjb3B5IHRoZSBgZC50c2AgYnVuZGxlcyB3aGlsZSBwcmVzZXJ2aW5nIHRoZSBzdWItcGF0aCBmcm9tIHRoZSBvd25pbmdcbiAgICAvLyBwYWNrYWdlLiBlLmcuIGBwYWNrYWdlcy9hbmltYXRpb25zL2FuaW1hdGlvbnMuYnVuZGxlLmQudHNgIHdpbGwgZW5kIHVwIGJlaW5nXG4gICAgLy8gY29waWVkIGludG8gYDxwa2ctb3V0Pi9hbmltYXRpb25zLmQudHNgLiBOb3RpY2UgaG93IHRoZSBgLmJ1bmRsZWAgc3VmZml4XG4gICAgLy8gaGFzIGJlZW4gcmVtb3ZlZC4gVGhlIGBuZ19tb2R1bGVgIGFwcGVuZHMgdGhpcyB0byBhdm9pZCBjb25mbGljdHMgd2l0aCB0aGVcbiAgICAvLyBhY3R1YWwgdHlwaW5ncyBmaWxlcyBiZWluZyBnZW5lcmF0ZWQgYnkgdGhlIFRTL0FuZ3VsYXIgY29tcGlsYXRpb24uXG4gICAgY29uc3Qgb3V0cHV0UmVsYXRpdmVQYXRoID1cbiAgICAgICAgZ2V0VHlwaW5nT3V0cHV0UmVsYXRpdmVQYXRoKGJ1bmRsZUR0c0ZpbGUpLnJlcGxhY2UoZHRzQnVuZGxlRmlsZVN1ZmZpeCwgJy5kLnRzJyk7XG4gICAgLy8gQVBJIGV4dHJhY3RvciB3aWxsIG5vdCBkZWR1cGUgbGljZW5zZSBjb21tZW50cyBmcm9tIHZhcmlvdXMgZmlsZXNcbiAgICAvLyB0aGlzIHdpbGwgcmVtb3ZlIGFsbCB0aGUgbGljZW5zZSBjb21tZW50cyBhbmQgYXBwZW5kIHRoZSBsaWNlbnNlIGJhbm5lci5cbiAgICBjb25zdCBjb250ZW50ID0gbGljZW5zZUJhbm5lciArICdcXG4nICtcbiAgICAgICAgcmVhZFR5cGluZ3NBbmRTdHJpcEFtZE1vZHVsZShidW5kbGVEdHNGaWxlLnBhdGgpXG4gICAgICAgICAgICAucmVwbGFjZSgvKFxcL1xcKlxcKlxccytcXCpcXHNcXEBsaWNlbnNlKCgoPyFcXCpcXC8pLnxcXHMpKilcXCpcXC8pL2dtLCAnJyk7XG5cbiAgICB3cml0ZUZpbGUob3V0cHV0UmVsYXRpdmVQYXRoLCBjb250ZW50KTtcbiAgfSk7XG5cbiAgY29uc3QgbW9kdWxlc1dpdGhFeGlzdGluZ1BhY2thZ2VKc29uID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgZm9yIChjb25zdCBzcmNGaWxlIG9mIHNyY3MpIHtcbiAgICAvLyBXZSBjb3B5IGFsbCBzb3VyY2UgZmlsZXMgaW50byB0aGUgcGFja2FnZSBvdXRwdXQgd2hpbGUgcHJlc2VydmluZyB0aGUgc3ViLXBhdGggZnJvbVxuICAgIC8vIHRoZSBvd25pbmcgcGFja2FnZS4gZS5nLiBgcGFja2FnZXMvY29yZS9wYWNrYWdlLmpzb25gIGVuZHMgdXAgYDxwa2ctb3V0Pi9wYWNrYWdlLmpzb25gLlxuICAgIGNvbnN0IG91dHB1dFJlbGF0aXZlUGF0aCA9IGdldE93bmluZ1BhY2thZ2VSZWxhdGl2ZVBhdGgoc3JjRmlsZSk7XG4gICAgbGV0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoc3JjRmlsZS5wYXRoLCAndXRmOCcpO1xuXG4gICAgLy8gTW9kaWZ5IHBhY2thZ2UuanNvbiBmaWxlcyBhcyBuZWNlc3NhcnkgZm9yIHB1Ymxpc2hpbmdcbiAgICBpZiAocGF0aC5iYXNlbmFtZShzcmNGaWxlLnBhdGgpID09PSAncGFja2FnZS5qc29uJykge1xuICAgICAgY29uc3QgaXNQcmltYXJ5UGFja2FnZUpzb24gPSBvdXRwdXRSZWxhdGl2ZVBhdGggPT09ICdwYWNrYWdlLmpzb24nO1xuICAgICAgY29uc3Qgc291cmNlUGFja2FnZUpzb24gPSBKU09OLnBhcnNlKGNvbnRlbnQpIGFzIFBhY2thZ2VKc29uO1xuICAgICAgY29uc3QgcGFja2FnZU5hbWUgPSBzb3VyY2VQYWNrYWdlSnNvblsnbmFtZSddO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgYG5hbWVgIGZpZWxkIG9mIHRoZSBgcGFja2FnZS5qc29uYCBmaWxlcyBhcmUgbWF0Y2hpbmcgd2l0aFxuICAgICAgLy8gbmFtZSBvZiB0aGUgTlBNIHBhY2thZ2UuIFRoaXMgaXMgYW4gYWRkaXRpb25hbCBzYWZldHkgY2hlY2suXG4gICAgICBpZiAoaXNQcmltYXJ5UGFja2FnZUpzb24gJiYgcGFja2FnZU5hbWUgIT09IG1ldGFkYXRhLm5wbVBhY2thZ2VOYW1lKSB7XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgYFByaW1hcnkgXCJwYWNrYWdlLmpzb25cIiBoYXMgbWlzbWF0Y2hpbmcgcGFja2FnZSBuYW1lLiBFeHBlY3RlZCB0aGUgYCArXG4gICAgICAgICAgICBgcGFja2FnZSB0byBiZSBuYW1lZCBcIiR7bWV0YWRhdGEubnBtUGFja2FnZU5hbWV9XCIsIGJ1dCBpcyBzZXQgdG86ICR7cGFja2FnZU5hbWV9LmApO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzUHJpbWFyeVBhY2thZ2VKc29uICYmICFwYWNrYWdlTmFtZS5zdGFydHNXaXRoKGAke21ldGFkYXRhLm5wbVBhY2thZ2VOYW1lfS9gKSkge1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIGBGb3VuZCBhIFwicGFja2FnZS5qc29uXCIgd2hpY2ggZG9lcyBub3Qgc3RhcnQgd2l0aCB0aGUgbmFtZSBvZiB0aGUgcHJpbWFyeSBgICtcbiAgICAgICAgICAgIGBlbnRyeS1wb2ludC4gU2Vjb25kYXJ5IGVudHJ5LXBvaW50cyBuZWVkIHRvIHN0YXJ0IHdpdGggXCIke1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhLm5wbVBhY2thZ2VOYW1lfS9cIiwgYCArXG4gICAgICAgICAgICBgYnV0IGlzIHNldCB0bzogJHtwYWNrYWdlTmFtZX0uYCk7XG4gICAgICB9XG5cbiAgICAgIGxldCBuZXdQYWNrYWdlSnNvbiA9XG4gICAgICAgICAgaW5zZXJ0Rm9ybWF0RmllbGRzSW50b1BhY2thZ2VKc29uKG91dHB1dFJlbGF0aXZlUGF0aCwgc291cmNlUGFja2FnZUpzb24sIGZhbHNlKTtcblxuICAgICAgaWYgKGlzUHJpbWFyeVBhY2thZ2VKc29uKSB7XG4gICAgICAgIG5ld1BhY2thZ2VKc29uID0gdXBkYXRlUHJpbWFyeVBhY2thZ2VKc29uKG5ld1BhY2thZ2VKc29uKTtcbiAgICAgIH1cblxuICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgbW9kdWxlcyB3ZSBoYXZlIGBwYWNrYWdlLmpzb25gIGZpbGVzIHByb3ZpZGVkIGFzIHBhcnQgb2ZcbiAgICAgIC8vIHRoZSBzb3VyY2VzLiBXZSB1c2UgdGhpcyBsYXRlciB0byBza2lwIGdlbmVyYXRpb24gb2YgYHBhY2thZ2UuanNvbmAgZmlsZXNcbiAgICAgIC8vIGZvciB0aGUgbW9kdWxlcyB0aGUgY29uc3VtZXIgYWxyZWFkeSBjcmVhdGVkIGEgZmlsZS5cbiAgICAgIG1vZHVsZXNXaXRoRXhpc3RpbmdQYWNrYWdlSnNvbi5hZGQocGFja2FnZU5hbWUpO1xuXG4gICAgICAvLyBVcGRhdGUgdGhlIGNvbnRlbnQgd2l0aCB0aGUgbmV3IGBwYWNrYWdlLmpzb25gIGZpbGUgY29udGVudC5cbiAgICAgIGNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShuZXdQYWNrYWdlSnNvbiwgbnVsbCwgMik7XG4gICAgfVxuXG4gICAgd3JpdGVGaWxlKG91dHB1dFJlbGF0aXZlUGF0aCwgY29udGVudCk7XG4gIH1cblxuICAvLyBHZW5lcmF0ZSBleHRyYSBmaWxlcyBmb3Igc2Vjb25kYXJ5IGVudHJ5LXBvaW50cy5cbiAgT2JqZWN0LmtleXMobWV0YWRhdGEuZW50cnlQb2ludHMpLmZvckVhY2gobW9kdWxlTmFtZSA9PiB7XG4gICAgaWYgKCFpc1NlY29uZGFyeUVudHJ5UG9pbnQobW9kdWxlTmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIGBwYWNrYWdlLmpzb25gIGFscmVhZHkgZGVmaW5lZCBhcyBwYXJ0IG9mIHRoZSBzb3VyY2VzLFxuICAgIC8vIHNraXAgZ2VuZXJhdGlvbiBvZiB0aGUgc2Vjb25kYXJ5IGBwYWNrYWdlLmpzb25gIGZpbGUuXG4gICAgaWYgKG1vZHVsZXNXaXRoRXhpc3RpbmdQYWNrYWdlSnNvbi5oYXMobW9kdWxlTmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwYWNrYWdlSnNvbkRpciA9IGdldEVudHJ5UG9pbnRTdWJwYXRoKG1vZHVsZU5hbWUpO1xuICAgIGNyZWF0ZVNlY29uZGFyeUVudHJ5UG9pbnRQYWNrYWdlSnNvbihwYWNrYWdlSnNvbkRpciwgbW9kdWxlTmFtZSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBJbnNlcnRzIG9yIGVkaXRzIHByb3BlcnRpZXMgaW50byB0aGUgcGFja2FnZS5qc29uIGZpbGUocykgaW4gdGhlIHBhY2thZ2Ugc28gdGhhdFxuICAgKiB0aGV5IHBvaW50IHRvIGFsbCB0aGUgcmlnaHQgZ2VuZXJhdGVkIGFydGlmYWN0cy5cbiAgICpcbiAgICogQHBhcmFtIHBhY2thZ2VKc29uT3V0UmVsYXRpdmVQYXRoIFBhdGggd2hlcmUgdGhlIGBwYWNrYWdlLmpzb25gIGlzIHN0b3JlZCBpblxuICAgKiAgIHRoZSBwYWNrYWdlIG91dHB1dC5cbiAgICogQHBhcmFtIHBhcnNlZFBhY2thZ2UgUGFyc2VkIHBhY2thZ2UuanNvbiBjb250ZW50XG4gICAqIEBwYXJhbSBpc0dlbmVyYXRlZFBhY2thZ2VKc29uIFdoZXRoZXIgdGhlIHBhc3NlZCBwYWNrYWdlLmpzb24gaGFzIGJlZW4gZ2VuZXJhdGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gaW5zZXJ0Rm9ybWF0RmllbGRzSW50b1BhY2thZ2VKc29uKFxuICAgICAgcGFja2FnZUpzb25PdXRSZWxhdGl2ZVBhdGg6IHN0cmluZywgcGFyc2VkUGFja2FnZTogUmVhZG9ubHk8UGFja2FnZUpzb24+LFxuICAgICAgaXNHZW5lcmF0ZWRQYWNrYWdlSnNvbjogYm9vbGVhbik6IFBhY2thZ2VKc29uIHtcbiAgICBjb25zdCBwYWNrYWdlSnNvbjogUGFja2FnZUpzb24gPSB7Li4ucGFyc2VkUGFja2FnZX07XG4gICAgY29uc3QgcGFja2FnZU5hbWUgPSBwYWNrYWdlSnNvblsnbmFtZSddO1xuICAgIGNvbnN0IGVudHJ5UG9pbnRJbmZvID0gbWV0YWRhdGEuZW50cnlQb2ludHNbcGFja2FnZU5hbWVdO1xuICAgIGNvbnN0IHBhY2thZ2VKc29uQ29udGFpbmluZ0RpciA9IHBhdGguZGlybmFtZShwYWNrYWdlSnNvbk91dFJlbGF0aXZlUGF0aCk7XG5cbiAgICAvLyBJZiBhIHBhY2thZ2UganNvbiBmaWxlIGhhcyBiZWVuIGRpc2NvdmVyZWQgdGhhdCBkb2VzIG5vdCBtYXRjaCBhbnlcbiAgICAvLyBlbnRyeS1wb2ludCBpbiB0aGUgbWV0YWRhdGEsIHdlIHJlcG9ydCBhIHdhcm5pbmcgYXMgbW9zdCBsaWtlbHkgdGhlIHRhcmdldFxuICAgIC8vIGlzIGNvbmZpZ3VyZWQgaW5jb3JyZWN0bHkgKGUuZy4gbWlzc2luZyBgbW9kdWxlX25hbWVgIGF0dHJpYnV0ZSkuXG4gICAgaWYgKCFlbnRyeVBvaW50SW5mbykge1xuICAgICAgLy8gSWRlYWxseSB3ZSBzaG91bGQgdGhyb3cgaGVyZSwgYXMgd2UgZ290IGFuIGVudHJ5IHBvaW50IHRoYXQgZG9lc24ndFxuICAgICAgLy8gaGF2ZSBmbGF0IG1vZHVsZSBtZXRhZGF0YSAvIGJ1bmRsZSBpbmRleCwgc28gaXQgbWF5IGhhdmUgYmVlbiBhblxuICAgICAgLy8gbmdfbW9kdWxlIHRoYXQncyBtaXNzaW5nIGEgbW9kdWxlX25hbWUgYXR0cmlidXRlLlxuICAgICAgLy8gSG93ZXZlciwgQGFuZ3VsYXIvY29tcGlsZXIgY2FuJ3QgYmUgYW4gbmdfbW9kdWxlLCBhcyBpdCdzIHRoZSBpbnRlcm5hbHNcbiAgICAgIC8vIG9mIHRoZSBuZ2MgY29tcGlsZXIsIHlldCB3ZSB3YW50IHRvIGJ1aWxkIGFuIG5nX3BhY2thZ2UgZm9yIGl0LlxuICAgICAgLy8gU28gaWdub3JlIHBhY2thZ2UuanNvbiBmaWxlcyB3aGVuIHdlIGFyZSBtaXNzaW5nIGRhdGEuXG4gICAgICBjb25zb2xlLmVycm9yKCdXQVJOSU5HOiBubyBtb2R1bGUgbWV0YWRhdGEgZm9yIHBhY2thZ2UnLCBwYWNrYWdlTmFtZSk7XG4gICAgICBjb25zb2xlLmVycm9yKCcgICBOb3QgdXBkYXRpbmcgdGhlIHBhY2thZ2UuanNvbiBmaWxlIHRvIHBvaW50IHRvIGl0Jyk7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICcgICBUaGUgbmdfbW9kdWxlIGZvciB0aGlzIHBhY2thZ2UgaXMgcG9zc2libHkgbWlzc2luZyB0aGUgbW9kdWxlX25hbWUgYXR0cmlidXRlICcpO1xuICAgICAgcmV0dXJuIHBhY2thZ2VKc29uO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGd1ZXNzZWQgdGhlIGluZGV4IHBhdGhzIGZvciBhIG1vZHVsZSwgYW5kIGl0IGNvbnRhaW5zIGFuIGV4cGxpY2l0IGBwYWNrYWdlLmpzb25gXG4gICAgLy8gZmlsZSB0aGF0IGFscmVhZHkgc2V0cyBmb3JtYXQgcHJvcGVydGllcywgd2Ugc2tpcCBhdXRvbWF0aWMgaW5zZXJ0aW9uIG9mIGZvcm1hdFxuICAgIC8vIHByb3BlcnRpZXMgYnV0IHJlcG9ydCBhIHdhcm5pbmcgaW4gY2FzZSBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBzZXQgYnkgYWNjaWRlbnQuXG4gICAgaWYgKGVudHJ5UG9pbnRJbmZvLmd1ZXNzZWRQYXRocyAmJiAhaXNHZW5lcmF0ZWRQYWNrYWdlSnNvbiAmJlxuICAgICAgICBoYXNFeHBsaWNpdEZvcm1hdFByb3BlcnRpZXMocGFja2FnZUpzb24pKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdXQVJOSU5HOiBgcGFja2FnZS5qc29uYCBleHBsaWNpdGx5IHNldHMgZm9ybWF0IHByb3BlcnRpZXMgKGxpa2UgYG1haW5gKS4nKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgJyAgICBTa2lwcGluZyBhdXRvbWF0aWMgaW5zZXJ0aW9uIG9mIGZvcm1hdCBwcm9wZXJ0aWVzIGFzIGV4cGxpY2l0ICcgK1xuICAgICAgICAgICdmb3JtYXQgcHJvcGVydGllcyBhcmUgc2V0LicpO1xuICAgICAgY29uc29sZS5lcnJvcignICAgIElnbm9yZSB0aGlzIHdhcm5pbmcgaWYgZXhwbGljaXQgcHJvcGVydGllcyBhcmUgc2V0IGludGVudGlvbmFsbHkuJyk7XG4gICAgICByZXR1cm4gcGFja2FnZUpzb247XG4gICAgfVxuXG4gICAgY29uc3QgZmVzbTIwMjBSZWxhdGl2ZU91dFBhdGggPSBnZXRGbGF0RXNtT3V0cHV0UmVsYXRpdmVQYXRoKGVudHJ5UG9pbnRJbmZvLmZlc20yMDIwQnVuZGxlKTtcbiAgICBjb25zdCBmZXNtMjAxNVJlbGF0aXZlT3V0UGF0aCA9IGdldEZsYXRFc21PdXRwdXRSZWxhdGl2ZVBhdGgoZW50cnlQb2ludEluZm8uZmVzbTIwMTVCdW5kbGUpO1xuICAgIGNvbnN0IGVzbTIwMjBSZWxhdGl2ZU91dFBhdGggPSBnZXRFc20yMDIwT3V0cHV0UmVsYXRpdmVQYXRoKGVudHJ5UG9pbnRJbmZvLmluZGV4KTtcbiAgICBjb25zdCB0eXBpbmdzUmVsYXRpdmVPdXRQYXRoID0gZ2V0VHlwaW5nT3V0cHV0UmVsYXRpdmVQYXRoKGVudHJ5UG9pbnRJbmZvLnR5cGluZ3MpO1xuXG4gICAgcGFja2FnZUpzb24uZmVzbTIwMjAgPVxuICAgICAgICBub3JtYWxpemVQYXRoKHBhdGgucmVsYXRpdmUocGFja2FnZUpzb25Db250YWluaW5nRGlyLCBmZXNtMjAyMFJlbGF0aXZlT3V0UGF0aCkpO1xuICAgIHBhY2thZ2VKc29uLmZlc20yMDE1ID1cbiAgICAgICAgbm9ybWFsaXplUGF0aChwYXRoLnJlbGF0aXZlKHBhY2thZ2VKc29uQ29udGFpbmluZ0RpciwgZmVzbTIwMTVSZWxhdGl2ZU91dFBhdGgpKTtcbiAgICBwYWNrYWdlSnNvbi5lc20yMDIwID1cbiAgICAgICAgbm9ybWFsaXplUGF0aChwYXRoLnJlbGF0aXZlKHBhY2thZ2VKc29uQ29udGFpbmluZ0RpciwgZXNtMjAyMFJlbGF0aXZlT3V0UGF0aCkpO1xuICAgIHBhY2thZ2VKc29uLnR5cGluZ3MgPVxuICAgICAgICBub3JtYWxpemVQYXRoKHBhdGgucmVsYXRpdmUocGFja2FnZUpzb25Db250YWluaW5nRGlyLCB0eXBpbmdzUmVsYXRpdmVPdXRQYXRoKSk7XG5cbiAgICAvLyBGb3Igbm93LCB3ZSBwb2ludCB0aGUgcHJpbWFyeSBlbnRyeSBwb2ludHMgYXQgdGhlIGZlc20gZmlsZXMsIGJlY2F1c2Ugb2YgV2VicGFja1xuICAgIC8vIHBlcmZvcm1hbmNlIGlzc3VlcyB3aXRoIGEgbGFyZ2UgbnVtYmVyIG9mIGluZGl2aWR1YWwgZmlsZXMuXG4gICAgcGFja2FnZUpzb24ubW9kdWxlID0gcGFja2FnZUpzb24uZmVzbTIwMTU7XG4gICAgcGFja2FnZUpzb24uZXMyMDIwID0gcGFja2FnZUpzb24uZmVzbTIwMjA7XG5cbiAgICByZXR1cm4gcGFja2FnZUpzb247XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcHJpbWFyeSBgcGFja2FnZS5qc29uYCBmaWxlIG9mIHRoZSBOUE0gcGFja2FnZSB0byBzcGVjaWZ5XG4gICAqIHRoZSBtb2R1bGUgY29uZGl0aW9uYWwgZXhwb3J0cyBhbmQgdGhlIEVTTSBtb2R1bGUgdHlwZS5cbiAgICovXG4gIGZ1bmN0aW9uIHVwZGF0ZVByaW1hcnlQYWNrYWdlSnNvbihwYWNrYWdlSnNvbjogUmVhZG9ubHk8UGFja2FnZUpzb24+KTogUGFja2FnZUpzb24ge1xuICAgIGlmIChwYWNrYWdlSnNvbi50eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICdUaGUgcHJpbWFyeSBcInBhY2thZ2UuanNvblwiIGZpbGUgb2YgdGhlIHBhY2thZ2Ugc2V0cyB0aGUgXCJ0eXBlXCIgZmllbGQgJyArXG4gICAgICAgICAgJ3RoYXQgaXMgY29udHJvbGxlZCBieSB0aGUgcGFja2FnZXIuIFBsZWFzZSB1bnNldCBpdC4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdQYWNrYWdlSnNvbjogUGFja2FnZUpzb24gPSB7Li4ucGFja2FnZUpzb259O1xuXG4gICAgbmV3UGFja2FnZUpzb24udHlwZSA9ICdtb2R1bGUnO1xuXG4gICAgLy8gVGhlIGBwYWNrYWdlLmpzb25gIGZpbGUgaXMgbWFkZSBwdWJsaWNseSBhY2Nlc3NpYmxlIGZvciB0b29scyB0aGF0XG4gICAgLy8gbWlnaHQgd2FudCB0byBxdWVyeSBpbmZvcm1hdGlvbiBmcm9tIHRoZSBBbmd1bGFyIE5QTSBwYWNrYWdlLlxuICAgIGluc2VydEV4cG9ydE1hcHBpbmdPckVycm9yKG5ld1BhY2thZ2VKc29uLCAnLi9wYWNrYWdlLmpzb24nLCB7ZGVmYXVsdDogJy4vcGFja2FnZS5qc29uJ30pO1xuXG4gICAgLy8gQ2FwdHVyZSBhbGwgZW50cnktcG9pbnRzIGluIHRoZSBgZXhwb3J0c2AgZmllbGQgdXNpbmcgdGhlIHN1YnBhdGggZXhwb3J0IGRlY2xhcmF0aW9uczpcbiAgICAvLyBodHRwczovL25vZGVqcy5vcmcvYXBpL3BhY2thZ2VzLmh0bWwjcGFja2FnZXNfc3VicGF0aF9leHBvcnRzLlxuICAgIGZvciAoY29uc3QgW21vZHVsZU5hbWUsIGVudHJ5UG9pbnRdIG9mIE9iamVjdC5lbnRyaWVzKG1ldGFkYXRhLmVudHJ5UG9pbnRzKSkge1xuICAgICAgY29uc3Qgc3VicGF0aCA9XG4gICAgICAgICAgaXNTZWNvbmRhcnlFbnRyeVBvaW50KG1vZHVsZU5hbWUpID8gYC4vJHtnZXRFbnRyeVBvaW50U3VicGF0aChtb2R1bGVOYW1lKX1gIDogJy4nO1xuICAgICAgY29uc3QgZXNtMjAyMEluZGV4T3V0UmVsYXRpdmVQYXRoID0gZ2V0RXNtMjAyME91dHB1dFJlbGF0aXZlUGF0aChlbnRyeVBvaW50LmluZGV4KTtcbiAgICAgIGNvbnN0IGZlc20yMDIwT3V0UmVsYXRpdmVQYXRoID0gZ2V0RmxhdEVzbU91dHB1dFJlbGF0aXZlUGF0aChlbnRyeVBvaW50LmZlc20yMDIwQnVuZGxlKTtcbiAgICAgIGNvbnN0IGZlc20yMDE1T3V0UmVsYXRpdmVQYXRoID0gZ2V0RmxhdEVzbU91dHB1dFJlbGF0aXZlUGF0aChlbnRyeVBvaW50LmZlc20yMDE1QnVuZGxlKTtcbiAgICAgIGNvbnN0IHR5cGVzT3V0UmVsYXRpdmVQYXRoID0gZ2V0VHlwaW5nT3V0cHV0UmVsYXRpdmVQYXRoKGVudHJ5UG9pbnQudHlwaW5ncyk7XG5cbiAgICAgIC8vIEluc2VydCB0aGUgZXhwb3J0IG1hcHBpbmcgZm9yIHRoZSBlbnRyeS1wb2ludC4gV2Ugc2V0IGBkZWZhdWx0YCB0byB0aGUgRkVTTSAyMDIwXG4gICAgICAvLyBvdXRwdXQsIGFuZCBhbHNvIHNldCB0aGUgYHR5cGVzYCBjb25kaXRpb24gd2hpY2ggd2lsbCBiZSByZXNwZWN0ZWQgYnkgVFMgNC41LlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L3B1bGwvNDU4ODQuXG4gICAgICBpbnNlcnRFeHBvcnRNYXBwaW5nT3JFcnJvcihuZXdQYWNrYWdlSnNvbiwgc3VicGF0aCwge1xuICAgICAgICB0eXBlczogbm9ybWFsaXplUGF0aCh0eXBlc091dFJlbGF0aXZlUGF0aCksXG4gICAgICAgIGVzbTIwMjA6IG5vcm1hbGl6ZVBhdGgoZXNtMjAyMEluZGV4T3V0UmVsYXRpdmVQYXRoKSxcbiAgICAgICAgZXMyMDIwOiBub3JtYWxpemVQYXRoKGZlc20yMDIwT3V0UmVsYXRpdmVQYXRoKSxcbiAgICAgICAgLy8gV2UgYWxzbyBleHBvc2UgYSBub24tc3RhbmRhcmQgY29uZGl0aW9uIHRoYXQgd291bGQgYWxsb3cgY29uc3VtZXJzIHRvIHJlc29sdmVcbiAgICAgICAgLy8gdG8gdGhlIGBFUzIwMTVgIG91dHB1dCBvdXRzaWRlIG9mIE5vZGVKUywgaWYgZGVzaXJlZC5cbiAgICAgICAgLy8gVE9ETyhkZXZ2ZXJzaW9uKTogcmVtb3ZlL3JlcGxhY2UgdGhpcyBpZiBOb2RlSlMgdjEyIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuXG4gICAgICAgIGVzMjAxNTogbm9ybWFsaXplUGF0aChmZXNtMjAxNU91dFJlbGF0aXZlUGF0aCksXG4gICAgICAgIC8vIFdlIGRlY2xhcmUgdGhlIGBub2RlYCBjb25kaXRpb24gYW5kIHBvaW50IHRvIHRoZSBFUzIwMTUgb3V0cHV0IGFzIHdlIGN1cnJlbnRseSBzdGlsbFxuICAgICAgICAvLyBzdXBwb3J0IE5vZGVKUyB2MTIgd2hpY2ggZG9lcyBub3QgZnVsbHkgc3VwcG9ydCBFUzIwMjAgb3V0cHV0LiBXZSBjaG9zZSBFUzIwMTUgb3ZlclxuICAgICAgICAvLyBFUzIwMjkgYmVjYXVzZSB3ZSB3YW4gYXN5bmMvYXdhaXQgZG93bmxldmVsZWQgYXMgdGhpcyBhbGxvd3MgZm9yIHBhdGNoaW5nIHdpdGhab25lSlMuXG4gICAgICAgIC8vIFRPRE8oZGV2dmVyc2lvbik6IHJlbW92ZS9yZXBsYWNlIHRoaXMgaWYgTm9kZUpTIHYxMiBpcyBubyBsb25nZXIgc3VwcG9ydGVkLlxuICAgICAgICBub2RlOiBub3JtYWxpemVQYXRoKGZlc20yMDE1T3V0UmVsYXRpdmVQYXRoKSxcbiAgICAgICAgLy8gTm90ZTogVGhlIGRlZmF1bHQgY29uZGl0aW9ucyBuZWVkcyB0byBiZSB0aGUgbGFzdCBvbmUuXG4gICAgICAgIGRlZmF1bHQ6IG5vcm1hbGl6ZVBhdGgoZmVzbTIwMjBPdXRSZWxhdGl2ZVBhdGgpLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1BhY2thZ2VKc29uO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgYSBzdWJwYXRoIGV4cG9ydCBtYXBwaW5nIGludG8gdGhlIHNwZWNpZmllZCBgcGFja2FnZS5qc29uYCBvYmplY3QuXG4gICAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIG1hcHBpbmcgaXMgYWxyZWFkeSBkZWZpbmVkIGFuZCB3b3VsZCBjb25mbGljdC5cbiAgICovXG4gIGZ1bmN0aW9uIGluc2VydEV4cG9ydE1hcHBpbmdPckVycm9yKFxuICAgICAgcGFja2FnZUpzb246IFBhY2thZ2VKc29uLCBzdWJwYXRoOiBzdHJpbmcsIG1hcHBpbmc6IENvbmRpdGlvbmFsRXhwb3J0KSB7XG4gICAgaWYgKHBhY2thZ2VKc29uLmV4cG9ydHM/LltzdWJwYXRoXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAnRm91bmQgYSBjb25mbGljdGluZyBzdWJwYXRoIGV4cG9ydCBpbiB0aGUgYHBhY2thZ2UuanNvbmAgZmlsZSB0aGF0IHdvdWxkIGJlIG92ZXJyaWRkZW4gYnkgdGhlICcgK1xuICAgICAgICAgIGBwYWNrYWdlci4gUGxlYXNlIHVuc2V0IHRoZSBtYXBwaW5nIGZvcjogXCIke3N1YnBhdGh9XCIuYCk7XG4gICAgfVxuXG4gICAgaWYgKHBhY2thZ2VKc29uLmV4cG9ydHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcGFja2FnZUpzb24uZXhwb3J0cyA9IHt9O1xuICAgIH1cblxuICAgIHBhY2thZ2VKc29uLmV4cG9ydHNbc3VicGF0aF0gPSBtYXBwaW5nO1xuICB9XG5cbiAgLyoqIFdoZXRoZXIgdGhlIHBhY2thZ2UgZXhwbGljaXRseSBzZXRzIGFueSBvZiB0aGUgZm9ybWF0IHByb3BlcnRpZXMgKGxpa2UgYG1haW5gKS4gKi9cbiAgZnVuY3Rpb24gaGFzRXhwbGljaXRGb3JtYXRQcm9wZXJ0aWVzKHBhcnNlZFBhY2thZ2U6IFJlYWRvbmx5PFBhY2thZ2VKc29uPik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhwYXJzZWRQYWNrYWdlKVxuICAgICAgICAuc29tZShcbiAgICAgICAgICAgIChmaWVsZE5hbWU6IEtub3duUGFja2FnZUpzb25Gb3JtYXRGaWVsZHMpID0+XG4gICAgICAgICAgICAgICAga25vd25Gb3JtYXRQYWNrYWdlSnNvbkZvcm1hdEZpZWxkcy5pbmNsdWRlcyhmaWVsZE5hbWUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcGFja2FnZS5qc29uIGZvciBhIHNlY29uZGFyeSBlbnRyeS1wb2ludC5cbiAgICogQHBhcmFtIGRpciBUaGUgZGlyZWN0b3J5IHVuZGVyIHdoaWNoIHRoZSBwYWNrYWdlLmpzb24gc2hvdWxkIGJlIHdyaXR0ZW4uXG4gICAqIEBwYXJhbSBlbnRyeVBvaW50UGFja2FnZU5hbWUgVGhlIGZ1bGwgcGFja2FnZSBuYW1lIGZvciB0aGUgZW50cnkgcG9pbnQsXG4gICAqICAgICBlLmcuICdAYW5ndWxhci9jb21tb24vaHR0cCcuXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVTZWNvbmRhcnlFbnRyeVBvaW50UGFja2FnZUpzb24oZGlyOiBzdHJpbmcsIGVudHJ5UG9pbnRQYWNrYWdlTmFtZTogc3RyaW5nKSB7XG4gICAgY29uc3QgcmVsYXRpdmVPdXRQYXRoID0gcGF0aC5qb2luKGRpciwgJ3BhY2thZ2UuanNvbicpO1xuICAgIGNvbnN0IGNvbnRlbnQgPVxuICAgICAgICBpbnNlcnRGb3JtYXRGaWVsZHNJbnRvUGFja2FnZUpzb24ocmVsYXRpdmVPdXRQYXRoLCB7bmFtZTogZW50cnlQb2ludFBhY2thZ2VOYW1lfSwgdHJ1ZSk7XG4gICAgd3JpdGVGaWxlKHJlbGF0aXZlT3V0UGF0aCwgSlNPTi5zdHJpbmdpZnkoY29udGVudCwgbnVsbCwgMikpO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZXMgdGhlIHNwZWNpZmllZCBwYXRoIGJ5IHJlcGxhY2luZyBiYWNrc2xhc2ggc2VwYXJhdG9ycyB3aXRoIFBvc2l4XG4gICAqIGZvcndhcmQgc2xhc2ggc2VwYXJhdG9ycy5cbiAgICovXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVBhdGgocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCByZXN1bHQgPSBwYXRoLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcbiAgICByZXR1cm4gcmVzdWx0LnN0YXJ0c1dpdGgoJy4nKSA/IHJlc3VsdCA6IGAuLyR7cmVzdWx0fWA7XG4gIH1cblxuICAvKipcbiAgICogU3RyaXAgdGhlIG5hbWVkIEFNRCBtb2R1bGUgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24tYmF6ZWwgdXNlcnMgZnJvbSB0eXBpbmdzIGNvbnRlbnRcbiAgICogQHBhcmFtIGZpbGVQYXRoIGR0cyBmaWxlIHBhdGhcbiAgICovXG4gIGZ1bmN0aW9uIHJlYWRUeXBpbmdzQW5kU3RyaXBBbWRNb2R1bGUoZmlsZVBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGZzXG4gICAgICAgIC5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsICd1dGYtOCcpXG4gICAgICAgIC8vIFN0cmlwIHRoZSBuYW1lZCBBTUQgbW9kdWxlIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWJhemVsIHVzZXJzXG4gICAgICAgIC5yZXBsYWNlKC9eXFwvXFwvXFwvIDxhbWQtbW9kdWxlIG5hbWU9LipcXC8+W1xcclxcbl0rL2dtLCAnJyk7XG4gIH1cbn1cblxuaWYgKHJlcXVpcmUubWFpbiA9PT0gbW9kdWxlKSB7XG4gIG1haW4ocHJvY2Vzcy5hcmd2LnNsaWNlKDIpKTtcbn1cbiJdfQ==