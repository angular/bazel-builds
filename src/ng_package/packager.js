/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("angular/packages/bazel/src/ng_package/packager", ["require", "exports", "fs", "path", "shelljs"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.newArray = void 0;
    const fs = require("fs");
    const path = require("path");
    const shx = require("shelljs");
    function main(args) {
        // Exit immediately when encountering an error.
        shx.set('-e');
        // Keep track of whether an error has occured so that we can return an appropriate exit code.
        let errorHasOccured = false;
        // This utility expects all of its arguments to be specified in a params file generated by
        // bazel (see https://docs.bazel.build/versions/master/skylark/lib/Args.html#use_param_file).
        const paramFilePath = args[0];
        // Bazel params may be surrounded with quotes
        function unquoteParameter(s) {
            return s.replace(/^'(.*)'$/, '$1');
        }
        // Parameters are specified in the file one per line.
        const params = fs.readFileSync(paramFilePath, 'utf-8').split('\n').map(unquoteParameter);
        const [
        // Output directory for the npm package.
        out, 
        // The package segment of the ng_package rule's label (e.g. 'package/common').
        srcDir, 
        // The bazel-bin dir joined with the srcDir (e.g. 'bazel-bin/package.common').
        // This is the intended output location for package artifacts.
        binDir, 
        // The bazel-genfiles dir joined with the srcDir (e.g. 'bazel-bin/package.common').
        genfilesDir, 
        // JSON data mapping each entry point to the generated bundle index and
        // flat module metadata, for example
        // {"@angular/core": {
        //     "index": "bazel-bin/packages/core/core.js",
        //     "typings": "bazel-bin/packages/core/core.d.ts",
        //     "metadata": "bazel-bin/packages/core/core.metadata.json"
        //  },
        // ...
        // }
        modulesManifestArg, 
        // Path to the package's README.md.
        readmeMd, 
        // List of rolled-up flat ES2015 modules
        fesm2015Arg, 
        // List of individual ES2015 modules
        esm2015Arg, 
        // List of all UMD bundles generated by rollup.
        bundlesArg, 
        // List of all files in the ng_package rule's srcs.
        srcsArg, 
        // List of all type definitions that need to packaged into the ng_package.
        typeDefinitionsArg, 
        // List of all files in the ng_package rule's data.
        dataArg, 
        // Path to the package's LICENSE.
        licenseFile, 
        // List of all dts bundles generated by the API extractor.
        dtsBundleArg, 
        // The dts bundle file suffix example: '.bundle.d.ts'
        dtsBundleFileSuffix,] = params;
        const fesm2015 = fesm2015Arg.split(',').filter(s => !!s);
        const esm2015 = esm2015Arg.split(',').filter(s => !!s);
        const bundles = bundlesArg.split(',').filter(s => !!s);
        const typeDefinitions = typeDefinitionsArg.split(',').filter(s => !!s);
        const srcs = srcsArg.split(',').filter(s => !!s);
        const dataFiles = dataArg.split(',').filter(s => !!s);
        const modulesManifest = JSON.parse(modulesManifestArg);
        const dtsBundles = dtsBundleArg.split(',').filter(s => !!s);
        /**
         * List of known `package.json` fields which provide information about
         * supported package formats and their associated entry paths.
         */
        const knownFormatPackageJsonFields = ['main', 'fesm2015', 'esm2015', 'typings', 'module', 'es2015'];
        if (readmeMd) {
            copyFile(readmeMd, out);
        }
        /**
         * Writes a file into the package based on its input path, relativizing to the package path.
         * @param inputPath Path to the file in the input tree.
         * @param fileContent Content of the file.
         */
        function writeFileFromInputPath(inputPath, fileContent) {
            // We want the relative path from the given file to its ancestor "root" directory.
            // This root depends on whether the file lives in the source tree (srcDir) as a basic file
            // input to ng_package, the bin output tree (binDir) as the output of another rule, or
            // the genfiles output tree (genfilesDir) as the output of a genrule.
            let rootDir;
            if (inputPath.includes(binDir)) {
                rootDir = binDir;
            }
            else if (inputPath.includes(genfilesDir)) {
                rootDir = genfilesDir;
            }
            else {
                rootDir = srcDir;
            }
            const outputPath = path.join(out, path.relative(rootDir, inputPath));
            // Always ensure that the target directory exists.
            shx.mkdir('-p', path.dirname(outputPath));
            fs.writeFileSync(outputPath, fileContent);
        }
        /**
         * Copies a file into the package based on its input path, relativizing to the package path.
         * @param inputPath a path relative to the binDir, typically from a file in the deps[]
         */
        function copyFileFromInputPath(inputPath) {
            writeFileFromInputPath(inputPath, fs.readFileSync(inputPath));
        }
        /**
         * Relativize the path where a file is written.
         * @param file a path containing a re-rooted segment like `.esm2015`
         * @param outDir path where we copy the file, relative to the out
         */
        function writeEsmFile(file, outDir) {
            // Path computed relative to the current package in bazel-bin. e.g. a ES2015 output file
            // in `bazel-out/<..>/packages/core/src/di.js` should be stored in `{out_dir}/src/di.js`
            // if the package target has been declared in `<..>/packages/core`.
            const packageRelativePath = path.dirname(path.relative(binDir, file));
            if (!packageRelativePath.startsWith('..')) {
                copyFile(file, path.join(out, outDir), packageRelativePath);
            }
        }
        esm2015.forEach(file => writeEsmFile(file, 'esm2015'));
        bundles.forEach(bundle => {
            copyFile(bundle, out, 'bundles');
        });
        fesm2015.forEach(file => {
            copyFile(file, out, 'fesm2015');
        });
        // Copy all type definitions into the package. This is necessary so that developers can use
        // the package with type definitions.
        typeDefinitions.forEach(f => writeFileFromInputPath(f, readTypingsAndStripAmdModule(f)));
        // Copy all `data` files into the package. These are files that aren't built by the ng_package
        // rule, but instead are just straight copied into the package, e.g. global CSS assets.
        dataFiles.forEach(f => copyFileFromInputPath(f));
        // Iterate through the entry point modules
        // We do this first because we also record new paths for the esm5 and esm2015 copies
        // of the index JS file, which we need to amend the package.json.
        Object.keys(modulesManifest).forEach(moduleName => {
            const moduleFiles = modulesManifest[moduleName];
            const relative = path.relative(binDir, moduleFiles['index']);
            moduleFiles['esm2015_index'] = path.join(binDir, 'esm2015', relative);
            // Metadata file is optional as entry-points can be built with the `ts_library`
            // rule or `ng_module` rule in Ivy mode.
            const metadataFile = moduleFiles['metadata'];
            if (!metadataFile) {
                return;
            }
            const typingsOutFile = moduleFiles['typings'];
            // We only support all modules within a package to be dts bundled
            // ie: if @angular/common/http has flat dts, so should @angular/common
            if (dtsBundles.length) {
                const metadataContent = rewireMetadata(metadataFile, typingsOutFile);
                writeFileFromInputPath(metadataFile, metadataContent);
            }
            else {
                copyFileFromInputPath(metadataFile);
            }
        });
        const licenseBanner = licenseFile ? fs.readFileSync(licenseFile, 'utf-8') : '';
        dtsBundles.forEach(bundleFile => {
            const cleanDistPath = bundleFile.replace(dtsBundleFileSuffix, '.d.ts');
            // API extractor will not dedupe license comments from various files
            // this will remove all the license comments and append the license banner.
            const content = licenseBanner + '\n' +
                readTypingsAndStripAmdModule(bundleFile)
                    .replace(/(\/\*\*\s+\*\s\@license(((?!\*\/).|\s)*)\*\/)/gm, '');
            writeFileFromInputPath(cleanDistPath, content);
        });
        // Root package name (e.g. '@angular/common'), captures as we iterate through sources below.
        let rootPackageName = '';
        const packagesWithExistingPackageJson = new Set();
        for (const src of srcs) {
            if (src.includes(binDir) || src.includes(genfilesDir)) {
                errorHasOccured = true;
                console.error('The "srcs" for ng_package should not include output of other rules. Found:\n' +
                    `  ${src}`);
            }
            let content = fs.readFileSync(src, 'utf-8');
            // Modify package.json files as necessary for publishing
            if (path.basename(src) === 'package.json') {
                const packageJson = JSON.parse(content);
                content = amendPackageJson(src, packageJson, false);
                const packageName = packageJson['name'];
                packagesWithExistingPackageJson.add(packageName);
                // Keep track of the root package name, e.g. "@angular/common". We assume that the
                // root name will be shortest because secondary entry-points will append to it
                // (e.g. "@angular/common/http").
                if (!rootPackageName || packageName.length < rootPackageName.length) {
                    rootPackageName = packageJson['name'];
                }
            }
            writeFileFromInputPath(src, content);
        }
        // Generate extra files for secondary entry-points.
        Object.keys(modulesManifest).forEach(entryPointPackageName => {
            const entryPointName = entryPointPackageName.substr(rootPackageName.length + 1);
            if (!entryPointName)
                return;
            const metadataFilePath = modulesManifest[entryPointPackageName]['metadata'];
            if (metadataFilePath) {
                createMetadataReexportFile(entryPointName, modulesManifest[entryPointPackageName]['metadata'], entryPointPackageName);
            }
            createTypingsReexportFile(entryPointName, licenseBanner, modulesManifest[entryPointPackageName]['typings']);
            if (!packagesWithExistingPackageJson.has(entryPointPackageName)) {
                createEntryPointPackageJson(entryPointName, entryPointPackageName);
            }
        });
        return errorHasOccured ? 1 : 0;
        /**
         * Convert a binDir-relative path to srcDir-relative
         * @param from path to a file under the srcDir, like packages/core/testing/package.json
         * @param file path to a file under the binDir, like bazel-bin/core/testing/generated.js
         */
        function srcDirRelative(from, file) {
            const result = normalizeSeparators(path.relative(path.dirname(from), path.join(srcDir, path.relative(binDir, file))));
            if (result.startsWith('..'))
                return result;
            return `./${result}`;
        }
        function copyFile(file, baseDir, relative = '.') {
            const dir = path.join(baseDir, relative);
            // output file is .js if the input file is .mjs
            const outFile = path.posix.join(dir, path.basename(file.endsWith('.mjs') ? file.replace(/\.mjs$/, '.js') : file));
            shx.mkdir('-p', dir);
            shx.cp(file, outFile);
            // Double-underscore is used to escape forward slash in FESM filenames.
            // See ng_package.bzl:
            //   fesm_output_filename = entry_point.replace("/", "__")
            // We need to unescape these.
            if (outFile.indexOf('__') >= 0) {
                const outputPath = path.join(dir, ...path.basename(outFile).split('__'));
                shx.mkdir('-p', path.dirname(outputPath));
                shx.mv(path.join(dir, path.basename(file)), outputPath);
                // if we are renaming the .js file, we'll also need to update the sourceMappingURL in the file
                if (outFile.endsWith('.js')) {
                    shx.chmod('+w', outputPath);
                    shx.sed('-i', `${path.basename(file)}.map`, `${path.basename(outputPath)}.map`, outputPath);
                }
            }
        }
        /**
         * Inserts or edits properties into the package.json file(s) in the package so that
         * they point to all the right generated artifacts.
         *
         * @param packageJson The path to the package.json file.
         * @param parsedPackage Parsed package.json content
         * @param isGeneratedPackageJson Whether the passed package.json has been generated.
         */
        function amendPackageJson(packageJson, parsedPackage, isGeneratedPackageJson) {
            const packageName = parsedPackage['name'];
            const moduleData = modulesManifest[packageName];
            // If a package json file has been discovered that does not match any
            // module in the manifest, we report a warning as most likely the target
            // is configured incorrectly (e.g. missing `module_name` attribute).
            if (!moduleData) {
                // Ideally we should throw here, as we got an entry point that doesn't
                // have flat module metadata / bundle index, so it may have been an
                // ng_module that's missing a module_name attribute.
                // However, @angular/compiler can't be an ng_module, as it's the internals
                // of the ngc compiler, yet we want to build an ng_package for it.
                // So ignore package.json files when we are missing data.
                console.error('WARNING: no module metadata for package', packageName);
                console.error('   Not updating the package.json file to point to it');
                console.error('   The ng_module for this package is possibly missing the module_name attribute ');
                return JSON.stringify(parsedPackage, null, 2);
            }
            // If we guessed the index paths for a module, and it contains an explicit `package.json`
            // file that already sets format properties, we skip automatic insertion of format
            // properties but report a warning in case properties have been set by accident.
            if (moduleData.guessedPaths && !isGeneratedPackageJson &&
                hasExplicitFormatProperties(parsedPackage)) {
                console.error('WARNING: `package.json` explicitly sets format properties (like `main`).');
                console.error('    Skipping automatic insertion of format properties as explicit ' +
                    'format properties are set.');
                console.error('    Ignore this warning if explicit properties are set intentionally.');
                return JSON.stringify(parsedPackage, null, 2);
            }
            // Derive the paths to the files from the hard-coded names we gave them.
            // TODO(alexeagle): it would be better to transfer this information from the place
            // where we created the filenames, via the modulesManifestArg
            parsedPackage['main'] = getBundleName(packageName, 'bundles');
            parsedPackage['fesm2015'] = getBundleName(packageName, 'fesm2015');
            parsedPackage['esm2015'] = srcDirRelative(packageJson, moduleData['esm2015_index']);
            parsedPackage['typings'] = srcDirRelative(packageJson, moduleData['typings']);
            // For now, we point the primary entry points at the fesm files, because of Webpack
            // performance issues with a large number of individual files.
            parsedPackage['module'] = parsedPackage['fesm2015'];
            parsedPackage['es2015'] = parsedPackage['fesm2015'];
            return JSON.stringify(parsedPackage, null, 2);
        }
        // e.g. @angular/common/http/testing -> ../../bundles/common-http-testing.umd.js
        // or   @angular/common/http/testing -> ../../fesm2015/http/testing.js
        function getBundleName(packageName, dir) {
            const parts = packageName.split('/');
            // Remove the scoped package part, like @angular if present
            const nameParts = packageName.startsWith('@') ? parts.splice(1) : parts;
            const relativePath = newArray(nameParts.length - 1, '..').join('/') || '.';
            let basename;
            if (dir === 'bundles') {
                basename = nameParts.join('-') + '.umd';
            }
            else if (nameParts.length === 1) {
                basename = nameParts[0];
            }
            else {
                basename = nameParts.slice(1).join('/');
            }
            return [relativePath, dir, basename + '.js'].join('/');
        }
        /** Whether the package explicitly sets any of the format properties (like `main`). */
        function hasExplicitFormatProperties(parsedPackage) {
            return Object.keys(parsedPackage)
                .some(propertyName => knownFormatPackageJsonFields.includes(propertyName));
        }
        /** Creates metadata re-export file for a secondary entry-point. */
        function createMetadataReexportFile(entryPointName, metadataFile, packageName) {
            const inputPath = path.join(srcDir, `${entryPointName}.metadata.json`);
            writeFileFromInputPath(inputPath, JSON.stringify({
                '__symbolic': 'module',
                'version': 3,
                'metadata': {},
                'exports': [{ 'from': `${srcDirRelative(inputPath, metadataFile.replace(/.metadata.json$/, ''))}` }],
                'flatModuleIndexRedirect': true,
                'importAs': packageName
            }) + '\n');
        }
        /**
         * Creates a typings (d.ts) re-export file for a secondary-entry point,
         * e.g., `export * from './common/common'`
         */
        function createTypingsReexportFile(entryPointName, license, typingsFile) {
            const inputPath = path.join(srcDir, `${entryPointName}.d.ts`);
            const content = `${license}
export * from '${srcDirRelative(inputPath, typingsFile.replace(/\.d\.tsx?$/, ''))}';
`;
            writeFileFromInputPath(inputPath, content);
        }
        /**
         * Creates a package.json for a secondary entry-point.
         * @param dir The directory under which the package.json should be written.
         * @param entryPointPackageName The full package name for the entry point,
         *     e.g. '@angular/common/http'.
         */
        function createEntryPointPackageJson(dir, entryPointPackageName) {
            const pkgJson = path.join(srcDir, dir, 'package.json');
            const content = amendPackageJson(pkgJson, { name: entryPointPackageName }, true);
            writeFileFromInputPath(pkgJson, content);
        }
        /**
         * Normalizes the specified path by replacing backslash separators with Posix
         * forward slash separators.
         */
        function normalizeSeparators(path) {
            return path.replace(/\\/g, '/');
        }
        /**
         * Rewires metadata to point to the flattened dts file.
         *
         * @param metadataPath the metadata file path
         * @param typingsPath the typings bundle entrypoint
         */
        function rewireMetadata(metadataPath, typingsPath) {
            const metadata = JSON.parse(fs.readFileSync(metadataPath, 'utf-8'));
            let typingsRelativePath = normalizeSeparators(path.relative(path.dirname(metadataPath), typingsPath));
            if (!typingsRelativePath.startsWith('..')) {
                typingsRelativePath = `./${typingsRelativePath}`;
            }
            typingsRelativePath = typingsRelativePath.replace('.d.ts', '');
            // the regexp here catches all relative paths such as:
            // ./src/core/foo.d.ts and ../src/core/foo.d.ts
            const relativePathRegex = /\.?\.\/[\w\.\-_\/]+/g;
            if (metadata.exports) {
                // Strip re-exports which are now self-references
                metadata.exports =
                    metadata.exports.filter((e) => !e.from.match(relativePathRegex));
            }
            return JSON.stringify(metadata).replace(relativePathRegex, typingsRelativePath);
        }
        /**
         * Strip the named AMD module for compatibility with non-bazel users from typings content
         * @param filePath dts file path
         */
        function readTypingsAndStripAmdModule(filePath) {
            return fs
                .readFileSync(filePath, 'utf-8')
                // Strip the named AMD module for compatibility with non-bazel users
                .replace(/^\/\/\/ <amd-module name=.*\/>[\r\n]+/gm, '');
        }
    }
    if (require.main === module) {
        process.exitCode = main(process.argv.slice(2));
    }
    function newArray(size, value) {
        const list = [];
        for (let i = 0; i < size; i++) {
            list.push(value);
        }
        return list;
    }
    exports.newArray = newArray;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFja2FnZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9iYXplbC9zcmMvbmdfcGFja2FnZS9wYWNrYWdlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7Ozs7Ozs7Ozs7Ozs7SUFFSCx5QkFBeUI7SUFDekIsNkJBQTZCO0lBQzdCLCtCQUErQjtJQUUvQixTQUFTLElBQUksQ0FBQyxJQUFjO1FBQzFCLCtDQUErQztRQUMvQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRWQsNkZBQTZGO1FBQzdGLElBQUksZUFBZSxHQUFHLEtBQUssQ0FBQztRQUU1QiwwRkFBMEY7UUFDMUYsNkZBQTZGO1FBQzdGLE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUU5Qiw2Q0FBNkM7UUFDN0MsU0FBUyxnQkFBZ0IsQ0FBQyxDQUFTO1lBQ2pDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDckMsQ0FBQztRQUVELHFEQUFxRDtRQUNyRCxNQUFNLE1BQU0sR0FBRyxFQUFFLENBQUMsWUFBWSxDQUFDLGFBQWEsRUFBRSxPQUFPLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFFekYsTUFBTTtRQUNGLHdDQUF3QztRQUN4QyxHQUFHO1FBRUgsOEVBQThFO1FBQzlFLE1BQU07UUFFTiw4RUFBOEU7UUFDOUUsOERBQThEO1FBQzlELE1BQU07UUFFTixtRkFBbUY7UUFDbkYsV0FBVztRQUVYLHVFQUF1RTtRQUN2RSxvQ0FBb0M7UUFDcEMsc0JBQXNCO1FBQ3RCLGtEQUFrRDtRQUNsRCxzREFBc0Q7UUFDdEQsK0RBQStEO1FBQy9ELE1BQU07UUFDTixNQUFNO1FBQ04sSUFBSTtRQUNKLGtCQUFrQjtRQUVsQixtQ0FBbUM7UUFD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c0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyBzaHggZnJvbSAnc2hlbGxqcyc7XG5cbmZ1bmN0aW9uIG1haW4oYXJnczogc3RyaW5nW10pOiBudW1iZXIge1xuICAvLyBFeGl0IGltbWVkaWF0ZWx5IHdoZW4gZW5jb3VudGVyaW5nIGFuIGVycm9yLlxuICBzaHguc2V0KCctZScpO1xuXG4gIC8vIEtlZXAgdHJhY2sgb2Ygd2hldGhlciBhbiBlcnJvciBoYXMgb2NjdXJlZCBzbyB0aGF0IHdlIGNhbiByZXR1cm4gYW4gYXBwcm9wcmlhdGUgZXhpdCBjb2RlLlxuICBsZXQgZXJyb3JIYXNPY2N1cmVkID0gZmFsc2U7XG5cbiAgLy8gVGhpcyB1dGlsaXR5IGV4cGVjdHMgYWxsIG9mIGl0cyBhcmd1bWVudHMgdG8gYmUgc3BlY2lmaWVkIGluIGEgcGFyYW1zIGZpbGUgZ2VuZXJhdGVkIGJ5XG4gIC8vIGJhemVsIChzZWUgaHR0cHM6Ly9kb2NzLmJhemVsLmJ1aWxkL3ZlcnNpb25zL21hc3Rlci9za3lsYXJrL2xpYi9BcmdzLmh0bWwjdXNlX3BhcmFtX2ZpbGUpLlxuICBjb25zdCBwYXJhbUZpbGVQYXRoID0gYXJnc1swXTtcblxuICAvLyBCYXplbCBwYXJhbXMgbWF5IGJlIHN1cnJvdW5kZWQgd2l0aCBxdW90ZXNcbiAgZnVuY3Rpb24gdW5xdW90ZVBhcmFtZXRlcihzOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKC9eJyguKiknJC8sICckMScpO1xuICB9XG5cbiAgLy8gUGFyYW1ldGVycyBhcmUgc3BlY2lmaWVkIGluIHRoZSBmaWxlIG9uZSBwZXIgbGluZS5cbiAgY29uc3QgcGFyYW1zID0gZnMucmVhZEZpbGVTeW5jKHBhcmFtRmlsZVBhdGgsICd1dGYtOCcpLnNwbGl0KCdcXG4nKS5tYXAodW5xdW90ZVBhcmFtZXRlcik7XG5cbiAgY29uc3QgW1xuICAgICAgLy8gT3V0cHV0IGRpcmVjdG9yeSBmb3IgdGhlIG5wbSBwYWNrYWdlLlxuICAgICAgb3V0LFxuXG4gICAgICAvLyBUaGUgcGFja2FnZSBzZWdtZW50IG9mIHRoZSBuZ19wYWNrYWdlIHJ1bGUncyBsYWJlbCAoZS5nLiAncGFja2FnZS9jb21tb24nKS5cbiAgICAgIHNyY0RpcixcblxuICAgICAgLy8gVGhlIGJhemVsLWJpbiBkaXIgam9pbmVkIHdpdGggdGhlIHNyY0RpciAoZS5nLiAnYmF6ZWwtYmluL3BhY2thZ2UuY29tbW9uJykuXG4gICAgICAvLyBUaGlzIGlzIHRoZSBpbnRlbmRlZCBvdXRwdXQgbG9jYXRpb24gZm9yIHBhY2thZ2UgYXJ0aWZhY3RzLlxuICAgICAgYmluRGlyLFxuXG4gICAgICAvLyBUaGUgYmF6ZWwtZ2VuZmlsZXMgZGlyIGpvaW5lZCB3aXRoIHRoZSBzcmNEaXIgKGUuZy4gJ2JhemVsLWJpbi9wYWNrYWdlLmNvbW1vbicpLlxuICAgICAgZ2VuZmlsZXNEaXIsXG5cbiAgICAgIC8vIEpTT04gZGF0YSBtYXBwaW5nIGVhY2ggZW50cnkgcG9pbnQgdG8gdGhlIGdlbmVyYXRlZCBidW5kbGUgaW5kZXggYW5kXG4gICAgICAvLyBmbGF0IG1vZHVsZSBtZXRhZGF0YSwgZm9yIGV4YW1wbGVcbiAgICAgIC8vIHtcIkBhbmd1bGFyL2NvcmVcIjoge1xuICAgICAgLy8gICAgIFwiaW5kZXhcIjogXCJiYXplbC1iaW4vcGFja2FnZXMvY29yZS9jb3JlLmpzXCIsXG4gICAgICAvLyAgICAgXCJ0eXBpbmdzXCI6IFwiYmF6ZWwtYmluL3BhY2thZ2VzL2NvcmUvY29yZS5kLnRzXCIsXG4gICAgICAvLyAgICAgXCJtZXRhZGF0YVwiOiBcImJhemVsLWJpbi9wYWNrYWdlcy9jb3JlL2NvcmUubWV0YWRhdGEuanNvblwiXG4gICAgICAvLyAgfSxcbiAgICAgIC8vIC4uLlxuICAgICAgLy8gfVxuICAgICAgbW9kdWxlc01hbmlmZXN0QXJnLFxuXG4gICAgICAvLyBQYXRoIHRvIHRoZSBwYWNrYWdlJ3MgUkVBRE1FLm1kLlxuICAgICAgcmVhZG1lTWQsXG5cbiAgICAgIC8vIExpc3Qgb2Ygcm9sbGVkLXVwIGZsYXQgRVMyMDE1IG1vZHVsZXNcbiAgICAgIGZlc20yMDE1QXJnLFxuXG4gICAgICAvLyBMaXN0IG9mIGluZGl2aWR1YWwgRVMyMDE1IG1vZHVsZXNcbiAgICAgIGVzbTIwMTVBcmcsXG5cbiAgICAgIC8vIExpc3Qgb2YgYWxsIFVNRCBidW5kbGVzIGdlbmVyYXRlZCBieSByb2xsdXAuXG4gICAgICBidW5kbGVzQXJnLFxuXG4gICAgICAvLyBMaXN0IG9mIGFsbCBmaWxlcyBpbiB0aGUgbmdfcGFja2FnZSBydWxlJ3Mgc3Jjcy5cbiAgICAgIHNyY3NBcmcsXG5cbiAgICAgIC8vIExpc3Qgb2YgYWxsIHR5cGUgZGVmaW5pdGlvbnMgdGhhdCBuZWVkIHRvIHBhY2thZ2VkIGludG8gdGhlIG5nX3BhY2thZ2UuXG4gICAgICB0eXBlRGVmaW5pdGlvbnNBcmcsXG5cbiAgICAgIC8vIExpc3Qgb2YgYWxsIGZpbGVzIGluIHRoZSBuZ19wYWNrYWdlIHJ1bGUncyBkYXRhLlxuICAgICAgZGF0YUFyZyxcblxuICAgICAgLy8gUGF0aCB0byB0aGUgcGFja2FnZSdzIExJQ0VOU0UuXG4gICAgICBsaWNlbnNlRmlsZSxcblxuICAgICAgLy8gTGlzdCBvZiBhbGwgZHRzIGJ1bmRsZXMgZ2VuZXJhdGVkIGJ5IHRoZSBBUEkgZXh0cmFjdG9yLlxuICAgICAgZHRzQnVuZGxlQXJnLFxuXG4gICAgICAvLyBUaGUgZHRzIGJ1bmRsZSBmaWxlIHN1ZmZpeCBleGFtcGxlOiAnLmJ1bmRsZS5kLnRzJ1xuICAgICAgZHRzQnVuZGxlRmlsZVN1ZmZpeCxcbiAgXSA9IHBhcmFtcztcblxuICBjb25zdCBmZXNtMjAxNSA9IGZlc20yMDE1QXJnLnNwbGl0KCcsJykuZmlsdGVyKHMgPT4gISFzKTtcbiAgY29uc3QgZXNtMjAxNSA9IGVzbTIwMTVBcmcuc3BsaXQoJywnKS5maWx0ZXIocyA9PiAhIXMpO1xuICBjb25zdCBidW5kbGVzID0gYnVuZGxlc0FyZy5zcGxpdCgnLCcpLmZpbHRlcihzID0+ICEhcyk7XG4gIGNvbnN0IHR5cGVEZWZpbml0aW9ucyA9IHR5cGVEZWZpbml0aW9uc0FyZy5zcGxpdCgnLCcpLmZpbHRlcihzID0+ICEhcyk7XG4gIGNvbnN0IHNyY3MgPSBzcmNzQXJnLnNwbGl0KCcsJykuZmlsdGVyKHMgPT4gISFzKTtcbiAgY29uc3QgZGF0YUZpbGVzOiBzdHJpbmdbXSA9IGRhdGFBcmcuc3BsaXQoJywnKS5maWx0ZXIocyA9PiAhIXMpO1xuICBjb25zdCBtb2R1bGVzTWFuaWZlc3QgPSBKU09OLnBhcnNlKG1vZHVsZXNNYW5pZmVzdEFyZykgYXMgUmVjb3JkPHN0cmluZywgYW55PjtcbiAgY29uc3QgZHRzQnVuZGxlczogc3RyaW5nW10gPSBkdHNCdW5kbGVBcmcuc3BsaXQoJywnKS5maWx0ZXIocyA9PiAhIXMpO1xuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGtub3duIGBwYWNrYWdlLmpzb25gIGZpZWxkcyB3aGljaCBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0XG4gICAqIHN1cHBvcnRlZCBwYWNrYWdlIGZvcm1hdHMgYW5kIHRoZWlyIGFzc29jaWF0ZWQgZW50cnkgcGF0aHMuXG4gICAqL1xuICBjb25zdCBrbm93bkZvcm1hdFBhY2thZ2VKc29uRmllbGRzID1cbiAgICAgIFsnbWFpbicsICdmZXNtMjAxNScsICdlc20yMDE1JywgJ3R5cGluZ3MnLCAnbW9kdWxlJywgJ2VzMjAxNSddO1xuXG4gIGlmIChyZWFkbWVNZCkge1xuICAgIGNvcHlGaWxlKHJlYWRtZU1kLCBvdXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlcyBhIGZpbGUgaW50byB0aGUgcGFja2FnZSBiYXNlZCBvbiBpdHMgaW5wdXQgcGF0aCwgcmVsYXRpdml6aW5nIHRvIHRoZSBwYWNrYWdlIHBhdGguXG4gICAqIEBwYXJhbSBpbnB1dFBhdGggUGF0aCB0byB0aGUgZmlsZSBpbiB0aGUgaW5wdXQgdHJlZS5cbiAgICogQHBhcmFtIGZpbGVDb250ZW50IENvbnRlbnQgb2YgdGhlIGZpbGUuXG4gICAqL1xuICBmdW5jdGlvbiB3cml0ZUZpbGVGcm9tSW5wdXRQYXRoKGlucHV0UGF0aDogc3RyaW5nLCBmaWxlQ29udGVudDogc3RyaW5nfEJ1ZmZlcikge1xuICAgIC8vIFdlIHdhbnQgdGhlIHJlbGF0aXZlIHBhdGggZnJvbSB0aGUgZ2l2ZW4gZmlsZSB0byBpdHMgYW5jZXN0b3IgXCJyb290XCIgZGlyZWN0b3J5LlxuICAgIC8vIFRoaXMgcm9vdCBkZXBlbmRzIG9uIHdoZXRoZXIgdGhlIGZpbGUgbGl2ZXMgaW4gdGhlIHNvdXJjZSB0cmVlIChzcmNEaXIpIGFzIGEgYmFzaWMgZmlsZVxuICAgIC8vIGlucHV0IHRvIG5nX3BhY2thZ2UsIHRoZSBiaW4gb3V0cHV0IHRyZWUgKGJpbkRpcikgYXMgdGhlIG91dHB1dCBvZiBhbm90aGVyIHJ1bGUsIG9yXG4gICAgLy8gdGhlIGdlbmZpbGVzIG91dHB1dCB0cmVlIChnZW5maWxlc0RpcikgYXMgdGhlIG91dHB1dCBvZiBhIGdlbnJ1bGUuXG4gICAgbGV0IHJvb3REaXI6IHN0cmluZztcbiAgICBpZiAoaW5wdXRQYXRoLmluY2x1ZGVzKGJpbkRpcikpIHtcbiAgICAgIHJvb3REaXIgPSBiaW5EaXI7XG4gICAgfSBlbHNlIGlmIChpbnB1dFBhdGguaW5jbHVkZXMoZ2VuZmlsZXNEaXIpKSB7XG4gICAgICByb290RGlyID0gZ2VuZmlsZXNEaXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvb3REaXIgPSBzcmNEaXI7XG4gICAgfVxuXG4gICAgY29uc3Qgb3V0cHV0UGF0aCA9IHBhdGguam9pbihvdXQsIHBhdGgucmVsYXRpdmUocm9vdERpciwgaW5wdXRQYXRoKSk7XG5cbiAgICAvLyBBbHdheXMgZW5zdXJlIHRoYXQgdGhlIHRhcmdldCBkaXJlY3RvcnkgZXhpc3RzLlxuICAgIHNoeC5ta2RpcignLXAnLCBwYXRoLmRpcm5hbWUob3V0cHV0UGF0aCkpO1xuICAgIGZzLndyaXRlRmlsZVN5bmMob3V0cHV0UGF0aCwgZmlsZUNvbnRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvcGllcyBhIGZpbGUgaW50byB0aGUgcGFja2FnZSBiYXNlZCBvbiBpdHMgaW5wdXQgcGF0aCwgcmVsYXRpdml6aW5nIHRvIHRoZSBwYWNrYWdlIHBhdGguXG4gICAqIEBwYXJhbSBpbnB1dFBhdGggYSBwYXRoIHJlbGF0aXZlIHRvIHRoZSBiaW5EaXIsIHR5cGljYWxseSBmcm9tIGEgZmlsZSBpbiB0aGUgZGVwc1tdXG4gICAqL1xuICBmdW5jdGlvbiBjb3B5RmlsZUZyb21JbnB1dFBhdGgoaW5wdXRQYXRoOiBzdHJpbmcpIHtcbiAgICB3cml0ZUZpbGVGcm9tSW5wdXRQYXRoKGlucHV0UGF0aCwgZnMucmVhZEZpbGVTeW5jKGlucHV0UGF0aCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbGF0aXZpemUgdGhlIHBhdGggd2hlcmUgYSBmaWxlIGlzIHdyaXR0ZW4uXG4gICAqIEBwYXJhbSBmaWxlIGEgcGF0aCBjb250YWluaW5nIGEgcmUtcm9vdGVkIHNlZ21lbnQgbGlrZSBgLmVzbTIwMTVgXG4gICAqIEBwYXJhbSBvdXREaXIgcGF0aCB3aGVyZSB3ZSBjb3B5IHRoZSBmaWxlLCByZWxhdGl2ZSB0byB0aGUgb3V0XG4gICAqL1xuICBmdW5jdGlvbiB3cml0ZUVzbUZpbGUoZmlsZTogc3RyaW5nLCBvdXREaXI6IHN0cmluZykge1xuICAgIC8vIFBhdGggY29tcHV0ZWQgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcGFja2FnZSBpbiBiYXplbC1iaW4uIGUuZy4gYSBFUzIwMTUgb3V0cHV0IGZpbGVcbiAgICAvLyBpbiBgYmF6ZWwtb3V0LzwuLj4vcGFja2FnZXMvY29yZS9zcmMvZGkuanNgIHNob3VsZCBiZSBzdG9yZWQgaW4gYHtvdXRfZGlyfS9zcmMvZGkuanNgXG4gICAgLy8gaWYgdGhlIHBhY2thZ2UgdGFyZ2V0IGhhcyBiZWVuIGRlY2xhcmVkIGluIGA8Li4+L3BhY2thZ2VzL2NvcmVgLlxuICAgIGNvbnN0IHBhY2thZ2VSZWxhdGl2ZVBhdGggPSBwYXRoLmRpcm5hbWUocGF0aC5yZWxhdGl2ZShiaW5EaXIsIGZpbGUpKTtcbiAgICBpZiAoIXBhY2thZ2VSZWxhdGl2ZVBhdGguc3RhcnRzV2l0aCgnLi4nKSkge1xuICAgICAgY29weUZpbGUoZmlsZSwgcGF0aC5qb2luKG91dCwgb3V0RGlyKSwgcGFja2FnZVJlbGF0aXZlUGF0aCk7XG4gICAgfVxuICB9XG5cbiAgZXNtMjAxNS5mb3JFYWNoKGZpbGUgPT4gd3JpdGVFc21GaWxlKGZpbGUsICdlc20yMDE1JykpO1xuXG4gIGJ1bmRsZXMuZm9yRWFjaChidW5kbGUgPT4ge1xuICAgIGNvcHlGaWxlKGJ1bmRsZSwgb3V0LCAnYnVuZGxlcycpO1xuICB9KTtcbiAgZmVzbTIwMTUuZm9yRWFjaChmaWxlID0+IHtcbiAgICBjb3B5RmlsZShmaWxlLCBvdXQsICdmZXNtMjAxNScpO1xuICB9KTtcblxuICAvLyBDb3B5IGFsbCB0eXBlIGRlZmluaXRpb25zIGludG8gdGhlIHBhY2thZ2UuIFRoaXMgaXMgbmVjZXNzYXJ5IHNvIHRoYXQgZGV2ZWxvcGVycyBjYW4gdXNlXG4gIC8vIHRoZSBwYWNrYWdlIHdpdGggdHlwZSBkZWZpbml0aW9ucy5cbiAgdHlwZURlZmluaXRpb25zLmZvckVhY2goZiA9PiB3cml0ZUZpbGVGcm9tSW5wdXRQYXRoKGYsIHJlYWRUeXBpbmdzQW5kU3RyaXBBbWRNb2R1bGUoZikpKTtcblxuICAvLyBDb3B5IGFsbCBgZGF0YWAgZmlsZXMgaW50byB0aGUgcGFja2FnZS4gVGhlc2UgYXJlIGZpbGVzIHRoYXQgYXJlbid0IGJ1aWx0IGJ5IHRoZSBuZ19wYWNrYWdlXG4gIC8vIHJ1bGUsIGJ1dCBpbnN0ZWFkIGFyZSBqdXN0IHN0cmFpZ2h0IGNvcGllZCBpbnRvIHRoZSBwYWNrYWdlLCBlLmcuIGdsb2JhbCBDU1MgYXNzZXRzLlxuICBkYXRhRmlsZXMuZm9yRWFjaChmID0+IGNvcHlGaWxlRnJvbUlucHV0UGF0aChmKSk7XG5cbiAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBlbnRyeSBwb2ludCBtb2R1bGVzXG4gIC8vIFdlIGRvIHRoaXMgZmlyc3QgYmVjYXVzZSB3ZSBhbHNvIHJlY29yZCBuZXcgcGF0aHMgZm9yIHRoZSBlc201IGFuZCBlc20yMDE1IGNvcGllc1xuICAvLyBvZiB0aGUgaW5kZXggSlMgZmlsZSwgd2hpY2ggd2UgbmVlZCB0byBhbWVuZCB0aGUgcGFja2FnZS5qc29uLlxuICBPYmplY3Qua2V5cyhtb2R1bGVzTWFuaWZlc3QpLmZvckVhY2gobW9kdWxlTmFtZSA9PiB7XG4gICAgY29uc3QgbW9kdWxlRmlsZXMgPSBtb2R1bGVzTWFuaWZlc3RbbW9kdWxlTmFtZV07XG4gICAgY29uc3QgcmVsYXRpdmUgPSBwYXRoLnJlbGF0aXZlKGJpbkRpciwgbW9kdWxlRmlsZXNbJ2luZGV4J10pO1xuXG4gICAgbW9kdWxlRmlsZXNbJ2VzbTIwMTVfaW5kZXgnXSA9IHBhdGguam9pbihiaW5EaXIsICdlc20yMDE1JywgcmVsYXRpdmUpO1xuXG4gICAgLy8gTWV0YWRhdGEgZmlsZSBpcyBvcHRpb25hbCBhcyBlbnRyeS1wb2ludHMgY2FuIGJlIGJ1aWx0IHdpdGggdGhlIGB0c19saWJyYXJ5YFxuICAgIC8vIHJ1bGUgb3IgYG5nX21vZHVsZWAgcnVsZSBpbiBJdnkgbW9kZS5cbiAgICBjb25zdCBtZXRhZGF0YUZpbGUgPSBtb2R1bGVGaWxlc1snbWV0YWRhdGEnXTtcbiAgICBpZiAoIW1ldGFkYXRhRmlsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHR5cGluZ3NPdXRGaWxlID0gbW9kdWxlRmlsZXNbJ3R5cGluZ3MnXTtcbiAgICAvLyBXZSBvbmx5IHN1cHBvcnQgYWxsIG1vZHVsZXMgd2l0aGluIGEgcGFja2FnZSB0byBiZSBkdHMgYnVuZGxlZFxuICAgIC8vIGllOiBpZiBAYW5ndWxhci9jb21tb24vaHR0cCBoYXMgZmxhdCBkdHMsIHNvIHNob3VsZCBAYW5ndWxhci9jb21tb25cbiAgICBpZiAoZHRzQnVuZGxlcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhQ29udGVudCA9IHJld2lyZU1ldGFkYXRhKG1ldGFkYXRhRmlsZSwgdHlwaW5nc091dEZpbGUpO1xuICAgICAgd3JpdGVGaWxlRnJvbUlucHV0UGF0aChtZXRhZGF0YUZpbGUsIG1ldGFkYXRhQ29udGVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvcHlGaWxlRnJvbUlucHV0UGF0aChtZXRhZGF0YUZpbGUpO1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgbGljZW5zZUJhbm5lciA9IGxpY2Vuc2VGaWxlID8gZnMucmVhZEZpbGVTeW5jKGxpY2Vuc2VGaWxlLCAndXRmLTgnKSA6ICcnO1xuXG4gIGR0c0J1bmRsZXMuZm9yRWFjaChidW5kbGVGaWxlID0+IHtcbiAgICBjb25zdCBjbGVhbkRpc3RQYXRoID0gYnVuZGxlRmlsZS5yZXBsYWNlKGR0c0J1bmRsZUZpbGVTdWZmaXgsICcuZC50cycpO1xuICAgIC8vIEFQSSBleHRyYWN0b3Igd2lsbCBub3QgZGVkdXBlIGxpY2Vuc2UgY29tbWVudHMgZnJvbSB2YXJpb3VzIGZpbGVzXG4gICAgLy8gdGhpcyB3aWxsIHJlbW92ZSBhbGwgdGhlIGxpY2Vuc2UgY29tbWVudHMgYW5kIGFwcGVuZCB0aGUgbGljZW5zZSBiYW5uZXIuXG4gICAgY29uc3QgY29udGVudCA9IGxpY2Vuc2VCYW5uZXIgKyAnXFxuJyArXG4gICAgICAgIHJlYWRUeXBpbmdzQW5kU3RyaXBBbWRNb2R1bGUoYnVuZGxlRmlsZSlcbiAgICAgICAgICAgIC5yZXBsYWNlKC8oXFwvXFwqXFwqXFxzK1xcKlxcc1xcQGxpY2Vuc2UoKCg/IVxcKlxcLykufFxccykqKVxcKlxcLykvZ20sICcnKTtcblxuICAgIHdyaXRlRmlsZUZyb21JbnB1dFBhdGgoY2xlYW5EaXN0UGF0aCwgY29udGVudCk7XG4gIH0pO1xuXG4gIC8vIFJvb3QgcGFja2FnZSBuYW1lIChlLmcuICdAYW5ndWxhci9jb21tb24nKSwgY2FwdHVyZXMgYXMgd2UgaXRlcmF0ZSB0aHJvdWdoIHNvdXJjZXMgYmVsb3cuXG4gIGxldCByb290UGFja2FnZU5hbWUgPSAnJztcbiAgY29uc3QgcGFja2FnZXNXaXRoRXhpc3RpbmdQYWNrYWdlSnNvbiA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gIGZvciAoY29uc3Qgc3JjIG9mIHNyY3MpIHtcbiAgICBpZiAoc3JjLmluY2x1ZGVzKGJpbkRpcikgfHwgc3JjLmluY2x1ZGVzKGdlbmZpbGVzRGlyKSkge1xuICAgICAgZXJyb3JIYXNPY2N1cmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgJ1RoZSBcInNyY3NcIiBmb3IgbmdfcGFja2FnZSBzaG91bGQgbm90IGluY2x1ZGUgb3V0cHV0IG9mIG90aGVyIHJ1bGVzLiBGb3VuZDpcXG4nICtcbiAgICAgICAgICBgICAke3NyY31gKTtcbiAgICB9XG5cbiAgICBsZXQgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhzcmMsICd1dGYtOCcpO1xuICAgIC8vIE1vZGlmeSBwYWNrYWdlLmpzb24gZmlsZXMgYXMgbmVjZXNzYXJ5IGZvciBwdWJsaXNoaW5nXG4gICAgaWYgKHBhdGguYmFzZW5hbWUoc3JjKSA9PT0gJ3BhY2thZ2UuanNvbicpIHtcbiAgICAgIGNvbnN0IHBhY2thZ2VKc29uID0gSlNPTi5wYXJzZShjb250ZW50KSBhcyB7W2tleTogc3RyaW5nXTogc3RyaW5nfTtcbiAgICAgIGNvbnRlbnQgPSBhbWVuZFBhY2thZ2VKc29uKHNyYywgcGFja2FnZUpzb24sIGZhbHNlKTtcblxuICAgICAgY29uc3QgcGFja2FnZU5hbWUgPSBwYWNrYWdlSnNvblsnbmFtZSddO1xuICAgICAgcGFja2FnZXNXaXRoRXhpc3RpbmdQYWNrYWdlSnNvbi5hZGQocGFja2FnZU5hbWUpO1xuXG4gICAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSByb290IHBhY2thZ2UgbmFtZSwgZS5nLiBcIkBhbmd1bGFyL2NvbW1vblwiLiBXZSBhc3N1bWUgdGhhdCB0aGVcbiAgICAgIC8vIHJvb3QgbmFtZSB3aWxsIGJlIHNob3J0ZXN0IGJlY2F1c2Ugc2Vjb25kYXJ5IGVudHJ5LXBvaW50cyB3aWxsIGFwcGVuZCB0byBpdFxuICAgICAgLy8gKGUuZy4gXCJAYW5ndWxhci9jb21tb24vaHR0cFwiKS5cbiAgICAgIGlmICghcm9vdFBhY2thZ2VOYW1lIHx8IHBhY2thZ2VOYW1lLmxlbmd0aCA8IHJvb3RQYWNrYWdlTmFtZS5sZW5ndGgpIHtcbiAgICAgICAgcm9vdFBhY2thZ2VOYW1lID0gcGFja2FnZUpzb25bJ25hbWUnXTtcbiAgICAgIH1cbiAgICB9XG4gICAgd3JpdGVGaWxlRnJvbUlucHV0UGF0aChzcmMsIGNvbnRlbnQpO1xuICB9XG5cbiAgLy8gR2VuZXJhdGUgZXh0cmEgZmlsZXMgZm9yIHNlY29uZGFyeSBlbnRyeS1wb2ludHMuXG4gIE9iamVjdC5rZXlzKG1vZHVsZXNNYW5pZmVzdCkuZm9yRWFjaChlbnRyeVBvaW50UGFja2FnZU5hbWUgPT4ge1xuICAgIGNvbnN0IGVudHJ5UG9pbnROYW1lID0gZW50cnlQb2ludFBhY2thZ2VOYW1lLnN1YnN0cihyb290UGFja2FnZU5hbWUubGVuZ3RoICsgMSk7XG4gICAgaWYgKCFlbnRyeVBvaW50TmFtZSkgcmV0dXJuO1xuXG4gICAgY29uc3QgbWV0YWRhdGFGaWxlUGF0aCA9IG1vZHVsZXNNYW5pZmVzdFtlbnRyeVBvaW50UGFja2FnZU5hbWVdWydtZXRhZGF0YSddO1xuICAgIGlmIChtZXRhZGF0YUZpbGVQYXRoKSB7XG4gICAgICBjcmVhdGVNZXRhZGF0YVJlZXhwb3J0RmlsZShcbiAgICAgICAgICBlbnRyeVBvaW50TmFtZSwgbW9kdWxlc01hbmlmZXN0W2VudHJ5UG9pbnRQYWNrYWdlTmFtZV1bJ21ldGFkYXRhJ10sXG4gICAgICAgICAgZW50cnlQb2ludFBhY2thZ2VOYW1lKTtcbiAgICB9XG5cbiAgICBjcmVhdGVUeXBpbmdzUmVleHBvcnRGaWxlKFxuICAgICAgICBlbnRyeVBvaW50TmFtZSwgbGljZW5zZUJhbm5lciwgbW9kdWxlc01hbmlmZXN0W2VudHJ5UG9pbnRQYWNrYWdlTmFtZV1bJ3R5cGluZ3MnXSk7XG5cbiAgICBpZiAoIXBhY2thZ2VzV2l0aEV4aXN0aW5nUGFja2FnZUpzb24uaGFzKGVudHJ5UG9pbnRQYWNrYWdlTmFtZSkpIHtcbiAgICAgIGNyZWF0ZUVudHJ5UG9pbnRQYWNrYWdlSnNvbihlbnRyeVBvaW50TmFtZSwgZW50cnlQb2ludFBhY2thZ2VOYW1lKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBlcnJvckhhc09jY3VyZWQgPyAxIDogMDtcblxuICAvKipcbiAgICogQ29udmVydCBhIGJpbkRpci1yZWxhdGl2ZSBwYXRoIHRvIHNyY0Rpci1yZWxhdGl2ZVxuICAgKiBAcGFyYW0gZnJvbSBwYXRoIHRvIGEgZmlsZSB1bmRlciB0aGUgc3JjRGlyLCBsaWtlIHBhY2thZ2VzL2NvcmUvdGVzdGluZy9wYWNrYWdlLmpzb25cbiAgICogQHBhcmFtIGZpbGUgcGF0aCB0byBhIGZpbGUgdW5kZXIgdGhlIGJpbkRpciwgbGlrZSBiYXplbC1iaW4vY29yZS90ZXN0aW5nL2dlbmVyYXRlZC5qc1xuICAgKi9cbiAgZnVuY3Rpb24gc3JjRGlyUmVsYXRpdmUoZnJvbTogc3RyaW5nLCBmaWxlOiBzdHJpbmcpIHtcbiAgICBjb25zdCByZXN1bHQgPSBub3JtYWxpemVTZXBhcmF0b3JzKFxuICAgICAgICBwYXRoLnJlbGF0aXZlKHBhdGguZGlybmFtZShmcm9tKSwgcGF0aC5qb2luKHNyY0RpciwgcGF0aC5yZWxhdGl2ZShiaW5EaXIsIGZpbGUpKSkpO1xuICAgIGlmIChyZXN1bHQuc3RhcnRzV2l0aCgnLi4nKSkgcmV0dXJuIHJlc3VsdDtcbiAgICByZXR1cm4gYC4vJHtyZXN1bHR9YDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvcHlGaWxlKGZpbGU6IHN0cmluZywgYmFzZURpcjogc3RyaW5nLCByZWxhdGl2ZSA9ICcuJykge1xuICAgIGNvbnN0IGRpciA9IHBhdGguam9pbihiYXNlRGlyLCByZWxhdGl2ZSk7XG4gICAgLy8gb3V0cHV0IGZpbGUgaXMgLmpzIGlmIHRoZSBpbnB1dCBmaWxlIGlzIC5tanNcbiAgICBjb25zdCBvdXRGaWxlID0gcGF0aC5wb3NpeC5qb2luKFxuICAgICAgICBkaXIsIHBhdGguYmFzZW5hbWUoZmlsZS5lbmRzV2l0aCgnLm1qcycpID8gZmlsZS5yZXBsYWNlKC9cXC5tanMkLywgJy5qcycpIDogZmlsZSkpO1xuICAgIHNoeC5ta2RpcignLXAnLCBkaXIpO1xuICAgIHNoeC5jcChmaWxlLCBvdXRGaWxlKTtcbiAgICAvLyBEb3VibGUtdW5kZXJzY29yZSBpcyB1c2VkIHRvIGVzY2FwZSBmb3J3YXJkIHNsYXNoIGluIEZFU00gZmlsZW5hbWVzLlxuICAgIC8vIFNlZSBuZ19wYWNrYWdlLmJ6bDpcbiAgICAvLyAgIGZlc21fb3V0cHV0X2ZpbGVuYW1lID0gZW50cnlfcG9pbnQucmVwbGFjZShcIi9cIiwgXCJfX1wiKVxuICAgIC8vIFdlIG5lZWQgdG8gdW5lc2NhcGUgdGhlc2UuXG4gICAgaWYgKG91dEZpbGUuaW5kZXhPZignX18nKSA+PSAwKSB7XG4gICAgICBjb25zdCBvdXRwdXRQYXRoID0gcGF0aC5qb2luKGRpciwgLi4ucGF0aC5iYXNlbmFtZShvdXRGaWxlKS5zcGxpdCgnX18nKSk7XG4gICAgICBzaHgubWtkaXIoJy1wJywgcGF0aC5kaXJuYW1lKG91dHB1dFBhdGgpKTtcbiAgICAgIHNoeC5tdihwYXRoLmpvaW4oZGlyLCBwYXRoLmJhc2VuYW1lKGZpbGUpKSwgb3V0cHV0UGF0aCk7XG5cbiAgICAgIC8vIGlmIHdlIGFyZSByZW5hbWluZyB0aGUgLmpzIGZpbGUsIHdlJ2xsIGFsc28gbmVlZCB0byB1cGRhdGUgdGhlIHNvdXJjZU1hcHBpbmdVUkwgaW4gdGhlIGZpbGVcbiAgICAgIGlmIChvdXRGaWxlLmVuZHNXaXRoKCcuanMnKSkge1xuICAgICAgICBzaHguY2htb2QoJyt3Jywgb3V0cHV0UGF0aCk7XG4gICAgICAgIHNoeC5zZWQoJy1pJywgYCR7cGF0aC5iYXNlbmFtZShmaWxlKX0ubWFwYCwgYCR7cGF0aC5iYXNlbmFtZShvdXRwdXRQYXRoKX0ubWFwYCwgb3V0cHV0UGF0aCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgb3IgZWRpdHMgcHJvcGVydGllcyBpbnRvIHRoZSBwYWNrYWdlLmpzb24gZmlsZShzKSBpbiB0aGUgcGFja2FnZSBzbyB0aGF0XG4gICAqIHRoZXkgcG9pbnQgdG8gYWxsIHRoZSByaWdodCBnZW5lcmF0ZWQgYXJ0aWZhY3RzLlxuICAgKlxuICAgKiBAcGFyYW0gcGFja2FnZUpzb24gVGhlIHBhdGggdG8gdGhlIHBhY2thZ2UuanNvbiBmaWxlLlxuICAgKiBAcGFyYW0gcGFyc2VkUGFja2FnZSBQYXJzZWQgcGFja2FnZS5qc29uIGNvbnRlbnRcbiAgICogQHBhcmFtIGlzR2VuZXJhdGVkUGFja2FnZUpzb24gV2hldGhlciB0aGUgcGFzc2VkIHBhY2thZ2UuanNvbiBoYXMgYmVlbiBnZW5lcmF0ZWQuXG4gICAqL1xuICBmdW5jdGlvbiBhbWVuZFBhY2thZ2VKc29uKFxuICAgICAgcGFja2FnZUpzb246IHN0cmluZywgcGFyc2VkUGFja2FnZToge1trZXk6IHN0cmluZ106IHN0cmluZ30sXG4gICAgICBpc0dlbmVyYXRlZFBhY2thZ2VKc29uOiBib29sZWFuKSB7XG4gICAgY29uc3QgcGFja2FnZU5hbWUgPSBwYXJzZWRQYWNrYWdlWyduYW1lJ107XG4gICAgY29uc3QgbW9kdWxlRGF0YSA9IG1vZHVsZXNNYW5pZmVzdFtwYWNrYWdlTmFtZV07XG5cbiAgICAvLyBJZiBhIHBhY2thZ2UganNvbiBmaWxlIGhhcyBiZWVuIGRpc2NvdmVyZWQgdGhhdCBkb2VzIG5vdCBtYXRjaCBhbnlcbiAgICAvLyBtb2R1bGUgaW4gdGhlIG1hbmlmZXN0LCB3ZSByZXBvcnQgYSB3YXJuaW5nIGFzIG1vc3QgbGlrZWx5IHRoZSB0YXJnZXRcbiAgICAvLyBpcyBjb25maWd1cmVkIGluY29ycmVjdGx5IChlLmcuIG1pc3NpbmcgYG1vZHVsZV9uYW1lYCBhdHRyaWJ1dGUpLlxuICAgIGlmICghbW9kdWxlRGF0YSkge1xuICAgICAgLy8gSWRlYWxseSB3ZSBzaG91bGQgdGhyb3cgaGVyZSwgYXMgd2UgZ290IGFuIGVudHJ5IHBvaW50IHRoYXQgZG9lc24ndFxuICAgICAgLy8gaGF2ZSBmbGF0IG1vZHVsZSBtZXRhZGF0YSAvIGJ1bmRsZSBpbmRleCwgc28gaXQgbWF5IGhhdmUgYmVlbiBhblxuICAgICAgLy8gbmdfbW9kdWxlIHRoYXQncyBtaXNzaW5nIGEgbW9kdWxlX25hbWUgYXR0cmlidXRlLlxuICAgICAgLy8gSG93ZXZlciwgQGFuZ3VsYXIvY29tcGlsZXIgY2FuJ3QgYmUgYW4gbmdfbW9kdWxlLCBhcyBpdCdzIHRoZSBpbnRlcm5hbHNcbiAgICAgIC8vIG9mIHRoZSBuZ2MgY29tcGlsZXIsIHlldCB3ZSB3YW50IHRvIGJ1aWxkIGFuIG5nX3BhY2thZ2UgZm9yIGl0LlxuICAgICAgLy8gU28gaWdub3JlIHBhY2thZ2UuanNvbiBmaWxlcyB3aGVuIHdlIGFyZSBtaXNzaW5nIGRhdGEuXG4gICAgICBjb25zb2xlLmVycm9yKCdXQVJOSU5HOiBubyBtb2R1bGUgbWV0YWRhdGEgZm9yIHBhY2thZ2UnLCBwYWNrYWdlTmFtZSk7XG4gICAgICBjb25zb2xlLmVycm9yKCcgICBOb3QgdXBkYXRpbmcgdGhlIHBhY2thZ2UuanNvbiBmaWxlIHRvIHBvaW50IHRvIGl0Jyk7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICcgICBUaGUgbmdfbW9kdWxlIGZvciB0aGlzIHBhY2thZ2UgaXMgcG9zc2libHkgbWlzc2luZyB0aGUgbW9kdWxlX25hbWUgYXR0cmlidXRlICcpO1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBhcnNlZFBhY2thZ2UsIG51bGwsIDIpO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGd1ZXNzZWQgdGhlIGluZGV4IHBhdGhzIGZvciBhIG1vZHVsZSwgYW5kIGl0IGNvbnRhaW5zIGFuIGV4cGxpY2l0IGBwYWNrYWdlLmpzb25gXG4gICAgLy8gZmlsZSB0aGF0IGFscmVhZHkgc2V0cyBmb3JtYXQgcHJvcGVydGllcywgd2Ugc2tpcCBhdXRvbWF0aWMgaW5zZXJ0aW9uIG9mIGZvcm1hdFxuICAgIC8vIHByb3BlcnRpZXMgYnV0IHJlcG9ydCBhIHdhcm5pbmcgaW4gY2FzZSBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBzZXQgYnkgYWNjaWRlbnQuXG4gICAgaWYgKG1vZHVsZURhdGEuZ3Vlc3NlZFBhdGhzICYmICFpc0dlbmVyYXRlZFBhY2thZ2VKc29uICYmXG4gICAgICAgIGhhc0V4cGxpY2l0Rm9ybWF0UHJvcGVydGllcyhwYXJzZWRQYWNrYWdlKSkge1xuICAgICAgY29uc29sZS5lcnJvcignV0FSTklORzogYHBhY2thZ2UuanNvbmAgZXhwbGljaXRseSBzZXRzIGZvcm1hdCBwcm9wZXJ0aWVzIChsaWtlIGBtYWluYCkuJyk7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICcgICAgU2tpcHBpbmcgYXV0b21hdGljIGluc2VydGlvbiBvZiBmb3JtYXQgcHJvcGVydGllcyBhcyBleHBsaWNpdCAnICtcbiAgICAgICAgICAnZm9ybWF0IHByb3BlcnRpZXMgYXJlIHNldC4nKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyAgICBJZ25vcmUgdGhpcyB3YXJuaW5nIGlmIGV4cGxpY2l0IHByb3BlcnRpZXMgYXJlIHNldCBpbnRlbnRpb25hbGx5LicpO1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBhcnNlZFBhY2thZ2UsIG51bGwsIDIpO1xuICAgIH1cblxuICAgIC8vIERlcml2ZSB0aGUgcGF0aHMgdG8gdGhlIGZpbGVzIGZyb20gdGhlIGhhcmQtY29kZWQgbmFtZXMgd2UgZ2F2ZSB0aGVtLlxuICAgIC8vIFRPRE8oYWxleGVhZ2xlKTogaXQgd291bGQgYmUgYmV0dGVyIHRvIHRyYW5zZmVyIHRoaXMgaW5mb3JtYXRpb24gZnJvbSB0aGUgcGxhY2VcbiAgICAvLyB3aGVyZSB3ZSBjcmVhdGVkIHRoZSBmaWxlbmFtZXMsIHZpYSB0aGUgbW9kdWxlc01hbmlmZXN0QXJnXG4gICAgcGFyc2VkUGFja2FnZVsnbWFpbiddID0gZ2V0QnVuZGxlTmFtZShwYWNrYWdlTmFtZSwgJ2J1bmRsZXMnKTtcbiAgICBwYXJzZWRQYWNrYWdlWydmZXNtMjAxNSddID0gZ2V0QnVuZGxlTmFtZShwYWNrYWdlTmFtZSwgJ2Zlc20yMDE1Jyk7XG5cbiAgICBwYXJzZWRQYWNrYWdlWydlc20yMDE1J10gPSBzcmNEaXJSZWxhdGl2ZShwYWNrYWdlSnNvbiwgbW9kdWxlRGF0YVsnZXNtMjAxNV9pbmRleCddKTtcbiAgICBwYXJzZWRQYWNrYWdlWyd0eXBpbmdzJ10gPSBzcmNEaXJSZWxhdGl2ZShwYWNrYWdlSnNvbiwgbW9kdWxlRGF0YVsndHlwaW5ncyddKTtcblxuICAgIC8vIEZvciBub3csIHdlIHBvaW50IHRoZSBwcmltYXJ5IGVudHJ5IHBvaW50cyBhdCB0aGUgZmVzbSBmaWxlcywgYmVjYXVzZSBvZiBXZWJwYWNrXG4gICAgLy8gcGVyZm9ybWFuY2UgaXNzdWVzIHdpdGggYSBsYXJnZSBudW1iZXIgb2YgaW5kaXZpZHVhbCBmaWxlcy5cbiAgICBwYXJzZWRQYWNrYWdlWydtb2R1bGUnXSA9IHBhcnNlZFBhY2thZ2VbJ2Zlc20yMDE1J107XG4gICAgcGFyc2VkUGFja2FnZVsnZXMyMDE1J10gPSBwYXJzZWRQYWNrYWdlWydmZXNtMjAxNSddO1xuXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBhcnNlZFBhY2thZ2UsIG51bGwsIDIpO1xuICB9XG5cbiAgLy8gZS5nLiBAYW5ndWxhci9jb21tb24vaHR0cC90ZXN0aW5nIC0+IC4uLy4uL2J1bmRsZXMvY29tbW9uLWh0dHAtdGVzdGluZy51bWQuanNcbiAgLy8gb3IgICBAYW5ndWxhci9jb21tb24vaHR0cC90ZXN0aW5nIC0+IC4uLy4uL2Zlc20yMDE1L2h0dHAvdGVzdGluZy5qc1xuICBmdW5jdGlvbiBnZXRCdW5kbGVOYW1lKHBhY2thZ2VOYW1lOiBzdHJpbmcsIGRpcjogc3RyaW5nKSB7XG4gICAgY29uc3QgcGFydHMgPSBwYWNrYWdlTmFtZS5zcGxpdCgnLycpO1xuICAgIC8vIFJlbW92ZSB0aGUgc2NvcGVkIHBhY2thZ2UgcGFydCwgbGlrZSBAYW5ndWxhciBpZiBwcmVzZW50XG4gICAgY29uc3QgbmFtZVBhcnRzID0gcGFja2FnZU5hbWUuc3RhcnRzV2l0aCgnQCcpID8gcGFydHMuc3BsaWNlKDEpIDogcGFydHM7XG4gICAgY29uc3QgcmVsYXRpdmVQYXRoID0gbmV3QXJyYXkobmFtZVBhcnRzLmxlbmd0aCAtIDEsICcuLicpLmpvaW4oJy8nKSB8fCAnLic7XG4gICAgbGV0IGJhc2VuYW1lOiBzdHJpbmc7XG4gICAgaWYgKGRpciA9PT0gJ2J1bmRsZXMnKSB7XG4gICAgICBiYXNlbmFtZSA9IG5hbWVQYXJ0cy5qb2luKCctJykgKyAnLnVtZCc7XG4gICAgfSBlbHNlIGlmIChuYW1lUGFydHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBiYXNlbmFtZSA9IG5hbWVQYXJ0c1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZW5hbWUgPSBuYW1lUGFydHMuc2xpY2UoMSkuam9pbignLycpO1xuICAgIH1cbiAgICByZXR1cm4gW3JlbGF0aXZlUGF0aCwgZGlyLCBiYXNlbmFtZSArICcuanMnXS5qb2luKCcvJyk7XG4gIH1cblxuICAvKiogV2hldGhlciB0aGUgcGFja2FnZSBleHBsaWNpdGx5IHNldHMgYW55IG9mIHRoZSBmb3JtYXQgcHJvcGVydGllcyAobGlrZSBgbWFpbmApLiAqL1xuICBmdW5jdGlvbiBoYXNFeHBsaWNpdEZvcm1hdFByb3BlcnRpZXMocGFyc2VkUGFja2FnZToge1trZXk6IHN0cmluZ106IHN0cmluZ30pOiBib29sZWFuIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocGFyc2VkUGFja2FnZSlcbiAgICAgICAgLnNvbWUocHJvcGVydHlOYW1lID0+IGtub3duRm9ybWF0UGFja2FnZUpzb25GaWVsZHMuaW5jbHVkZXMocHJvcGVydHlOYW1lKSk7XG4gIH1cblxuICAvKiogQ3JlYXRlcyBtZXRhZGF0YSByZS1leHBvcnQgZmlsZSBmb3IgYSBzZWNvbmRhcnkgZW50cnktcG9pbnQuICovXG4gIGZ1bmN0aW9uIGNyZWF0ZU1ldGFkYXRhUmVleHBvcnRGaWxlKFxuICAgICAgZW50cnlQb2ludE5hbWU6IHN0cmluZywgbWV0YWRhdGFGaWxlOiBzdHJpbmcsIHBhY2thZ2VOYW1lOiBzdHJpbmcpIHtcbiAgICBjb25zdCBpbnB1dFBhdGggPSBwYXRoLmpvaW4oc3JjRGlyLCBgJHtlbnRyeVBvaW50TmFtZX0ubWV0YWRhdGEuanNvbmApO1xuICAgIHdyaXRlRmlsZUZyb21JbnB1dFBhdGgoaW5wdXRQYXRoLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAnX19zeW1ib2xpYyc6ICdtb2R1bGUnLFxuICAgICAgJ3ZlcnNpb24nOiAzLFxuICAgICAgJ21ldGFkYXRhJzoge30sXG4gICAgICAnZXhwb3J0cyc6XG4gICAgICAgICAgW3snZnJvbSc6IGAke3NyY0RpclJlbGF0aXZlKGlucHV0UGF0aCwgbWV0YWRhdGFGaWxlLnJlcGxhY2UoLy5tZXRhZGF0YS5qc29uJC8sICcnKSl9YH1dLFxuICAgICAgJ2ZsYXRNb2R1bGVJbmRleFJlZGlyZWN0JzogdHJ1ZSxcbiAgICAgICdpbXBvcnRBcyc6IHBhY2thZ2VOYW1lXG4gICAgfSkgKyAnXFxuJyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHR5cGluZ3MgKGQudHMpIHJlLWV4cG9ydCBmaWxlIGZvciBhIHNlY29uZGFyeS1lbnRyeSBwb2ludCxcbiAgICogZS5nLiwgYGV4cG9ydCAqIGZyb20gJy4vY29tbW9uL2NvbW1vbidgXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVUeXBpbmdzUmVleHBvcnRGaWxlKGVudHJ5UG9pbnROYW1lOiBzdHJpbmcsIGxpY2Vuc2U6IHN0cmluZywgdHlwaW5nc0ZpbGU6IHN0cmluZykge1xuICAgIGNvbnN0IGlucHV0UGF0aCA9IHBhdGguam9pbihzcmNEaXIsIGAke2VudHJ5UG9pbnROYW1lfS5kLnRzYCk7XG4gICAgY29uc3QgY29udGVudCA9IGAke2xpY2Vuc2V9XG5leHBvcnQgKiBmcm9tICcke3NyY0RpclJlbGF0aXZlKGlucHV0UGF0aCwgdHlwaW5nc0ZpbGUucmVwbGFjZSgvXFwuZFxcLnRzeD8kLywgJycpKX0nO1xuYDtcbiAgICB3cml0ZUZpbGVGcm9tSW5wdXRQYXRoKGlucHV0UGF0aCwgY29udGVudCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHBhY2thZ2UuanNvbiBmb3IgYSBzZWNvbmRhcnkgZW50cnktcG9pbnQuXG4gICAqIEBwYXJhbSBkaXIgVGhlIGRpcmVjdG9yeSB1bmRlciB3aGljaCB0aGUgcGFja2FnZS5qc29uIHNob3VsZCBiZSB3cml0dGVuLlxuICAgKiBAcGFyYW0gZW50cnlQb2ludFBhY2thZ2VOYW1lIFRoZSBmdWxsIHBhY2thZ2UgbmFtZSBmb3IgdGhlIGVudHJ5IHBvaW50LFxuICAgKiAgICAgZS5nLiAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnLlxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlRW50cnlQb2ludFBhY2thZ2VKc29uKGRpcjogc3RyaW5nLCBlbnRyeVBvaW50UGFja2FnZU5hbWU6IHN0cmluZykge1xuICAgIGNvbnN0IHBrZ0pzb24gPSBwYXRoLmpvaW4oc3JjRGlyLCBkaXIsICdwYWNrYWdlLmpzb24nKTtcbiAgICBjb25zdCBjb250ZW50ID0gYW1lbmRQYWNrYWdlSnNvbihwa2dKc29uLCB7bmFtZTogZW50cnlQb2ludFBhY2thZ2VOYW1lfSwgdHJ1ZSk7XG4gICAgd3JpdGVGaWxlRnJvbUlucHV0UGF0aChwa2dKc29uLCBjb250ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemVzIHRoZSBzcGVjaWZpZWQgcGF0aCBieSByZXBsYWNpbmcgYmFja3NsYXNoIHNlcGFyYXRvcnMgd2l0aCBQb3NpeFxuICAgKiBmb3J3YXJkIHNsYXNoIHNlcGFyYXRvcnMuXG4gICAqL1xuICBmdW5jdGlvbiBub3JtYWxpemVTZXBhcmF0b3JzKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJld2lyZXMgbWV0YWRhdGEgdG8gcG9pbnQgdG8gdGhlIGZsYXR0ZW5lZCBkdHMgZmlsZS5cbiAgICpcbiAgICogQHBhcmFtIG1ldGFkYXRhUGF0aCB0aGUgbWV0YWRhdGEgZmlsZSBwYXRoXG4gICAqIEBwYXJhbSB0eXBpbmdzUGF0aCB0aGUgdHlwaW5ncyBidW5kbGUgZW50cnlwb2ludFxuICAgKi9cbiAgZnVuY3Rpb24gcmV3aXJlTWV0YWRhdGEobWV0YWRhdGFQYXRoOiBzdHJpbmcsIHR5cGluZ3NQYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IG1ldGFkYXRhID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMobWV0YWRhdGFQYXRoLCAndXRmLTgnKSkgYXMge1trZXk6IHN0cmluZ106IGFueX07XG5cbiAgICBsZXQgdHlwaW5nc1JlbGF0aXZlUGF0aCA9XG4gICAgICAgIG5vcm1hbGl6ZVNlcGFyYXRvcnMocGF0aC5yZWxhdGl2ZShwYXRoLmRpcm5hbWUobWV0YWRhdGFQYXRoKSwgdHlwaW5nc1BhdGgpKTtcbiAgICBpZiAoIXR5cGluZ3NSZWxhdGl2ZVBhdGguc3RhcnRzV2l0aCgnLi4nKSkge1xuICAgICAgdHlwaW5nc1JlbGF0aXZlUGF0aCA9IGAuLyR7dHlwaW5nc1JlbGF0aXZlUGF0aH1gO1xuICAgIH1cblxuICAgIHR5cGluZ3NSZWxhdGl2ZVBhdGggPSB0eXBpbmdzUmVsYXRpdmVQYXRoLnJlcGxhY2UoJy5kLnRzJywgJycpO1xuXG4gICAgLy8gdGhlIHJlZ2V4cCBoZXJlIGNhdGNoZXMgYWxsIHJlbGF0aXZlIHBhdGhzIHN1Y2ggYXM6XG4gICAgLy8gLi9zcmMvY29yZS9mb28uZC50cyBhbmQgLi4vc3JjL2NvcmUvZm9vLmQudHNcbiAgICBjb25zdCByZWxhdGl2ZVBhdGhSZWdleCA9IC9cXC4/XFwuXFwvW1xcd1xcLlxcLV9cXC9dKy9nO1xuICAgIGlmIChtZXRhZGF0YS5leHBvcnRzKSB7XG4gICAgICAvLyBTdHJpcCByZS1leHBvcnRzIHdoaWNoIGFyZSBub3cgc2VsZi1yZWZlcmVuY2VzXG4gICAgICBtZXRhZGF0YS5leHBvcnRzID1cbiAgICAgICAgICBtZXRhZGF0YS5leHBvcnRzLmZpbHRlcigoZToge2Zyb206IHN0cmluZ30pID0+ICFlLmZyb20ubWF0Y2gocmVsYXRpdmVQYXRoUmVnZXgpKTtcbiAgICB9XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKS5yZXBsYWNlKHJlbGF0aXZlUGF0aFJlZ2V4LCB0eXBpbmdzUmVsYXRpdmVQYXRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdHJpcCB0aGUgbmFtZWQgQU1EIG1vZHVsZSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1iYXplbCB1c2VycyBmcm9tIHR5cGluZ3MgY29udGVudFxuICAgKiBAcGFyYW0gZmlsZVBhdGggZHRzIGZpbGUgcGF0aFxuICAgKi9cbiAgZnVuY3Rpb24gcmVhZFR5cGluZ3NBbmRTdHJpcEFtZE1vZHVsZShmaWxlUGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gZnNcbiAgICAgICAgLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgJ3V0Zi04JylcbiAgICAgICAgLy8gU3RyaXAgdGhlIG5hbWVkIEFNRCBtb2R1bGUgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24tYmF6ZWwgdXNlcnNcbiAgICAgICAgLnJlcGxhY2UoL15cXC9cXC9cXC8gPGFtZC1tb2R1bGUgbmFtZT0uKlxcLz5bXFxyXFxuXSsvZ20sICcnKTtcbiAgfVxufVxuXG5pZiAocmVxdWlyZS5tYWluID09PSBtb2R1bGUpIHtcbiAgcHJvY2Vzcy5leGl0Q29kZSA9IG1haW4ocHJvY2Vzcy5hcmd2LnNsaWNlKDIpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5ld0FycmF5PFQgPSBhbnk+KHNpemU6IG51bWJlcik6IFRbXTtcbmV4cG9ydCBmdW5jdGlvbiBuZXdBcnJheTxUPihzaXplOiBudW1iZXIsIHZhbHVlOiBUKTogVFtdO1xuZXhwb3J0IGZ1bmN0aW9uIG5ld0FycmF5PFQ+KHNpemU6IG51bWJlciwgdmFsdWU/OiBUKTogVFtdIHtcbiAgY29uc3QgbGlzdDogVFtdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgbGlzdC5wdXNoKHZhbHVlISk7XG4gIH1cbiAgcmV0dXJuIGxpc3Q7XG59XG4iXX0=