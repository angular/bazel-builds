/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("npm_angular_bazel/src/ng_package/packager", ["require", "exports", "fs", "path", "shelljs"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const fs = require("fs");
    const path = require("path");
    const shx = require("shelljs");
    function main(args) {
        // Exit immediately when encountering an error.
        shx.set('-e');
        // Keep track of whether an error has occured so that we can return an appropriate exit code.
        let errorHasOccured = false;
        // This utility expects all of its arguments to be specified in a params file generated by
        // bazel (see https://docs.bazel.build/versions/master/skylark/lib/Args.html#use_param_file).
        const paramFilePath = args[0];
        // Bazel params may be surrounded with quotes
        function unquoteParameter(s) { return s.replace(/^'(.*)'$/, '$1'); }
        // Parameters are specified in the file one per line.
        const params = fs.readFileSync(paramFilePath, 'utf-8').split('\n').map(unquoteParameter);
        const [
        // Output directory for the npm package.
        out, 
        // The package segment of the ng_package rule's label (e.g. 'package/common').
        srcDir, 
        // The bazel-bin dir joined with the srcDir (e.g. 'bazel-bin/package.common').
        // This is the intended output location for package artifacts.
        binDir, 
        // The bazel-genfiles dir joined with the srcDir (e.g. 'bazel-bin/package.common').
        genfilesDir, 
        // JSON data mapping each entry point to the generated bundle index and
        // flat module metadata, for example
        // {"@angular/core": {
        //     "index": "bazel-bin/packages/core/core.js",
        //     "typings": "bazel-bin/packages/core/core.d.ts",
        //     "metadata": "bazel-bin/packages/core/core.metadata.json"
        //  },
        // ...
        // }
        modulesManifestArg, 
        // Path to the package's README.md.
        readmeMd, 
        // List of rolled-up flat ES2015 modules
        fesm2015Arg, 
        // List of rolled-up flat ES5 modules
        fesm5Arg, 
        // List of individual ES2015 modules
        esm2015Arg, 
        // List of individual ES5 modules
        esm5Arg, 
        // List of all UMD bundles generated by rollup.
        bundlesArg, 
        // List of all files in the ng_package rule's srcs.
        srcsArg, 
        // List of all type definitions that need to packaged into the ng_package.
        typeDefinitionsArg, 
        // List of all files in the ng_package rule's data.
        dataArg, 
        // Path to the package's LICENSE.
        licenseFile, 
        // List of all dts bundles generated by the API extractor.
        dtsBundleArg, 
        // The dts bundle file suffix example: '.bundle.d.ts'
        dtsBundleFileSuffix,] = params;
        const fesm2015 = fesm2015Arg.split(',').filter(s => !!s);
        const fesm5 = fesm5Arg.split(',').filter(s => !!s);
        const esm2015 = esm2015Arg.split(',').filter(s => !!s);
        const esm5 = esm5Arg.split(',').filter(s => !!s);
        const bundles = bundlesArg.split(',').filter(s => !!s);
        const typeDefinitions = typeDefinitionsArg.split(',').filter(s => !!s);
        const srcs = srcsArg.split(',').filter(s => !!s);
        const dataFiles = dataArg.split(',').filter(s => !!s);
        const modulesManifest = JSON.parse(modulesManifestArg);
        const dtsBundles = dtsBundleArg.split(',').filter(s => !!s);
        if (readmeMd) {
            copyFile(readmeMd, out);
        }
        /**
         * Writes a file into the package based on its input path, relativizing to the package path.
         * @param inputPath Path to the file in the input tree.
         * @param fileContent Content of the file.
         */
        function writeFileFromInputPath(inputPath, fileContent) {
            // We want the relative path from the given file to its ancestor "root" directory.
            // This root depends on whether the file lives in the source tree (srcDir) as a basic file
            // input to ng_package, the bin output tree (binDir) as the output of another rule, or
            // the genfiles output tree (genfilesDir) as the output of a genrule.
            let rootDir;
            if (inputPath.includes(binDir)) {
                rootDir = binDir;
            }
            else if (inputPath.includes(genfilesDir)) {
                rootDir = genfilesDir;
            }
            else {
                rootDir = srcDir;
            }
            const outputPath = path.join(out, path.relative(rootDir, inputPath));
            // Always ensure that the target directory exists.
            shx.mkdir('-p', path.dirname(outputPath));
            fs.writeFileSync(outputPath, fileContent);
        }
        /**
         * Copies a file into the package based on its input path, relativizing to the package path.
         * @param inputPath a path relative to the binDir, typically from a file in the deps[]
         */
        function copyFileFromInputPath(inputPath) {
            writeFileFromInputPath(inputPath, fs.readFileSync(inputPath));
        }
        /**
         * Relativize the path where a file is written.
         * @param file a path containing a re-rooted segment like .esm5
         * @param suffix the re-rooted directory
         * @param outDir path where we copy the file, relative to the out
         */
        function writeEsmFile(file, suffix, outDir) {
            function relPath(file, suffix) {
                if (suffix) {
                    // Note that the specified file path is always using the posix path delimiter.
                    const root = suffix ? file.substr(0, file.lastIndexOf(`${suffix}/`) + suffix.length + 1) : binDir;
                    return path.dirname(path.relative(path.join(root, srcDir), file));
                }
                else {
                    return path.dirname(path.relative(binDir, file));
                }
            }
            const rel = relPath(file, suffix);
            if (!rel.startsWith('..')) {
                copyFile(file, path.join(out, outDir), rel);
            }
        }
        esm2015.forEach(file => writeEsmFile(file, '', 'esm2015'));
        esm5.forEach(file => writeEsmFile(file, '.esm5', 'esm5'));
        bundles.forEach(bundle => { copyFile(bundle, out, 'bundles'); });
        fesm2015.forEach(file => { copyFile(file, out, 'fesm2015'); });
        fesm5.forEach(file => { copyFile(file, out, 'fesm5'); });
        // Copy all type definitions into the package. This is necessary so that developers can use
        // the package with type definitions.
        typeDefinitions.forEach(f => writeFileFromInputPath(f, readTypingsAndStripAmdModule(f)));
        // Copy all `data` files into the package. These are files that aren't built by the ng_package
        // rule, but instead are just straight copied into the package, e.g. global CSS assets.
        dataFiles.forEach(f => copyFileFromInputPath(f));
        // Iterate through the entry point modules
        // We do this first because we also record new paths for the esm5 and esm2015 copies
        // of the index JS file, which we need to amend the package.json.
        Object.keys(modulesManifest).forEach(moduleName => {
            const moduleFiles = modulesManifest[moduleName];
            const relative = path.relative(binDir, moduleFiles['index']);
            moduleFiles['esm5_index'] = path.join(binDir, 'esm5', relative);
            moduleFiles['esm2015_index'] = path.join(binDir, 'esm2015', relative);
            // Metadata file is optional as entry-points can be also built
            // with the "ts_library" rule.
            const metadataFile = moduleFiles['metadata'];
            if (!metadataFile) {
                return;
            }
            const typingsOutFile = moduleFiles['typings'];
            // We only support all modules within a package to be dts bundled
            // ie: if @angular/common/http has flat dts, so should @angular/common
            if (dtsBundles.length) {
                const metadataContent = rewireMetadata(metadataFile, typingsOutFile);
                writeFileFromInputPath(metadataFile, metadataContent);
            }
            else {
                copyFileFromInputPath(metadataFile);
            }
        });
        const licenseBanner = licenseFile ? fs.readFileSync(licenseFile, 'utf-8') : '';
        dtsBundles.forEach(bundleFile => {
            const cleanDistPath = bundleFile.replace(dtsBundleFileSuffix, '.d.ts');
            // API extractor will not dedupe license comments from various files
            // this will remove all the license comments and append the license banner.
            const content = licenseBanner + '\n' +
                readTypingsAndStripAmdModule(bundleFile)
                    .replace(/(\/\*\*\s+\*\s\@license(((?!\*\/).|\s)*)\*\/)/gm, '');
            writeFileFromInputPath(cleanDistPath, content);
        });
        // Root package name (e.g. '@angular/common'), captures as we iterate through sources below.
        let rootPackageName = '';
        const packagesWithExistingPackageJson = new Set();
        for (const src of srcs) {
            if (src.includes(binDir) || src.includes(genfilesDir)) {
                errorHasOccured = true;
                console.error('The "srcs" for ng_package should not include output of other rules. Found:\n' +
                    `  ${src}`);
            }
            let content = fs.readFileSync(src, 'utf-8');
            // Modify package.json files as necessary for publishing
            if (path.basename(src) === 'package.json') {
                const packageJson = JSON.parse(content);
                content = amendPackageJson(src, packageJson, false);
                const packageName = packageJson['name'];
                packagesWithExistingPackageJson.add(packageName);
                // Keep track of the root package name, e.g. "@angular/common". We assume that the
                // root name will be shortest because secondary entry-points will append to it
                // (e.g. "@angular/common/http").
                if (!rootPackageName || packageName.length < rootPackageName.length) {
                    rootPackageName = packageJson['name'];
                }
            }
            writeFileFromInputPath(src, content);
        }
        // Generate extra files for secondary entry-points.
        Object.keys(modulesManifest).forEach(entryPointPackageName => {
            const entryPointName = entryPointPackageName.substr(rootPackageName.length + 1);
            if (!entryPointName)
                return;
            const metadataFilePath = modulesManifest[entryPointPackageName]['metadata'];
            if (metadataFilePath) {
                createMetadataReexportFile(entryPointName, modulesManifest[entryPointPackageName]['metadata'], entryPointPackageName);
            }
            createTypingsReexportFile(entryPointName, licenseBanner, modulesManifest[entryPointPackageName]['typings']);
            if (!packagesWithExistingPackageJson.has(entryPointPackageName)) {
                createEntryPointPackageJson(entryPointName, entryPointPackageName);
            }
        });
        return errorHasOccured ? 1 : 0;
        /**
         * Convert a binDir-relative path to srcDir-relative
         * @param from path to a file under the srcDir, like packages/core/testing/package.json
         * @param file path to a file under the binDir, like bazel-bin/core/testing/generated.js
         */
        function srcDirRelative(from, file) {
            const result = normalizeSeparators(path.relative(path.dirname(from), path.join(srcDir, path.relative(binDir, file))));
            if (result.startsWith('..'))
                return result;
            return `./${result}`;
        }
        function copyFile(file, baseDir, relative = '.') {
            const dir = path.join(baseDir, relative);
            // output file is .js if the input file is .mjs
            const outFile = path.posix.join(dir, path.basename(file.endsWith('.mjs') ? file.replace(/\.mjs$/, '.js') : file));
            shx.mkdir('-p', dir);
            shx.cp(file, outFile);
            // Double-underscore is used to escape forward slash in FESM filenames.
            // See ng_package.bzl:
            //   fesm_output_filename = entry_point.replace("/", "__")
            // We need to unescape these.
            if (outFile.indexOf('__') >= 0) {
                const outputPath = path.join(dir, ...path.basename(outFile).split('__'));
                shx.mkdir('-p', path.dirname(outputPath));
                shx.mv(path.join(dir, path.basename(file)), outputPath);
                // if we are renaming the .js file, we'll also need to update the sourceMappingURL in the file
                if (outFile.endsWith('.js')) {
                    shx.chmod('+w', outputPath);
                    shx.sed('-i', `${path.basename(file)}.map`, `${path.basename(outputPath)}.map`, outputPath);
                }
            }
        }
        /**
         * Inserts or edits properties into the package.json file(s) in the package so that
         * they point to all the right generated artifacts.
         *
         * @param packageJson The path to the package.json file.
         * @param parsedPackage Parsed package.json content
         * @param isGeneratedPackageJson Whether the passed package.json has been generated.
         */
        function amendPackageJson(packageJson, parsedPackage, isGeneratedPackageJson) {
            const packageName = parsedPackage['name'];
            const moduleData = modulesManifest[packageName];
            // We don't want to modify the "package.json" if we guessed the entry-point
            // paths and there is a custom "package.json" for that package already. Module
            // data will be only undefined if the package name comes from a non-generated
            // "package.json". In that case we want to leave the file untouched as well.
            if (!moduleData || moduleData.guessedPaths && !isGeneratedPackageJson) {
                // Ideally we should throw here, as we got an entry point that doesn't
                // have flat module metadata / bundle index, so it may have been an
                // ng_module that's missing a module_name attribute.
                // However, @angular/compiler can't be an ng_module, as it's the internals
                // of the ngc compiler, yet we want to build an ng_package for it.
                // So ignore package.json files when we are missing data.
                console.error('WARNING: no module metadata for package', packageName);
                console.error('   Not updating the package.json file to point to it');
                console.error('   The ng_module for this package is possibly missing the module_name attribute ');
                return JSON.stringify(parsedPackage, null, 2);
            }
            // Derive the paths to the files from the hard-coded names we gave them.
            // TODO(alexeagle): it would be better to transfer this information from the place
            // where we created the filenames, via the modulesManifestArg
            parsedPackage['main'] = getBundleName(packageName, 'bundles');
            parsedPackage['fesm5'] = getBundleName(packageName, 'fesm5');
            parsedPackage['fesm2015'] = getBundleName(packageName, 'fesm2015');
            parsedPackage['esm5'] = srcDirRelative(packageJson, moduleData['esm5_index']);
            parsedPackage['esm2015'] = srcDirRelative(packageJson, moduleData['esm2015_index']);
            parsedPackage['typings'] = srcDirRelative(packageJson, moduleData['typings']);
            // For now, we point the primary entry points at the fesm files, because of Webpack
            // performance issues with a large number of individual files.
            // TODO(iminar): resolve performance issues with the toolchain and point these to esm
            parsedPackage['module'] = parsedPackage['fesm5'];
            parsedPackage['es2015'] = parsedPackage['fesm2015'];
            return JSON.stringify(parsedPackage, null, 2);
        }
        // e.g. @angular/common/http/testing -> ../../bundles/common-http-testing.umd.js
        // or   @angular/common/http/testing -> ../../fesm5/http/testing.js
        function getBundleName(packageName, dir) {
            const parts = packageName.split('/');
            // Remove the scoped package part, like @angular if present
            const nameParts = packageName.startsWith('@') ? parts.splice(1) : parts;
            const relativePath = newArray(nameParts.length - 1, '..').join('/') || '.';
            let basename;
            if (dir === 'bundles') {
                basename = nameParts.join('-') + '.umd';
            }
            else if (nameParts.length === 1) {
                basename = nameParts[0];
            }
            else {
                basename = nameParts.slice(1).join('/');
            }
            return [relativePath, dir, basename + '.js'].join('/');
        }
        /** Creates metadata re-export file for a secondary entry-point. */
        function createMetadataReexportFile(entryPointName, metadataFile, packageName) {
            const inputPath = path.join(srcDir, `${entryPointName}.metadata.json`);
            writeFileFromInputPath(inputPath, JSON.stringify({
                '__symbolic': 'module',
                'version': 3,
                'metadata': {},
                'exports': [{ 'from': `${srcDirRelative(inputPath, metadataFile.replace(/.metadata.json$/, ''))}` }],
                'flatModuleIndexRedirect': true,
                'importAs': packageName
            }) + '\n');
        }
        /**
         * Creates a typings (d.ts) re-export file for a secondary-entry point,
         * e.g., `export * from './common/common'`
         */
        function createTypingsReexportFile(entryPointName, license, typingsFile) {
            const inputPath = path.join(srcDir, `${entryPointName}.d.ts`);
            const content = `${license}
export * from '${srcDirRelative(inputPath, typingsFile.replace(/\.d\.tsx?$/, ''))}';
`;
            writeFileFromInputPath(inputPath, content);
        }
        /**
         * Creates a package.json for a secondary entry-point.
         * @param dir The directory under which the package.json should be written.
         * @param entryPointPackageName The full package name for the entry point,
         *     e.g. '@angular/common/http'.
         */
        function createEntryPointPackageJson(dir, entryPointPackageName) {
            const pkgJson = path.join(srcDir, dir, 'package.json');
            const content = amendPackageJson(pkgJson, { name: entryPointPackageName }, true);
            writeFileFromInputPath(pkgJson, content);
        }
        /**
         * Normalizes the specified path by replacing backslash separators with Posix
         * forward slash separators.
         */
        function normalizeSeparators(path) { return path.replace(/\\/g, '/'); }
        /**
        * Rewires metadata to point to the flattened dts file.
        *
        * @param metadataPath the metadata file path
        * @param typingsPath the typings bundle entrypoint
        */
        function rewireMetadata(metadataPath, typingsPath) {
            const metadata = JSON.parse(fs.readFileSync(metadataPath, 'utf-8'));
            let typingsRelativePath = normalizeSeparators(path.relative(path.dirname(metadataPath), typingsPath));
            if (!typingsRelativePath.startsWith('..')) {
                typingsRelativePath = `./${typingsRelativePath}`;
            }
            typingsRelativePath = typingsRelativePath.replace('.d.ts', '');
            // the regexp here catches all relative paths such as:
            // ./src/core/foo.d.ts and ../src/core/foo.d.ts
            const relativePathRegex = /\.?\.\/[\w\.\-_\/]+/g;
            if (metadata.exports) {
                // Strip re-exports which are now self-references
                metadata.exports =
                    metadata.exports.filter((e) => !e.from.match(relativePathRegex));
            }
            return JSON.stringify(metadata).replace(relativePathRegex, typingsRelativePath);
        }
        /**
         * Strip the named AMD module for compatibility with non-bazel users from typings content
         * @param filePath dts file path
         */
        function readTypingsAndStripAmdModule(filePath) {
            return fs
                .readFileSync(filePath, 'utf-8')
                // Strip the named AMD module for compatibility with non-bazel users
                .replace(/^\/\/\/ <amd-module name=.*\/>[\r\n]+/gm, '');
        }
    }
    if (require.main === module) {
        process.exitCode = main(process.argv.slice(2));
    }
    function newArray(size, value) {
        const list = [];
        for (let i = 0; i < size; i++) {
            list.push(value);
        }
        return list;
    }
    exports.newArray = newArray;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFja2FnZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9iYXplbC9zcmMvbmdfcGFja2FnZS9wYWNrYWdlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7Ozs7Ozs7Ozs7OztJQUVILHlCQUF5QjtJQUN6Qiw2QkFBNkI7SUFDN0IsK0JBQStCO0lBRS9CLFNBQVMsSUFBSSxDQUFDLElBQWM7UUFDMUIsK0NBQStDO1FBQy9DLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFZCw2RkFBNkY7UUFDN0YsSUFBSSxlQUFlLEdBQUcsS0FBSyxDQUFDO1FBRTVCLDBGQUEwRjtRQUMxRiw2RkFBNkY7UUFDN0YsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRTlCLDZDQUE2QztRQUM3QyxTQUFTLGdCQUFnQixDQUFDLENBQVMsSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUU1RSxxREFBcUQ7UUFDckQsTUFBTSxNQUFNLEdBQUcsRUFBRSxDQUFDLFlBQVksQ0FBQyxhQUFhLEVBQUUsT0FBTyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1FBRXpGLE1BQU07UUFDRix3Q0FBd0M7UUFDeEMsR0FBRztRQUVILDhFQUE4RTtRQUM5RSxNQUFNO1FBRU4sOEVBQThFO1FBQzlFLDhEQUE4RDtRQUM5RCxNQUFNO1FBRU4sbUZBQW1GO1FBQ25GLFdBQVc7UUFFWCx1RUFBdUU7UUFDdkUsb0NBQW9DO1FBQ3BDLHNCQUFzQjtRQUN0QixrREFBa0Q7UUFDbEQsc0RBQXNEO1FBQ3RELCtEQUErRDtRQUMvRCxNQUFNO1FBQ04sTUFBTTtRQUNOLElBQUk7UUFDSixrQkFBa0I7UUFFbEIsbUNBQW1DO1FBQ25D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QUFtQixDQUFDLENBQUM7UUFDbEYsQ0FBQztRQUVEOzs7V0FHRztRQUNILFNBQVMsNEJBQTRCLENBQUMsUUFBZ0I7WUFDcEQsT0FBTyxFQUFFO2lCQUNKLFlBQVksQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDO2dCQUNoQyxvRUFBb0U7aUJBQ25FLE9BQU8sQ0FBQyx5Q0FBeUMsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUM5RCxDQUFDO0lBQ0gsQ0FBQztJQUVELElBQUksT0FBTyxDQUFDLElBQUksS0FBSyxNQUFNLEVBQUU7UUFDM0IsT0FBTyxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNoRDtJQUlELFNBQWdCLFFBQVEsQ0FBSSxJQUFZLEVBQUUsS0FBUztRQUNqRCxNQUFNLElBQUksR0FBUSxFQUFFLENBQUM7UUFDckIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUM3QixJQUFJLENBQUMsSUFBSSxDQUFDLEtBQU8sQ0FBQyxDQUFDO1NBQ3BCO1FBQ0QsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBTkQsNEJBTUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyBzaHggZnJvbSAnc2hlbGxqcyc7XG5cbmZ1bmN0aW9uIG1haW4oYXJnczogc3RyaW5nW10pOiBudW1iZXIge1xuICAvLyBFeGl0IGltbWVkaWF0ZWx5IHdoZW4gZW5jb3VudGVyaW5nIGFuIGVycm9yLlxuICBzaHguc2V0KCctZScpO1xuXG4gIC8vIEtlZXAgdHJhY2sgb2Ygd2hldGhlciBhbiBlcnJvciBoYXMgb2NjdXJlZCBzbyB0aGF0IHdlIGNhbiByZXR1cm4gYW4gYXBwcm9wcmlhdGUgZXhpdCBjb2RlLlxuICBsZXQgZXJyb3JIYXNPY2N1cmVkID0gZmFsc2U7XG5cbiAgLy8gVGhpcyB1dGlsaXR5IGV4cGVjdHMgYWxsIG9mIGl0cyBhcmd1bWVudHMgdG8gYmUgc3BlY2lmaWVkIGluIGEgcGFyYW1zIGZpbGUgZ2VuZXJhdGVkIGJ5XG4gIC8vIGJhemVsIChzZWUgaHR0cHM6Ly9kb2NzLmJhemVsLmJ1aWxkL3ZlcnNpb25zL21hc3Rlci9za3lsYXJrL2xpYi9BcmdzLmh0bWwjdXNlX3BhcmFtX2ZpbGUpLlxuICBjb25zdCBwYXJhbUZpbGVQYXRoID0gYXJnc1swXTtcblxuICAvLyBCYXplbCBwYXJhbXMgbWF5IGJlIHN1cnJvdW5kZWQgd2l0aCBxdW90ZXNcbiAgZnVuY3Rpb24gdW5xdW90ZVBhcmFtZXRlcihzOiBzdHJpbmcpIHsgcmV0dXJuIHMucmVwbGFjZSgvXicoLiopJyQvLCAnJDEnKTsgfVxuXG4gIC8vIFBhcmFtZXRlcnMgYXJlIHNwZWNpZmllZCBpbiB0aGUgZmlsZSBvbmUgcGVyIGxpbmUuXG4gIGNvbnN0IHBhcmFtcyA9IGZzLnJlYWRGaWxlU3luYyhwYXJhbUZpbGVQYXRoLCAndXRmLTgnKS5zcGxpdCgnXFxuJykubWFwKHVucXVvdGVQYXJhbWV0ZXIpO1xuXG4gIGNvbnN0IFtcbiAgICAgIC8vIE91dHB1dCBkaXJlY3RvcnkgZm9yIHRoZSBucG0gcGFja2FnZS5cbiAgICAgIG91dCxcblxuICAgICAgLy8gVGhlIHBhY2thZ2Ugc2VnbWVudCBvZiB0aGUgbmdfcGFja2FnZSBydWxlJ3MgbGFiZWwgKGUuZy4gJ3BhY2thZ2UvY29tbW9uJykuXG4gICAgICBzcmNEaXIsXG5cbiAgICAgIC8vIFRoZSBiYXplbC1iaW4gZGlyIGpvaW5lZCB3aXRoIHRoZSBzcmNEaXIgKGUuZy4gJ2JhemVsLWJpbi9wYWNrYWdlLmNvbW1vbicpLlxuICAgICAgLy8gVGhpcyBpcyB0aGUgaW50ZW5kZWQgb3V0cHV0IGxvY2F0aW9uIGZvciBwYWNrYWdlIGFydGlmYWN0cy5cbiAgICAgIGJpbkRpcixcblxuICAgICAgLy8gVGhlIGJhemVsLWdlbmZpbGVzIGRpciBqb2luZWQgd2l0aCB0aGUgc3JjRGlyIChlLmcuICdiYXplbC1iaW4vcGFja2FnZS5jb21tb24nKS5cbiAgICAgIGdlbmZpbGVzRGlyLFxuXG4gICAgICAvLyBKU09OIGRhdGEgbWFwcGluZyBlYWNoIGVudHJ5IHBvaW50IHRvIHRoZSBnZW5lcmF0ZWQgYnVuZGxlIGluZGV4IGFuZFxuICAgICAgLy8gZmxhdCBtb2R1bGUgbWV0YWRhdGEsIGZvciBleGFtcGxlXG4gICAgICAvLyB7XCJAYW5ndWxhci9jb3JlXCI6IHtcbiAgICAgIC8vICAgICBcImluZGV4XCI6IFwiYmF6ZWwtYmluL3BhY2thZ2VzL2NvcmUvY29yZS5qc1wiLFxuICAgICAgLy8gICAgIFwidHlwaW5nc1wiOiBcImJhemVsLWJpbi9wYWNrYWdlcy9jb3JlL2NvcmUuZC50c1wiLFxuICAgICAgLy8gICAgIFwibWV0YWRhdGFcIjogXCJiYXplbC1iaW4vcGFja2FnZXMvY29yZS9jb3JlLm1ldGFkYXRhLmpzb25cIlxuICAgICAgLy8gIH0sXG4gICAgICAvLyAuLi5cbiAgICAgIC8vIH1cbiAgICAgIG1vZHVsZXNNYW5pZmVzdEFyZyxcblxuICAgICAgLy8gUGF0aCB0byB0aGUgcGFja2FnZSdzIFJFQURNRS5tZC5cbiAgICAgIHJlYWRtZU1kLFxuXG4gICAgICAvLyBMaXN0IG9mIHJvbGxlZC11cCBmbGF0IEVTMjAxNSBtb2R1bGVzXG4gICAgICBmZXNtMjAxNUFyZyxcblxuICAgICAgLy8gTGlzdCBvZiByb2xsZWQtdXAgZmxhdCBFUzUgbW9kdWxlc1xuICAgICAgZmVzbTVBcmcsXG5cbiAgICAgIC8vIExpc3Qgb2YgaW5kaXZpZHVhbCBFUzIwMTUgbW9kdWxlc1xuICAgICAgZXNtMjAxNUFyZyxcblxuICAgICAgLy8gTGlzdCBvZiBpbmRpdmlkdWFsIEVTNSBtb2R1bGVzXG4gICAgICBlc201QXJnLFxuXG4gICAgICAvLyBMaXN0IG9mIGFsbCBVTUQgYnVuZGxlcyBnZW5lcmF0ZWQgYnkgcm9sbHVwLlxuICAgICAgYnVuZGxlc0FyZyxcblxuICAgICAgLy8gTGlzdCBvZiBhbGwgZmlsZXMgaW4gdGhlIG5nX3BhY2thZ2UgcnVsZSdzIHNyY3MuXG4gICAgICBzcmNzQXJnLFxuXG4gICAgICAvLyBMaXN0IG9mIGFsbCB0eXBlIGRlZmluaXRpb25zIHRoYXQgbmVlZCB0byBwYWNrYWdlZCBpbnRvIHRoZSBuZ19wYWNrYWdlLlxuICAgICAgdHlwZURlZmluaXRpb25zQXJnLFxuXG4gICAgICAvLyBMaXN0IG9mIGFsbCBmaWxlcyBpbiB0aGUgbmdfcGFja2FnZSBydWxlJ3MgZGF0YS5cbiAgICAgIGRhdGFBcmcsXG5cbiAgICAgIC8vIFBhdGggdG8gdGhlIHBhY2thZ2UncyBMSUNFTlNFLlxuICAgICAgbGljZW5zZUZpbGUsXG5cbiAgICAgIC8vIExpc3Qgb2YgYWxsIGR0cyBidW5kbGVzIGdlbmVyYXRlZCBieSB0aGUgQVBJIGV4dHJhY3Rvci5cbiAgICAgIGR0c0J1bmRsZUFyZyxcblxuICAgICAgLy8gVGhlIGR0cyBidW5kbGUgZmlsZSBzdWZmaXggZXhhbXBsZTogJy5idW5kbGUuZC50cydcbiAgICAgIGR0c0J1bmRsZUZpbGVTdWZmaXgsXG4gIF0gPSBwYXJhbXM7XG5cbiAgY29uc3QgZmVzbTIwMTUgPSBmZXNtMjAxNUFyZy5zcGxpdCgnLCcpLmZpbHRlcihzID0+ICEhcyk7XG4gIGNvbnN0IGZlc201ID0gZmVzbTVBcmcuc3BsaXQoJywnKS5maWx0ZXIocyA9PiAhIXMpO1xuICBjb25zdCBlc20yMDE1ID0gZXNtMjAxNUFyZy5zcGxpdCgnLCcpLmZpbHRlcihzID0+ICEhcyk7XG4gIGNvbnN0IGVzbTUgPSBlc201QXJnLnNwbGl0KCcsJykuZmlsdGVyKHMgPT4gISFzKTtcbiAgY29uc3QgYnVuZGxlcyA9IGJ1bmRsZXNBcmcuc3BsaXQoJywnKS5maWx0ZXIocyA9PiAhIXMpO1xuICBjb25zdCB0eXBlRGVmaW5pdGlvbnMgPSB0eXBlRGVmaW5pdGlvbnNBcmcuc3BsaXQoJywnKS5maWx0ZXIocyA9PiAhIXMpO1xuICBjb25zdCBzcmNzID0gc3Jjc0FyZy5zcGxpdCgnLCcpLmZpbHRlcihzID0+ICEhcyk7XG4gIGNvbnN0IGRhdGFGaWxlczogc3RyaW5nW10gPSBkYXRhQXJnLnNwbGl0KCcsJykuZmlsdGVyKHMgPT4gISFzKTtcbiAgY29uc3QgbW9kdWxlc01hbmlmZXN0ID0gSlNPTi5wYXJzZShtb2R1bGVzTWFuaWZlc3RBcmcpO1xuICBjb25zdCBkdHNCdW5kbGVzOiBzdHJpbmdbXSA9IGR0c0J1bmRsZUFyZy5zcGxpdCgnLCcpLmZpbHRlcihzID0+ICEhcyk7XG5cbiAgaWYgKHJlYWRtZU1kKSB7XG4gICAgY29weUZpbGUocmVhZG1lTWQsIG91dCk7XG4gIH1cblxuICAvKipcbiAgICogV3JpdGVzIGEgZmlsZSBpbnRvIHRoZSBwYWNrYWdlIGJhc2VkIG9uIGl0cyBpbnB1dCBwYXRoLCByZWxhdGl2aXppbmcgdG8gdGhlIHBhY2thZ2UgcGF0aC5cbiAgICogQHBhcmFtIGlucHV0UGF0aCBQYXRoIHRvIHRoZSBmaWxlIGluIHRoZSBpbnB1dCB0cmVlLlxuICAgKiBAcGFyYW0gZmlsZUNvbnRlbnQgQ29udGVudCBvZiB0aGUgZmlsZS5cbiAgICovXG4gIGZ1bmN0aW9uIHdyaXRlRmlsZUZyb21JbnB1dFBhdGgoaW5wdXRQYXRoOiBzdHJpbmcsIGZpbGVDb250ZW50OiBzdHJpbmcgfCBCdWZmZXIpIHtcbiAgICAvLyBXZSB3YW50IHRoZSByZWxhdGl2ZSBwYXRoIGZyb20gdGhlIGdpdmVuIGZpbGUgdG8gaXRzIGFuY2VzdG9yIFwicm9vdFwiIGRpcmVjdG9yeS5cbiAgICAvLyBUaGlzIHJvb3QgZGVwZW5kcyBvbiB3aGV0aGVyIHRoZSBmaWxlIGxpdmVzIGluIHRoZSBzb3VyY2UgdHJlZSAoc3JjRGlyKSBhcyBhIGJhc2ljIGZpbGVcbiAgICAvLyBpbnB1dCB0byBuZ19wYWNrYWdlLCB0aGUgYmluIG91dHB1dCB0cmVlIChiaW5EaXIpIGFzIHRoZSBvdXRwdXQgb2YgYW5vdGhlciBydWxlLCBvclxuICAgIC8vIHRoZSBnZW5maWxlcyBvdXRwdXQgdHJlZSAoZ2VuZmlsZXNEaXIpIGFzIHRoZSBvdXRwdXQgb2YgYSBnZW5ydWxlLlxuICAgIGxldCByb290RGlyOiBzdHJpbmc7XG4gICAgaWYgKGlucHV0UGF0aC5pbmNsdWRlcyhiaW5EaXIpKSB7XG4gICAgICByb290RGlyID0gYmluRGlyO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRQYXRoLmluY2x1ZGVzKGdlbmZpbGVzRGlyKSkge1xuICAgICAgcm9vdERpciA9IGdlbmZpbGVzRGlyO1xuICAgIH0gZWxzZSB7XG4gICAgICByb290RGlyID0gc3JjRGlyO1xuICAgIH1cblxuICAgIGNvbnN0IG91dHB1dFBhdGggPSBwYXRoLmpvaW4ob3V0LCBwYXRoLnJlbGF0aXZlKHJvb3REaXIsIGlucHV0UGF0aCkpO1xuXG4gICAgLy8gQWx3YXlzIGVuc3VyZSB0aGF0IHRoZSB0YXJnZXQgZGlyZWN0b3J5IGV4aXN0cy5cbiAgICBzaHgubWtkaXIoJy1wJywgcGF0aC5kaXJuYW1lKG91dHB1dFBhdGgpKTtcbiAgICBmcy53cml0ZUZpbGVTeW5jKG91dHB1dFBhdGgsIGZpbGVDb250ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3BpZXMgYSBmaWxlIGludG8gdGhlIHBhY2thZ2UgYmFzZWQgb24gaXRzIGlucHV0IHBhdGgsIHJlbGF0aXZpemluZyB0byB0aGUgcGFja2FnZSBwYXRoLlxuICAgKiBAcGFyYW0gaW5wdXRQYXRoIGEgcGF0aCByZWxhdGl2ZSB0byB0aGUgYmluRGlyLCB0eXBpY2FsbHkgZnJvbSBhIGZpbGUgaW4gdGhlIGRlcHNbXVxuICAgKi9cbiAgZnVuY3Rpb24gY29weUZpbGVGcm9tSW5wdXRQYXRoKGlucHV0UGF0aDogc3RyaW5nKSB7XG4gICAgd3JpdGVGaWxlRnJvbUlucHV0UGF0aChpbnB1dFBhdGgsIGZzLnJlYWRGaWxlU3luYyhpbnB1dFBhdGgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxhdGl2aXplIHRoZSBwYXRoIHdoZXJlIGEgZmlsZSBpcyB3cml0dGVuLlxuICAgKiBAcGFyYW0gZmlsZSBhIHBhdGggY29udGFpbmluZyBhIHJlLXJvb3RlZCBzZWdtZW50IGxpa2UgLmVzbTVcbiAgICogQHBhcmFtIHN1ZmZpeCB0aGUgcmUtcm9vdGVkIGRpcmVjdG9yeVxuICAgKiBAcGFyYW0gb3V0RGlyIHBhdGggd2hlcmUgd2UgY29weSB0aGUgZmlsZSwgcmVsYXRpdmUgdG8gdGhlIG91dFxuICAgKi9cbiAgZnVuY3Rpb24gd3JpdGVFc21GaWxlKGZpbGU6IHN0cmluZywgc3VmZml4OiBzdHJpbmcsIG91dERpcjogc3RyaW5nKSB7XG4gICAgZnVuY3Rpb24gcmVsUGF0aChmaWxlOiBzdHJpbmcsIHN1ZmZpeDogc3RyaW5nKSB7XG4gICAgICBpZiAoc3VmZml4KSB7XG4gICAgICAgIC8vIE5vdGUgdGhhdCB0aGUgc3BlY2lmaWVkIGZpbGUgcGF0aCBpcyBhbHdheXMgdXNpbmcgdGhlIHBvc2l4IHBhdGggZGVsaW1pdGVyLlxuICAgICAgICBjb25zdCByb290ID1cbiAgICAgICAgICAgIHN1ZmZpeCA/IGZpbGUuc3Vic3RyKDAsIGZpbGUubGFzdEluZGV4T2YoYCR7c3VmZml4fS9gKSArIHN1ZmZpeC5sZW5ndGggKyAxKSA6IGJpbkRpcjtcbiAgICAgICAgcmV0dXJuIHBhdGguZGlybmFtZShwYXRoLnJlbGF0aXZlKHBhdGguam9pbihyb290LCBzcmNEaXIpLCBmaWxlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcGF0aC5kaXJuYW1lKHBhdGgucmVsYXRpdmUoYmluRGlyLCBmaWxlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlbCA9IHJlbFBhdGgoZmlsZSwgc3VmZml4KTtcbiAgICBpZiAoIXJlbC5zdGFydHNXaXRoKCcuLicpKSB7XG4gICAgICBjb3B5RmlsZShmaWxlLCBwYXRoLmpvaW4ob3V0LCBvdXREaXIpLCByZWwpO1xuICAgIH1cbiAgfVxuXG4gIGVzbTIwMTUuZm9yRWFjaChmaWxlID0+IHdyaXRlRXNtRmlsZShmaWxlLCAnJywgJ2VzbTIwMTUnKSk7XG4gIGVzbTUuZm9yRWFjaChmaWxlID0+IHdyaXRlRXNtRmlsZShmaWxlLCAnLmVzbTUnLCAnZXNtNScpKTtcblxuICBidW5kbGVzLmZvckVhY2goYnVuZGxlID0+IHsgY29weUZpbGUoYnVuZGxlLCBvdXQsICdidW5kbGVzJyk7IH0pO1xuICBmZXNtMjAxNS5mb3JFYWNoKGZpbGUgPT4geyBjb3B5RmlsZShmaWxlLCBvdXQsICdmZXNtMjAxNScpOyB9KTtcbiAgZmVzbTUuZm9yRWFjaChmaWxlID0+IHsgY29weUZpbGUoZmlsZSwgb3V0LCAnZmVzbTUnKTsgfSk7XG5cbiAgLy8gQ29weSBhbGwgdHlwZSBkZWZpbml0aW9ucyBpbnRvIHRoZSBwYWNrYWdlLiBUaGlzIGlzIG5lY2Vzc2FyeSBzbyB0aGF0IGRldmVsb3BlcnMgY2FuIHVzZVxuICAvLyB0aGUgcGFja2FnZSB3aXRoIHR5cGUgZGVmaW5pdGlvbnMuXG4gIHR5cGVEZWZpbml0aW9ucy5mb3JFYWNoKGYgPT4gd3JpdGVGaWxlRnJvbUlucHV0UGF0aChmLCByZWFkVHlwaW5nc0FuZFN0cmlwQW1kTW9kdWxlKGYpKSk7XG5cbiAgLy8gQ29weSBhbGwgYGRhdGFgIGZpbGVzIGludG8gdGhlIHBhY2thZ2UuIFRoZXNlIGFyZSBmaWxlcyB0aGF0IGFyZW4ndCBidWlsdCBieSB0aGUgbmdfcGFja2FnZVxuICAvLyBydWxlLCBidXQgaW5zdGVhZCBhcmUganVzdCBzdHJhaWdodCBjb3BpZWQgaW50byB0aGUgcGFja2FnZSwgZS5nLiBnbG9iYWwgQ1NTIGFzc2V0cy5cbiAgZGF0YUZpbGVzLmZvckVhY2goZiA9PiBjb3B5RmlsZUZyb21JbnB1dFBhdGgoZikpO1xuXG4gIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgZW50cnkgcG9pbnQgbW9kdWxlc1xuICAvLyBXZSBkbyB0aGlzIGZpcnN0IGJlY2F1c2Ugd2UgYWxzbyByZWNvcmQgbmV3IHBhdGhzIGZvciB0aGUgZXNtNSBhbmQgZXNtMjAxNSBjb3BpZXNcbiAgLy8gb2YgdGhlIGluZGV4IEpTIGZpbGUsIHdoaWNoIHdlIG5lZWQgdG8gYW1lbmQgdGhlIHBhY2thZ2UuanNvbi5cbiAgT2JqZWN0LmtleXMobW9kdWxlc01hbmlmZXN0KS5mb3JFYWNoKG1vZHVsZU5hbWUgPT4ge1xuICAgIGNvbnN0IG1vZHVsZUZpbGVzID0gbW9kdWxlc01hbmlmZXN0W21vZHVsZU5hbWVdO1xuICAgIGNvbnN0IHJlbGF0aXZlID0gcGF0aC5yZWxhdGl2ZShiaW5EaXIsIG1vZHVsZUZpbGVzWydpbmRleCddKTtcblxuICAgIG1vZHVsZUZpbGVzWydlc201X2luZGV4J10gPSBwYXRoLmpvaW4oYmluRGlyLCAnZXNtNScsIHJlbGF0aXZlKTtcbiAgICBtb2R1bGVGaWxlc1snZXNtMjAxNV9pbmRleCddID0gcGF0aC5qb2luKGJpbkRpciwgJ2VzbTIwMTUnLCByZWxhdGl2ZSk7XG5cbiAgICAvLyBNZXRhZGF0YSBmaWxlIGlzIG9wdGlvbmFsIGFzIGVudHJ5LXBvaW50cyBjYW4gYmUgYWxzbyBidWlsdFxuICAgIC8vIHdpdGggdGhlIFwidHNfbGlicmFyeVwiIHJ1bGUuXG4gICAgY29uc3QgbWV0YWRhdGFGaWxlID0gbW9kdWxlRmlsZXNbJ21ldGFkYXRhJ107XG4gICAgaWYgKCFtZXRhZGF0YUZpbGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB0eXBpbmdzT3V0RmlsZSA9IG1vZHVsZUZpbGVzWyd0eXBpbmdzJ107XG4gICAgLy8gV2Ugb25seSBzdXBwb3J0IGFsbCBtb2R1bGVzIHdpdGhpbiBhIHBhY2thZ2UgdG8gYmUgZHRzIGJ1bmRsZWRcbiAgICAvLyBpZTogaWYgQGFuZ3VsYXIvY29tbW9uL2h0dHAgaGFzIGZsYXQgZHRzLCBzbyBzaG91bGQgQGFuZ3VsYXIvY29tbW9uXG4gICAgaWYgKGR0c0J1bmRsZXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBtZXRhZGF0YUNvbnRlbnQgPSByZXdpcmVNZXRhZGF0YShtZXRhZGF0YUZpbGUsIHR5cGluZ3NPdXRGaWxlKTtcbiAgICAgIHdyaXRlRmlsZUZyb21JbnB1dFBhdGgobWV0YWRhdGFGaWxlLCBtZXRhZGF0YUNvbnRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb3B5RmlsZUZyb21JbnB1dFBhdGgobWV0YWRhdGFGaWxlKTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IGxpY2Vuc2VCYW5uZXIgPSBsaWNlbnNlRmlsZSA/IGZzLnJlYWRGaWxlU3luYyhsaWNlbnNlRmlsZSwgJ3V0Zi04JykgOiAnJztcblxuICBkdHNCdW5kbGVzLmZvckVhY2goYnVuZGxlRmlsZSA9PiB7XG4gICAgY29uc3QgY2xlYW5EaXN0UGF0aCA9IGJ1bmRsZUZpbGUucmVwbGFjZShkdHNCdW5kbGVGaWxlU3VmZml4LCAnLmQudHMnKTtcbiAgICAvLyBBUEkgZXh0cmFjdG9yIHdpbGwgbm90IGRlZHVwZSBsaWNlbnNlIGNvbW1lbnRzIGZyb20gdmFyaW91cyBmaWxlc1xuICAgIC8vIHRoaXMgd2lsbCByZW1vdmUgYWxsIHRoZSBsaWNlbnNlIGNvbW1lbnRzIGFuZCBhcHBlbmQgdGhlIGxpY2Vuc2UgYmFubmVyLlxuICAgIGNvbnN0IGNvbnRlbnQgPSBsaWNlbnNlQmFubmVyICsgJ1xcbicgK1xuICAgICAgICByZWFkVHlwaW5nc0FuZFN0cmlwQW1kTW9kdWxlKGJ1bmRsZUZpbGUpXG4gICAgICAgICAgICAucmVwbGFjZSgvKFxcL1xcKlxcKlxccytcXCpcXHNcXEBsaWNlbnNlKCgoPyFcXCpcXC8pLnxcXHMpKilcXCpcXC8pL2dtLCAnJyk7XG5cbiAgICB3cml0ZUZpbGVGcm9tSW5wdXRQYXRoKGNsZWFuRGlzdFBhdGgsIGNvbnRlbnQpO1xuICB9KTtcblxuICAvLyBSb290IHBhY2thZ2UgbmFtZSAoZS5nLiAnQGFuZ3VsYXIvY29tbW9uJyksIGNhcHR1cmVzIGFzIHdlIGl0ZXJhdGUgdGhyb3VnaCBzb3VyY2VzIGJlbG93LlxuICBsZXQgcm9vdFBhY2thZ2VOYW1lID0gJyc7XG4gIGNvbnN0IHBhY2thZ2VzV2l0aEV4aXN0aW5nUGFja2FnZUpzb24gPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICBmb3IgKGNvbnN0IHNyYyBvZiBzcmNzKSB7XG4gICAgaWYgKHNyYy5pbmNsdWRlcyhiaW5EaXIpIHx8IHNyYy5pbmNsdWRlcyhnZW5maWxlc0RpcikpIHtcbiAgICAgIGVycm9ySGFzT2NjdXJlZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdUaGUgXCJzcmNzXCIgZm9yIG5nX3BhY2thZ2Ugc2hvdWxkIG5vdCBpbmNsdWRlIG91dHB1dCBvZiBvdGhlciBydWxlcy4gRm91bmQ6XFxuJyArXG4gICAgICAgICAgYCAgJHtzcmN9YCk7XG4gICAgfVxuXG4gICAgbGV0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoc3JjLCAndXRmLTgnKTtcbiAgICAvLyBNb2RpZnkgcGFja2FnZS5qc29uIGZpbGVzIGFzIG5lY2Vzc2FyeSBmb3IgcHVibGlzaGluZ1xuICAgIGlmIChwYXRoLmJhc2VuYW1lKHNyYykgPT09ICdwYWNrYWdlLmpzb24nKSB7XG4gICAgICBjb25zdCBwYWNrYWdlSnNvbiA9IEpTT04ucGFyc2UoY29udGVudCk7XG4gICAgICBjb250ZW50ID0gYW1lbmRQYWNrYWdlSnNvbihzcmMsIHBhY2thZ2VKc29uLCBmYWxzZSk7XG5cbiAgICAgIGNvbnN0IHBhY2thZ2VOYW1lID0gcGFja2FnZUpzb25bJ25hbWUnXTtcbiAgICAgIHBhY2thZ2VzV2l0aEV4aXN0aW5nUGFja2FnZUpzb24uYWRkKHBhY2thZ2VOYW1lKTtcblxuICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgcm9vdCBwYWNrYWdlIG5hbWUsIGUuZy4gXCJAYW5ndWxhci9jb21tb25cIi4gV2UgYXNzdW1lIHRoYXQgdGhlXG4gICAgICAvLyByb290IG5hbWUgd2lsbCBiZSBzaG9ydGVzdCBiZWNhdXNlIHNlY29uZGFyeSBlbnRyeS1wb2ludHMgd2lsbCBhcHBlbmQgdG8gaXRcbiAgICAgIC8vIChlLmcuIFwiQGFuZ3VsYXIvY29tbW9uL2h0dHBcIikuXG4gICAgICBpZiAoIXJvb3RQYWNrYWdlTmFtZSB8fCBwYWNrYWdlTmFtZS5sZW5ndGggPCByb290UGFja2FnZU5hbWUubGVuZ3RoKSB7XG4gICAgICAgIHJvb3RQYWNrYWdlTmFtZSA9IHBhY2thZ2VKc29uWyduYW1lJ107XG4gICAgICB9XG4gICAgfVxuICAgIHdyaXRlRmlsZUZyb21JbnB1dFBhdGgoc3JjLCBjb250ZW50KTtcbiAgfVxuXG4gIC8vIEdlbmVyYXRlIGV4dHJhIGZpbGVzIGZvciBzZWNvbmRhcnkgZW50cnktcG9pbnRzLlxuICBPYmplY3Qua2V5cyhtb2R1bGVzTWFuaWZlc3QpLmZvckVhY2goZW50cnlQb2ludFBhY2thZ2VOYW1lID0+IHtcbiAgICBjb25zdCBlbnRyeVBvaW50TmFtZSA9IGVudHJ5UG9pbnRQYWNrYWdlTmFtZS5zdWJzdHIocm9vdFBhY2thZ2VOYW1lLmxlbmd0aCArIDEpO1xuICAgIGlmICghZW50cnlQb2ludE5hbWUpIHJldHVybjtcblxuICAgIGNvbnN0IG1ldGFkYXRhRmlsZVBhdGggPSBtb2R1bGVzTWFuaWZlc3RbZW50cnlQb2ludFBhY2thZ2VOYW1lXVsnbWV0YWRhdGEnXTtcbiAgICBpZiAobWV0YWRhdGFGaWxlUGF0aCkge1xuICAgICAgY3JlYXRlTWV0YWRhdGFSZWV4cG9ydEZpbGUoXG4gICAgICAgICAgZW50cnlQb2ludE5hbWUsIG1vZHVsZXNNYW5pZmVzdFtlbnRyeVBvaW50UGFja2FnZU5hbWVdWydtZXRhZGF0YSddLFxuICAgICAgICAgIGVudHJ5UG9pbnRQYWNrYWdlTmFtZSk7XG4gICAgfVxuXG4gICAgY3JlYXRlVHlwaW5nc1JlZXhwb3J0RmlsZShcbiAgICAgICAgZW50cnlQb2ludE5hbWUsIGxpY2Vuc2VCYW5uZXIsIG1vZHVsZXNNYW5pZmVzdFtlbnRyeVBvaW50UGFja2FnZU5hbWVdWyd0eXBpbmdzJ10pO1xuXG4gICAgaWYgKCFwYWNrYWdlc1dpdGhFeGlzdGluZ1BhY2thZ2VKc29uLmhhcyhlbnRyeVBvaW50UGFja2FnZU5hbWUpKSB7XG4gICAgICBjcmVhdGVFbnRyeVBvaW50UGFja2FnZUpzb24oZW50cnlQb2ludE5hbWUsIGVudHJ5UG9pbnRQYWNrYWdlTmFtZSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZXJyb3JIYXNPY2N1cmVkID8gMSA6IDA7XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBiaW5EaXItcmVsYXRpdmUgcGF0aCB0byBzcmNEaXItcmVsYXRpdmVcbiAgICogQHBhcmFtIGZyb20gcGF0aCB0byBhIGZpbGUgdW5kZXIgdGhlIHNyY0RpciwgbGlrZSBwYWNrYWdlcy9jb3JlL3Rlc3RpbmcvcGFja2FnZS5qc29uXG4gICAqIEBwYXJhbSBmaWxlIHBhdGggdG8gYSBmaWxlIHVuZGVyIHRoZSBiaW5EaXIsIGxpa2UgYmF6ZWwtYmluL2NvcmUvdGVzdGluZy9nZW5lcmF0ZWQuanNcbiAgICovXG4gIGZ1bmN0aW9uIHNyY0RpclJlbGF0aXZlKGZyb206IHN0cmluZywgZmlsZTogc3RyaW5nKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbm9ybWFsaXplU2VwYXJhdG9ycyhcbiAgICAgICAgcGF0aC5yZWxhdGl2ZShwYXRoLmRpcm5hbWUoZnJvbSksIHBhdGguam9pbihzcmNEaXIsIHBhdGgucmVsYXRpdmUoYmluRGlyLCBmaWxlKSkpKTtcbiAgICBpZiAocmVzdWx0LnN0YXJ0c1dpdGgoJy4uJykpIHJldHVybiByZXN1bHQ7XG4gICAgcmV0dXJuIGAuLyR7cmVzdWx0fWA7XG4gIH1cblxuICBmdW5jdGlvbiBjb3B5RmlsZShmaWxlOiBzdHJpbmcsIGJhc2VEaXI6IHN0cmluZywgcmVsYXRpdmUgPSAnLicpIHtcbiAgICBjb25zdCBkaXIgPSBwYXRoLmpvaW4oYmFzZURpciwgcmVsYXRpdmUpO1xuICAgIC8vIG91dHB1dCBmaWxlIGlzIC5qcyBpZiB0aGUgaW5wdXQgZmlsZSBpcyAubWpzXG4gICAgY29uc3Qgb3V0RmlsZSA9IHBhdGgucG9zaXguam9pbihcbiAgICAgICAgZGlyLCBwYXRoLmJhc2VuYW1lKGZpbGUuZW5kc1dpdGgoJy5tanMnKSA/IGZpbGUucmVwbGFjZSgvXFwubWpzJC8sICcuanMnKSA6IGZpbGUpKTtcbiAgICBzaHgubWtkaXIoJy1wJywgZGlyKTtcbiAgICBzaHguY3AoZmlsZSwgb3V0RmlsZSk7XG4gICAgLy8gRG91YmxlLXVuZGVyc2NvcmUgaXMgdXNlZCB0byBlc2NhcGUgZm9yd2FyZCBzbGFzaCBpbiBGRVNNIGZpbGVuYW1lcy5cbiAgICAvLyBTZWUgbmdfcGFja2FnZS5iemw6XG4gICAgLy8gICBmZXNtX291dHB1dF9maWxlbmFtZSA9IGVudHJ5X3BvaW50LnJlcGxhY2UoXCIvXCIsIFwiX19cIilcbiAgICAvLyBXZSBuZWVkIHRvIHVuZXNjYXBlIHRoZXNlLlxuICAgIGlmIChvdXRGaWxlLmluZGV4T2YoJ19fJykgPj0gMCkge1xuICAgICAgY29uc3Qgb3V0cHV0UGF0aCA9IHBhdGguam9pbihkaXIsIC4uLnBhdGguYmFzZW5hbWUob3V0RmlsZSkuc3BsaXQoJ19fJykpO1xuICAgICAgc2h4Lm1rZGlyKCctcCcsIHBhdGguZGlybmFtZShvdXRwdXRQYXRoKSk7XG4gICAgICBzaHgubXYocGF0aC5qb2luKGRpciwgcGF0aC5iYXNlbmFtZShmaWxlKSksIG91dHB1dFBhdGgpO1xuXG4gICAgICAvLyBpZiB3ZSBhcmUgcmVuYW1pbmcgdGhlIC5qcyBmaWxlLCB3ZSdsbCBhbHNvIG5lZWQgdG8gdXBkYXRlIHRoZSBzb3VyY2VNYXBwaW5nVVJMIGluIHRoZSBmaWxlXG4gICAgICBpZiAob3V0RmlsZS5lbmRzV2l0aCgnLmpzJykpIHtcbiAgICAgICAgc2h4LmNobW9kKCcrdycsIG91dHB1dFBhdGgpO1xuICAgICAgICBzaHguc2VkKCctaScsIGAke3BhdGguYmFzZW5hbWUoZmlsZSl9Lm1hcGAsIGAke3BhdGguYmFzZW5hbWUob3V0cHV0UGF0aCl9Lm1hcGAsIG91dHB1dFBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIG9yIGVkaXRzIHByb3BlcnRpZXMgaW50byB0aGUgcGFja2FnZS5qc29uIGZpbGUocykgaW4gdGhlIHBhY2thZ2Ugc28gdGhhdFxuICAgKiB0aGV5IHBvaW50IHRvIGFsbCB0aGUgcmlnaHQgZ2VuZXJhdGVkIGFydGlmYWN0cy5cbiAgICpcbiAgICogQHBhcmFtIHBhY2thZ2VKc29uIFRoZSBwYXRoIHRvIHRoZSBwYWNrYWdlLmpzb24gZmlsZS5cbiAgICogQHBhcmFtIHBhcnNlZFBhY2thZ2UgUGFyc2VkIHBhY2thZ2UuanNvbiBjb250ZW50XG4gICAqIEBwYXJhbSBpc0dlbmVyYXRlZFBhY2thZ2VKc29uIFdoZXRoZXIgdGhlIHBhc3NlZCBwYWNrYWdlLmpzb24gaGFzIGJlZW4gZ2VuZXJhdGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gYW1lbmRQYWNrYWdlSnNvbihcbiAgICAgIHBhY2thZ2VKc29uOiBzdHJpbmcsIHBhcnNlZFBhY2thZ2U6IHtba2V5OiBzdHJpbmddOiBzdHJpbmd9LFxuICAgICAgaXNHZW5lcmF0ZWRQYWNrYWdlSnNvbjogYm9vbGVhbikge1xuICAgIGNvbnN0IHBhY2thZ2VOYW1lID0gcGFyc2VkUGFja2FnZVsnbmFtZSddO1xuICAgIGNvbnN0IG1vZHVsZURhdGEgPSBtb2R1bGVzTWFuaWZlc3RbcGFja2FnZU5hbWVdO1xuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBtb2RpZnkgdGhlIFwicGFja2FnZS5qc29uXCIgaWYgd2UgZ3Vlc3NlZCB0aGUgZW50cnktcG9pbnRcbiAgICAvLyBwYXRocyBhbmQgdGhlcmUgaXMgYSBjdXN0b20gXCJwYWNrYWdlLmpzb25cIiBmb3IgdGhhdCBwYWNrYWdlIGFscmVhZHkuIE1vZHVsZVxuICAgIC8vIGRhdGEgd2lsbCBiZSBvbmx5IHVuZGVmaW5lZCBpZiB0aGUgcGFja2FnZSBuYW1lIGNvbWVzIGZyb20gYSBub24tZ2VuZXJhdGVkXG4gICAgLy8gXCJwYWNrYWdlLmpzb25cIi4gSW4gdGhhdCBjYXNlIHdlIHdhbnQgdG8gbGVhdmUgdGhlIGZpbGUgdW50b3VjaGVkIGFzIHdlbGwuXG4gICAgaWYgKCFtb2R1bGVEYXRhIHx8IG1vZHVsZURhdGEuZ3Vlc3NlZFBhdGhzICYmICFpc0dlbmVyYXRlZFBhY2thZ2VKc29uKSB7XG4gICAgICAvLyBJZGVhbGx5IHdlIHNob3VsZCB0aHJvdyBoZXJlLCBhcyB3ZSBnb3QgYW4gZW50cnkgcG9pbnQgdGhhdCBkb2Vzbid0XG4gICAgICAvLyBoYXZlIGZsYXQgbW9kdWxlIG1ldGFkYXRhIC8gYnVuZGxlIGluZGV4LCBzbyBpdCBtYXkgaGF2ZSBiZWVuIGFuXG4gICAgICAvLyBuZ19tb2R1bGUgdGhhdCdzIG1pc3NpbmcgYSBtb2R1bGVfbmFtZSBhdHRyaWJ1dGUuXG4gICAgICAvLyBIb3dldmVyLCBAYW5ndWxhci9jb21waWxlciBjYW4ndCBiZSBhbiBuZ19tb2R1bGUsIGFzIGl0J3MgdGhlIGludGVybmFsc1xuICAgICAgLy8gb2YgdGhlIG5nYyBjb21waWxlciwgeWV0IHdlIHdhbnQgdG8gYnVpbGQgYW4gbmdfcGFja2FnZSBmb3IgaXQuXG4gICAgICAvLyBTbyBpZ25vcmUgcGFja2FnZS5qc29uIGZpbGVzIHdoZW4gd2UgYXJlIG1pc3NpbmcgZGF0YS5cbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1dBUk5JTkc6IG5vIG1vZHVsZSBtZXRhZGF0YSBmb3IgcGFja2FnZScsIHBhY2thZ2VOYW1lKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyAgIE5vdCB1cGRhdGluZyB0aGUgcGFja2FnZS5qc29uIGZpbGUgdG8gcG9pbnQgdG8gaXQnKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgJyAgIFRoZSBuZ19tb2R1bGUgZm9yIHRoaXMgcGFja2FnZSBpcyBwb3NzaWJseSBtaXNzaW5nIHRoZSBtb2R1bGVfbmFtZSBhdHRyaWJ1dGUgJyk7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGFyc2VkUGFja2FnZSwgbnVsbCwgMik7XG4gICAgfVxuXG4gICAgLy8gRGVyaXZlIHRoZSBwYXRocyB0byB0aGUgZmlsZXMgZnJvbSB0aGUgaGFyZC1jb2RlZCBuYW1lcyB3ZSBnYXZlIHRoZW0uXG4gICAgLy8gVE9ETyhhbGV4ZWFnbGUpOiBpdCB3b3VsZCBiZSBiZXR0ZXIgdG8gdHJhbnNmZXIgdGhpcyBpbmZvcm1hdGlvbiBmcm9tIHRoZSBwbGFjZVxuICAgIC8vIHdoZXJlIHdlIGNyZWF0ZWQgdGhlIGZpbGVuYW1lcywgdmlhIHRoZSBtb2R1bGVzTWFuaWZlc3RBcmdcbiAgICBwYXJzZWRQYWNrYWdlWydtYWluJ10gPSBnZXRCdW5kbGVOYW1lKHBhY2thZ2VOYW1lLCAnYnVuZGxlcycpO1xuICAgIHBhcnNlZFBhY2thZ2VbJ2Zlc201J10gPSBnZXRCdW5kbGVOYW1lKHBhY2thZ2VOYW1lLCAnZmVzbTUnKTtcbiAgICBwYXJzZWRQYWNrYWdlWydmZXNtMjAxNSddID0gZ2V0QnVuZGxlTmFtZShwYWNrYWdlTmFtZSwgJ2Zlc20yMDE1Jyk7XG5cbiAgICBwYXJzZWRQYWNrYWdlWydlc201J10gPSBzcmNEaXJSZWxhdGl2ZShwYWNrYWdlSnNvbiwgbW9kdWxlRGF0YVsnZXNtNV9pbmRleCddKTtcbiAgICBwYXJzZWRQYWNrYWdlWydlc20yMDE1J10gPSBzcmNEaXJSZWxhdGl2ZShwYWNrYWdlSnNvbiwgbW9kdWxlRGF0YVsnZXNtMjAxNV9pbmRleCddKTtcbiAgICBwYXJzZWRQYWNrYWdlWyd0eXBpbmdzJ10gPSBzcmNEaXJSZWxhdGl2ZShwYWNrYWdlSnNvbiwgbW9kdWxlRGF0YVsndHlwaW5ncyddKTtcblxuICAgIC8vIEZvciBub3csIHdlIHBvaW50IHRoZSBwcmltYXJ5IGVudHJ5IHBvaW50cyBhdCB0aGUgZmVzbSBmaWxlcywgYmVjYXVzZSBvZiBXZWJwYWNrXG4gICAgLy8gcGVyZm9ybWFuY2UgaXNzdWVzIHdpdGggYSBsYXJnZSBudW1iZXIgb2YgaW5kaXZpZHVhbCBmaWxlcy5cbiAgICAvLyBUT0RPKGltaW5hcik6IHJlc29sdmUgcGVyZm9ybWFuY2UgaXNzdWVzIHdpdGggdGhlIHRvb2xjaGFpbiBhbmQgcG9pbnQgdGhlc2UgdG8gZXNtXG4gICAgcGFyc2VkUGFja2FnZVsnbW9kdWxlJ10gPSBwYXJzZWRQYWNrYWdlWydmZXNtNSddO1xuICAgIHBhcnNlZFBhY2thZ2VbJ2VzMjAxNSddID0gcGFyc2VkUGFja2FnZVsnZmVzbTIwMTUnXTtcblxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXJzZWRQYWNrYWdlLCBudWxsLCAyKTtcbiAgfVxuXG4gIC8vIGUuZy4gQGFuZ3VsYXIvY29tbW9uL2h0dHAvdGVzdGluZyAtPiAuLi8uLi9idW5kbGVzL2NvbW1vbi1odHRwLXRlc3RpbmcudW1kLmpzXG4gIC8vIG9yICAgQGFuZ3VsYXIvY29tbW9uL2h0dHAvdGVzdGluZyAtPiAuLi8uLi9mZXNtNS9odHRwL3Rlc3RpbmcuanNcbiAgZnVuY3Rpb24gZ2V0QnVuZGxlTmFtZShwYWNrYWdlTmFtZTogc3RyaW5nLCBkaXI6IHN0cmluZykge1xuICAgIGNvbnN0IHBhcnRzID0gcGFja2FnZU5hbWUuc3BsaXQoJy8nKTtcbiAgICAvLyBSZW1vdmUgdGhlIHNjb3BlZCBwYWNrYWdlIHBhcnQsIGxpa2UgQGFuZ3VsYXIgaWYgcHJlc2VudFxuICAgIGNvbnN0IG5hbWVQYXJ0cyA9IHBhY2thZ2VOYW1lLnN0YXJ0c1dpdGgoJ0AnKSA/IHBhcnRzLnNwbGljZSgxKSA6IHBhcnRzO1xuICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IG5ld0FycmF5KG5hbWVQYXJ0cy5sZW5ndGggLSAxLCAnLi4nKS5qb2luKCcvJykgfHwgJy4nO1xuICAgIGxldCBiYXNlbmFtZTogc3RyaW5nO1xuICAgIGlmIChkaXIgPT09ICdidW5kbGVzJykge1xuICAgICAgYmFzZW5hbWUgPSBuYW1lUGFydHMuam9pbignLScpICsgJy51bWQnO1xuICAgIH0gZWxzZSBpZiAobmFtZVBhcnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgYmFzZW5hbWUgPSBuYW1lUGFydHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2VuYW1lID0gbmFtZVBhcnRzLnNsaWNlKDEpLmpvaW4oJy8nKTtcbiAgICB9XG4gICAgcmV0dXJuIFtyZWxhdGl2ZVBhdGgsIGRpciwgYmFzZW5hbWUgKyAnLmpzJ10uam9pbignLycpO1xuICB9XG5cbiAgLyoqIENyZWF0ZXMgbWV0YWRhdGEgcmUtZXhwb3J0IGZpbGUgZm9yIGEgc2Vjb25kYXJ5IGVudHJ5LXBvaW50LiAqL1xuICBmdW5jdGlvbiBjcmVhdGVNZXRhZGF0YVJlZXhwb3J0RmlsZShcbiAgICAgIGVudHJ5UG9pbnROYW1lOiBzdHJpbmcsIG1ldGFkYXRhRmlsZTogc3RyaW5nLCBwYWNrYWdlTmFtZTogc3RyaW5nKSB7XG4gICAgY29uc3QgaW5wdXRQYXRoID0gcGF0aC5qb2luKHNyY0RpciwgYCR7ZW50cnlQb2ludE5hbWV9Lm1ldGFkYXRhLmpzb25gKTtcbiAgICB3cml0ZUZpbGVGcm9tSW5wdXRQYXRoKGlucHV0UGF0aCwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgJ19fc3ltYm9saWMnOiAnbW9kdWxlJyxcbiAgICAgICd2ZXJzaW9uJzogMyxcbiAgICAgICdtZXRhZGF0YSc6IHt9LFxuICAgICAgJ2V4cG9ydHMnOlxuICAgICAgICAgIFt7J2Zyb20nOiBgJHtzcmNEaXJSZWxhdGl2ZShpbnB1dFBhdGgsIG1ldGFkYXRhRmlsZS5yZXBsYWNlKC8ubWV0YWRhdGEuanNvbiQvLCAnJykpfWB9XSxcbiAgICAgICdmbGF0TW9kdWxlSW5kZXhSZWRpcmVjdCc6IHRydWUsXG4gICAgICAnaW1wb3J0QXMnOiBwYWNrYWdlTmFtZVxuICAgIH0pICsgJ1xcbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB0eXBpbmdzIChkLnRzKSByZS1leHBvcnQgZmlsZSBmb3IgYSBzZWNvbmRhcnktZW50cnkgcG9pbnQsXG4gICAqIGUuZy4sIGBleHBvcnQgKiBmcm9tICcuL2NvbW1vbi9jb21tb24nYFxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlVHlwaW5nc1JlZXhwb3J0RmlsZShlbnRyeVBvaW50TmFtZTogc3RyaW5nLCBsaWNlbnNlOiBzdHJpbmcsIHR5cGluZ3NGaWxlOiBzdHJpbmcpIHtcbiAgICBjb25zdCBpbnB1dFBhdGggPSBwYXRoLmpvaW4oc3JjRGlyLCBgJHtlbnRyeVBvaW50TmFtZX0uZC50c2ApO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBgJHtsaWNlbnNlfVxuZXhwb3J0ICogZnJvbSAnJHtzcmNEaXJSZWxhdGl2ZShpbnB1dFBhdGgsIHR5cGluZ3NGaWxlLnJlcGxhY2UoL1xcLmRcXC50c3g/JC8sICcnKSl9JztcbmA7XG4gICAgd3JpdGVGaWxlRnJvbUlucHV0UGF0aChpbnB1dFBhdGgsIGNvbnRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBwYWNrYWdlLmpzb24gZm9yIGEgc2Vjb25kYXJ5IGVudHJ5LXBvaW50LlxuICAgKiBAcGFyYW0gZGlyIFRoZSBkaXJlY3RvcnkgdW5kZXIgd2hpY2ggdGhlIHBhY2thZ2UuanNvbiBzaG91bGQgYmUgd3JpdHRlbi5cbiAgICogQHBhcmFtIGVudHJ5UG9pbnRQYWNrYWdlTmFtZSBUaGUgZnVsbCBwYWNrYWdlIG5hbWUgZm9yIHRoZSBlbnRyeSBwb2ludCxcbiAgICogICAgIGUuZy4gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJy5cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudHJ5UG9pbnRQYWNrYWdlSnNvbihkaXI6IHN0cmluZywgZW50cnlQb2ludFBhY2thZ2VOYW1lOiBzdHJpbmcpIHtcbiAgICBjb25zdCBwa2dKc29uID0gcGF0aC5qb2luKHNyY0RpciwgZGlyLCAncGFja2FnZS5qc29uJyk7XG4gICAgY29uc3QgY29udGVudCA9IGFtZW5kUGFja2FnZUpzb24ocGtnSnNvbiwge25hbWU6IGVudHJ5UG9pbnRQYWNrYWdlTmFtZX0sIHRydWUpO1xuICAgIHdyaXRlRmlsZUZyb21JbnB1dFBhdGgocGtnSnNvbiwgY29udGVudCk7XG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplcyB0aGUgc3BlY2lmaWVkIHBhdGggYnkgcmVwbGFjaW5nIGJhY2tzbGFzaCBzZXBhcmF0b3JzIHdpdGggUG9zaXhcbiAgICogZm9yd2FyZCBzbGFzaCBzZXBhcmF0b3JzLlxuICAgKi9cbiAgZnVuY3Rpb24gbm9ybWFsaXplU2VwYXJhdG9ycyhwYXRoOiBzdHJpbmcpOiBzdHJpbmcgeyByZXR1cm4gcGF0aC5yZXBsYWNlKC9cXFxcL2csICcvJyk7IH1cblxuICAvKipcbiAgKiBSZXdpcmVzIG1ldGFkYXRhIHRvIHBvaW50IHRvIHRoZSBmbGF0dGVuZWQgZHRzIGZpbGUuXG4gICpcbiAgKiBAcGFyYW0gbWV0YWRhdGFQYXRoIHRoZSBtZXRhZGF0YSBmaWxlIHBhdGhcbiAgKiBAcGFyYW0gdHlwaW5nc1BhdGggdGhlIHR5cGluZ3MgYnVuZGxlIGVudHJ5cG9pbnRcbiAgKi9cbiAgZnVuY3Rpb24gcmV3aXJlTWV0YWRhdGEobWV0YWRhdGFQYXRoOiBzdHJpbmcsIHR5cGluZ3NQYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IG1ldGFkYXRhID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMobWV0YWRhdGFQYXRoLCAndXRmLTgnKSk7XG5cbiAgICBsZXQgdHlwaW5nc1JlbGF0aXZlUGF0aCA9XG4gICAgICAgIG5vcm1hbGl6ZVNlcGFyYXRvcnMocGF0aC5yZWxhdGl2ZShwYXRoLmRpcm5hbWUobWV0YWRhdGFQYXRoKSwgdHlwaW5nc1BhdGgpKTtcbiAgICBpZiAoIXR5cGluZ3NSZWxhdGl2ZVBhdGguc3RhcnRzV2l0aCgnLi4nKSkge1xuICAgICAgdHlwaW5nc1JlbGF0aXZlUGF0aCA9IGAuLyR7dHlwaW5nc1JlbGF0aXZlUGF0aH1gO1xuICAgIH1cblxuICAgIHR5cGluZ3NSZWxhdGl2ZVBhdGggPSB0eXBpbmdzUmVsYXRpdmVQYXRoLnJlcGxhY2UoJy5kLnRzJywgJycpO1xuXG4gICAgLy8gdGhlIHJlZ2V4cCBoZXJlIGNhdGNoZXMgYWxsIHJlbGF0aXZlIHBhdGhzIHN1Y2ggYXM6XG4gICAgLy8gLi9zcmMvY29yZS9mb28uZC50cyBhbmQgLi4vc3JjL2NvcmUvZm9vLmQudHNcbiAgICBjb25zdCByZWxhdGl2ZVBhdGhSZWdleCA9IC9cXC4/XFwuXFwvW1xcd1xcLlxcLV9cXC9dKy9nO1xuICAgIGlmIChtZXRhZGF0YS5leHBvcnRzKSB7XG4gICAgICAvLyBTdHJpcCByZS1leHBvcnRzIHdoaWNoIGFyZSBub3cgc2VsZi1yZWZlcmVuY2VzXG4gICAgICBtZXRhZGF0YS5leHBvcnRzID1cbiAgICAgICAgICBtZXRhZGF0YS5leHBvcnRzLmZpbHRlcigoZToge2Zyb206IHN0cmluZ30pID0+ICFlLmZyb20ubWF0Y2gocmVsYXRpdmVQYXRoUmVnZXgpKTtcbiAgICB9XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKS5yZXBsYWNlKHJlbGF0aXZlUGF0aFJlZ2V4LCB0eXBpbmdzUmVsYXRpdmVQYXRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdHJpcCB0aGUgbmFtZWQgQU1EIG1vZHVsZSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1iYXplbCB1c2VycyBmcm9tIHR5cGluZ3MgY29udGVudFxuICAgKiBAcGFyYW0gZmlsZVBhdGggZHRzIGZpbGUgcGF0aFxuICAgKi9cbiAgZnVuY3Rpb24gcmVhZFR5cGluZ3NBbmRTdHJpcEFtZE1vZHVsZShmaWxlUGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gZnNcbiAgICAgICAgLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgJ3V0Zi04JylcbiAgICAgICAgLy8gU3RyaXAgdGhlIG5hbWVkIEFNRCBtb2R1bGUgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24tYmF6ZWwgdXNlcnNcbiAgICAgICAgLnJlcGxhY2UoL15cXC9cXC9cXC8gPGFtZC1tb2R1bGUgbmFtZT0uKlxcLz5bXFxyXFxuXSsvZ20sICcnKTtcbiAgfVxufVxuXG5pZiAocmVxdWlyZS5tYWluID09PSBtb2R1bGUpIHtcbiAgcHJvY2Vzcy5leGl0Q29kZSA9IG1haW4ocHJvY2Vzcy5hcmd2LnNsaWNlKDIpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5ld0FycmF5PFQgPSBhbnk+KHNpemU6IG51bWJlcik6IFRbXTtcbmV4cG9ydCBmdW5jdGlvbiBuZXdBcnJheTxUPihzaXplOiBudW1iZXIsIHZhbHVlOiBUKTogVFtdO1xuZXhwb3J0IGZ1bmN0aW9uIG5ld0FycmF5PFQ+KHNpemU6IG51bWJlciwgdmFsdWU/OiBUKTogVFtdIHtcbiAgY29uc3QgbGlzdDogVFtdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgbGlzdC5wdXNoKHZhbHVlICEpO1xuICB9XG4gIHJldHVybiBsaXN0O1xufVxuIl19