/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("npm_angular_bazel/src/ng_package/packager", ["require", "exports", "fs", "path", "shelljs"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.newArray = void 0;
    const fs = require("fs");
    const path = require("path");
    const shx = require("shelljs");
    function main(args) {
        // Exit immediately when encountering an error.
        shx.set('-e');
        // Keep track of whether an error has occured so that we can return an appropriate exit code.
        let errorHasOccured = false;
        // This utility expects all of its arguments to be specified in a params file generated by
        // bazel (see https://docs.bazel.build/versions/master/skylark/lib/Args.html#use_param_file).
        const paramFilePath = args[0];
        // Bazel params may be surrounded with quotes
        function unquoteParameter(s) {
            return s.replace(/^'(.*)'$/, '$1');
        }
        // Parameters are specified in the file one per line.
        const params = fs.readFileSync(paramFilePath, 'utf-8').split('\n').map(unquoteParameter);
        const [
        // Output directory for the npm package.
        out, 
        // The package segment of the ng_package rule's label (e.g. 'package/common').
        srcDir, 
        // The bazel-bin dir joined with the srcDir (e.g. 'bazel-bin/package.common').
        // This is the intended output location for package artifacts.
        binDir, 
        // The bazel-genfiles dir joined with the srcDir (e.g. 'bazel-bin/package.common').
        genfilesDir, 
        // JSON data mapping each entry point to the generated bundle index and
        // flat module metadata, for example
        // {"@angular/core": {
        //     "index": "bazel-bin/packages/core/core.js",
        //     "typings": "bazel-bin/packages/core/core.d.ts",
        //     "metadata": "bazel-bin/packages/core/core.metadata.json"
        //  },
        // ...
        // }
        modulesManifestArg, 
        // Path to the package's README.md.
        readmeMd, 
        // List of rolled-up flat ES2015 modules
        fesm2015Arg, 
        // List of rolled-up flat ES5 modules
        fesm5Arg, 
        // List of individual ES2015 modules
        esm2015Arg, 
        // List of individual ES5 modules
        esm5Arg, 
        // List of all UMD bundles generated by rollup.
        bundlesArg, 
        // List of all files in the ng_package rule's srcs.
        srcsArg, 
        // List of all type definitions that need to packaged into the ng_package.
        typeDefinitionsArg, 
        // List of all files in the ng_package rule's data.
        dataArg, 
        // Path to the package's LICENSE.
        licenseFile, 
        // List of all dts bundles generated by the API extractor.
        dtsBundleArg, 
        // The dts bundle file suffix example: '.bundle.d.ts'
        dtsBundleFileSuffix,] = params;
        const fesm2015 = fesm2015Arg.split(',').filter(s => !!s);
        const fesm5 = fesm5Arg.split(',').filter(s => !!s);
        const esm2015 = esm2015Arg.split(',').filter(s => !!s);
        const esm5 = esm5Arg.split(',').filter(s => !!s);
        const bundles = bundlesArg.split(',').filter(s => !!s);
        const typeDefinitions = typeDefinitionsArg.split(',').filter(s => !!s);
        const srcs = srcsArg.split(',').filter(s => !!s);
        const dataFiles = dataArg.split(',').filter(s => !!s);
        const modulesManifest = JSON.parse(modulesManifestArg);
        const dtsBundles = dtsBundleArg.split(',').filter(s => !!s);
        /**
         * List of known `package.json` fields which provide information about
         * supported package formats and their associated entry paths.
         */
        const knownFormatPackageJsonFields = ['main', 'fesm2015', 'esm2015', 'typings', 'module', 'es2015'];
        if (readmeMd) {
            copyFile(readmeMd, out);
        }
        /**
         * Writes a file into the package based on its input path, relativizing to the package path.
         * @param inputPath Path to the file in the input tree.
         * @param fileContent Content of the file.
         */
        function writeFileFromInputPath(inputPath, fileContent) {
            // We want the relative path from the given file to its ancestor "root" directory.
            // This root depends on whether the file lives in the source tree (srcDir) as a basic file
            // input to ng_package, the bin output tree (binDir) as the output of another rule, or
            // the genfiles output tree (genfilesDir) as the output of a genrule.
            let rootDir;
            if (inputPath.includes(binDir)) {
                rootDir = binDir;
            }
            else if (inputPath.includes(genfilesDir)) {
                rootDir = genfilesDir;
            }
            else {
                rootDir = srcDir;
            }
            const outputPath = path.join(out, path.relative(rootDir, inputPath));
            // Always ensure that the target directory exists.
            shx.mkdir('-p', path.dirname(outputPath));
            fs.writeFileSync(outputPath, fileContent);
        }
        /**
         * Copies a file into the package based on its input path, relativizing to the package path.
         * @param inputPath a path relative to the binDir, typically from a file in the deps[]
         */
        function copyFileFromInputPath(inputPath) {
            writeFileFromInputPath(inputPath, fs.readFileSync(inputPath));
        }
        /**
         * Relativize the path where a file is written.
         * @param file a path containing a re-rooted segment like .esm5
         * @param suffix the re-rooted directory
         * @param outDir path where we copy the file, relative to the out
         */
        function writeEsmFile(file, suffix, outDir) {
            function relPath(file, suffix) {
                if (suffix) {
                    // Note that the specified file path is always using the posix path delimiter.
                    const root = suffix ? file.substr(0, file.lastIndexOf(`${suffix}/`) + suffix.length + 1) : binDir;
                    return path.dirname(path.relative(path.join(root, srcDir), file));
                }
                else {
                    return path.dirname(path.relative(binDir, file));
                }
            }
            const rel = relPath(file, suffix);
            if (!rel.startsWith('..')) {
                copyFile(file, path.join(out, outDir), rel);
            }
        }
        esm2015.forEach(file => writeEsmFile(file, '', 'esm2015'));
        bundles.forEach(bundle => {
            copyFile(bundle, out, 'bundles');
        });
        fesm2015.forEach(file => {
            copyFile(file, out, 'fesm2015');
        });
        // Copy all type definitions into the package. This is necessary so that developers can use
        // the package with type definitions.
        typeDefinitions.forEach(f => writeFileFromInputPath(f, readTypingsAndStripAmdModule(f)));
        // Copy all `data` files into the package. These are files that aren't built by the ng_package
        // rule, but instead are just straight copied into the package, e.g. global CSS assets.
        dataFiles.forEach(f => copyFileFromInputPath(f));
        // Iterate through the entry point modules
        // We do this first because we also record new paths for the esm5 and esm2015 copies
        // of the index JS file, which we need to amend the package.json.
        Object.keys(modulesManifest).forEach(moduleName => {
            const moduleFiles = modulesManifest[moduleName];
            const relative = path.relative(binDir, moduleFiles['index']);
            moduleFiles['esm5_index'] = path.join(binDir, 'esm5', relative);
            moduleFiles['esm2015_index'] = path.join(binDir, 'esm2015', relative);
            // Metadata file is optional as entry-points can be also built
            // with the "ts_library" rule.
            const metadataFile = moduleFiles['metadata'];
            if (!metadataFile) {
                return;
            }
            const typingsOutFile = moduleFiles['typings'];
            // We only support all modules within a package to be dts bundled
            // ie: if @angular/common/http has flat dts, so should @angular/common
            if (dtsBundles.length) {
                const metadataContent = rewireMetadata(metadataFile, typingsOutFile);
                writeFileFromInputPath(metadataFile, metadataContent);
            }
            else {
                copyFileFromInputPath(metadataFile);
            }
        });
        const licenseBanner = licenseFile ? fs.readFileSync(licenseFile, 'utf-8') : '';
        dtsBundles.forEach(bundleFile => {
            const cleanDistPath = bundleFile.replace(dtsBundleFileSuffix, '.d.ts');
            // API extractor will not dedupe license comments from various files
            // this will remove all the license comments and append the license banner.
            const content = licenseBanner + '\n' +
                readTypingsAndStripAmdModule(bundleFile)
                    .replace(/(\/\*\*\s+\*\s\@license(((?!\*\/).|\s)*)\*\/)/gm, '');
            writeFileFromInputPath(cleanDistPath, content);
        });
        // Root package name (e.g. '@angular/common'), captures as we iterate through sources below.
        let rootPackageName = '';
        const packagesWithExistingPackageJson = new Set();
        for (const src of srcs) {
            if (src.includes(binDir) || src.includes(genfilesDir)) {
                errorHasOccured = true;
                console.error('The "srcs" for ng_package should not include output of other rules. Found:\n' +
                    `  ${src}`);
            }
            let content = fs.readFileSync(src, 'utf-8');
            // Modify package.json files as necessary for publishing
            if (path.basename(src) === 'package.json') {
                const packageJson = JSON.parse(content);
                content = amendPackageJson(src, packageJson, false);
                const packageName = packageJson['name'];
                packagesWithExistingPackageJson.add(packageName);
                // Keep track of the root package name, e.g. "@angular/common". We assume that the
                // root name will be shortest because secondary entry-points will append to it
                // (e.g. "@angular/common/http").
                if (!rootPackageName || packageName.length < rootPackageName.length) {
                    rootPackageName = packageJson['name'];
                }
            }
            writeFileFromInputPath(src, content);
        }
        // Generate extra files for secondary entry-points.
        Object.keys(modulesManifest).forEach(entryPointPackageName => {
            const entryPointName = entryPointPackageName.substr(rootPackageName.length + 1);
            if (!entryPointName)
                return;
            const metadataFilePath = modulesManifest[entryPointPackageName]['metadata'];
            if (metadataFilePath) {
                createMetadataReexportFile(entryPointName, modulesManifest[entryPointPackageName]['metadata'], entryPointPackageName);
            }
            createTypingsReexportFile(entryPointName, licenseBanner, modulesManifest[entryPointPackageName]['typings']);
            if (!packagesWithExistingPackageJson.has(entryPointPackageName)) {
                createEntryPointPackageJson(entryPointName, entryPointPackageName);
            }
        });
        return errorHasOccured ? 1 : 0;
        /**
         * Convert a binDir-relative path to srcDir-relative
         * @param from path to a file under the srcDir, like packages/core/testing/package.json
         * @param file path to a file under the binDir, like bazel-bin/core/testing/generated.js
         */
        function srcDirRelative(from, file) {
            const result = normalizeSeparators(path.relative(path.dirname(from), path.join(srcDir, path.relative(binDir, file))));
            if (result.startsWith('..'))
                return result;
            return `./${result}`;
        }
        function copyFile(file, baseDir, relative = '.') {
            const dir = path.join(baseDir, relative);
            // output file is .js if the input file is .mjs
            const outFile = path.posix.join(dir, path.basename(file.endsWith('.mjs') ? file.replace(/\.mjs$/, '.js') : file));
            shx.mkdir('-p', dir);
            shx.cp(file, outFile);
            // Double-underscore is used to escape forward slash in FESM filenames.
            // See ng_package.bzl:
            //   fesm_output_filename = entry_point.replace("/", "__")
            // We need to unescape these.
            if (outFile.indexOf('__') >= 0) {
                const outputPath = path.join(dir, ...path.basename(outFile).split('__'));
                shx.mkdir('-p', path.dirname(outputPath));
                shx.mv(path.join(dir, path.basename(file)), outputPath);
                // if we are renaming the .js file, we'll also need to update the sourceMappingURL in the file
                if (outFile.endsWith('.js')) {
                    shx.chmod('+w', outputPath);
                    shx.sed('-i', `${path.basename(file)}.map`, `${path.basename(outputPath)}.map`, outputPath);
                }
            }
        }
        /**
         * Inserts or edits properties into the package.json file(s) in the package so that
         * they point to all the right generated artifacts.
         *
         * @param packageJson The path to the package.json file.
         * @param parsedPackage Parsed package.json content
         * @param isGeneratedPackageJson Whether the passed package.json has been generated.
         */
        function amendPackageJson(packageJson, parsedPackage, isGeneratedPackageJson) {
            const packageName = parsedPackage['name'];
            const moduleData = modulesManifest[packageName];
            // If a package json file has been discovered that does not match any
            // module in the manifest, we report a warning as most likely the target
            // is configured incorrectly (e.g. missing `module_name` attribute).
            if (!moduleData) {
                // Ideally we should throw here, as we got an entry point that doesn't
                // have flat module metadata / bundle index, so it may have been an
                // ng_module that's missing a module_name attribute.
                // However, @angular/compiler can't be an ng_module, as it's the internals
                // of the ngc compiler, yet we want to build an ng_package for it.
                // So ignore package.json files when we are missing data.
                console.error('WARNING: no module metadata for package', packageName);
                console.error('   Not updating the package.json file to point to it');
                console.error('   The ng_module for this package is possibly missing the module_name attribute ');
                return JSON.stringify(parsedPackage, null, 2);
            }
            // If we guessed the index paths for a module, and it contains an explicit `package.json`
            // file that already sets format properties, we skip automatic insertion of format
            // properties but report a warning in case properties have been set by accident.
            if (moduleData.guessedPaths && !isGeneratedPackageJson &&
                hasExplicitFormatProperties(parsedPackage)) {
                console.error('WARNING: `package.json` explicitly sets format properties (like `main`).');
                console.error('    Skipping automatic insertion of format properties as explicit ' +
                    'format properties are set.');
                console.error('    Ignore this warning if explicit properties are set intentionally.');
                return JSON.stringify(parsedPackage, null, 2);
            }
            // Derive the paths to the files from the hard-coded names we gave them.
            // TODO(alexeagle): it would be better to transfer this information from the place
            // where we created the filenames, via the modulesManifestArg
            parsedPackage['main'] = getBundleName(packageName, 'bundles');
            parsedPackage['fesm2015'] = getBundleName(packageName, 'fesm2015');
            parsedPackage['esm2015'] = srcDirRelative(packageJson, moduleData['esm2015_index']);
            parsedPackage['typings'] = srcDirRelative(packageJson, moduleData['typings']);
            // For now, we point the primary entry points at the fesm files, because of Webpack
            // performance issues with a large number of individual files.
            parsedPackage['module'] = parsedPackage['fesm2015'];
            parsedPackage['es2015'] = parsedPackage['fesm2015'];
            return JSON.stringify(parsedPackage, null, 2);
        }
        // e.g. @angular/common/http/testing -> ../../bundles/common-http-testing.umd.js
        // or   @angular/common/http/testing -> ../../fesm5/http/testing.js
        function getBundleName(packageName, dir) {
            const parts = packageName.split('/');
            // Remove the scoped package part, like @angular if present
            const nameParts = packageName.startsWith('@') ? parts.splice(1) : parts;
            const relativePath = newArray(nameParts.length - 1, '..').join('/') || '.';
            let basename;
            if (dir === 'bundles') {
                basename = nameParts.join('-') + '.umd';
            }
            else if (nameParts.length === 1) {
                basename = nameParts[0];
            }
            else {
                basename = nameParts.slice(1).join('/');
            }
            return [relativePath, dir, basename + '.js'].join('/');
        }
        /** Whether the package explicitly sets any of the format properties (like `main`). */
        function hasExplicitFormatProperties(parsedPackage) {
            return Object.keys(parsedPackage)
                .some(propertyName => knownFormatPackageJsonFields.includes(propertyName));
        }
        /** Creates metadata re-export file for a secondary entry-point. */
        function createMetadataReexportFile(entryPointName, metadataFile, packageName) {
            const inputPath = path.join(srcDir, `${entryPointName}.metadata.json`);
            writeFileFromInputPath(inputPath, JSON.stringify({
                '__symbolic': 'module',
                'version': 3,
                'metadata': {},
                'exports': [{ 'from': `${srcDirRelative(inputPath, metadataFile.replace(/.metadata.json$/, ''))}` }],
                'flatModuleIndexRedirect': true,
                'importAs': packageName
            }) + '\n');
        }
        /**
         * Creates a typings (d.ts) re-export file for a secondary-entry point,
         * e.g., `export * from './common/common'`
         */
        function createTypingsReexportFile(entryPointName, license, typingsFile) {
            const inputPath = path.join(srcDir, `${entryPointName}.d.ts`);
            const content = `${license}
export * from '${srcDirRelative(inputPath, typingsFile.replace(/\.d\.tsx?$/, ''))}';
`;
            writeFileFromInputPath(inputPath, content);
        }
        /**
         * Creates a package.json for a secondary entry-point.
         * @param dir The directory under which the package.json should be written.
         * @param entryPointPackageName The full package name for the entry point,
         *     e.g. '@angular/common/http'.
         */
        function createEntryPointPackageJson(dir, entryPointPackageName) {
            const pkgJson = path.join(srcDir, dir, 'package.json');
            const content = amendPackageJson(pkgJson, { name: entryPointPackageName }, true);
            writeFileFromInputPath(pkgJson, content);
        }
        /**
         * Normalizes the specified path by replacing backslash separators with Posix
         * forward slash separators.
         */
        function normalizeSeparators(path) {
            return path.replace(/\\/g, '/');
        }
        /**
         * Rewires metadata to point to the flattened dts file.
         *
         * @param metadataPath the metadata file path
         * @param typingsPath the typings bundle entrypoint
         */
        function rewireMetadata(metadataPath, typingsPath) {
            const metadata = JSON.parse(fs.readFileSync(metadataPath, 'utf-8'));
            let typingsRelativePath = normalizeSeparators(path.relative(path.dirname(metadataPath), typingsPath));
            if (!typingsRelativePath.startsWith('..')) {
                typingsRelativePath = `./${typingsRelativePath}`;
            }
            typingsRelativePath = typingsRelativePath.replace('.d.ts', '');
            // the regexp here catches all relative paths such as:
            // ./src/core/foo.d.ts and ../src/core/foo.d.ts
            const relativePathRegex = /\.?\.\/[\w\.\-_\/]+/g;
            if (metadata.exports) {
                // Strip re-exports which are now self-references
                metadata.exports =
                    metadata.exports.filter((e) => !e.from.match(relativePathRegex));
            }
            return JSON.stringify(metadata).replace(relativePathRegex, typingsRelativePath);
        }
        /**
         * Strip the named AMD module for compatibility with non-bazel users from typings content
         * @param filePath dts file path
         */
        function readTypingsAndStripAmdModule(filePath) {
            return fs
                .readFileSync(filePath, 'utf-8')
                // Strip the named AMD module for compatibility with non-bazel users
                .replace(/^\/\/\/ <amd-module name=.*\/>[\r\n]+/gm, '');
        }
    }
    if (require.main === module) {
        process.exitCode = main(process.argv.slice(2));
    }
    function newArray(size, value) {
        const list = [];
        for (let i = 0; i < size; i++) {
            list.push(value);
        }
        return list;
    }
    exports.newArray = newArray;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFja2FnZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9iYXplbC9zcmMvbmdfcGFja2FnZS9wYWNrYWdlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7Ozs7Ozs7Ozs7Ozs7SUFFSCx5QkFBeUI7SUFDekIsNkJBQTZCO0lBQzdCLCtCQUErQjtJQUUvQixTQUFTLElBQUksQ0FBQyxJQUFjO1FBQzFCLCtDQUErQztRQUMvQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRWQsNkZBQTZGO1FBQzdGLElBQUksZUFBZSxHQUFHLEtBQUssQ0FBQztRQUU1QiwwRkFBMEY7UUFDMUYsNkZBQTZGO1FBQzdGLE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUU5Qiw2Q0FBNkM7UUFDN0MsU0FBUyxnQkFBZ0IsQ0FBQyxDQUFTO1lBQ2pDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDckMsQ0FBQztRQUVELHFEQUFxRDtRQUNyRCxNQUFNLE1BQU0sR0FBRyxFQUFFLENBQUMsWUFBWSxDQUFDLGFBQWEsRUFBRSxPQUFPLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFFekYsTUFBTTtRQUNGLHdDQUF3QztRQUN4QyxHQUFHO1FBRUgsOEVBQThFO1FBQzlFLE1BQU07UUFFTiw4RUFBOEU7UUFDOUUsOERBQThEO1FBQzlELE1BQU07UUFFTixtRkFBbUY7UUFDbkYsV0FBVztRQUVYLHVFQUF1RTtRQUN2RSxvQ0FBb0M7UUFDcEMsc0JBQXNCO1FBQ3RCLGtEQUFrRDtRQUNsRCxzREFBc0Q7UUFDdEQsK0RBQStEO1FBQy9ELE1BQU07UUFDTixNQUFNO1FBQ04sSUFBSTtRQUNKLGtCQUFrQjtRQUVsQixtQ0FBbUM7UUFD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T0FBTztvQkFDWixRQUFRLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQWlCLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDO2FBQ3RGO1lBQ0QsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxpQkFBaUIsRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO1FBQ2xGLENBQUM7UUFFRDs7O1dBR0c7UUFDSCxTQUFTLDRCQUE0QixDQUFDLFFBQWdCO1lBQ3BELE9BQU8sRUFBRTtpQkFDSixZQUFZLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQztnQkFDaEMsb0VBQW9FO2lCQUNuRSxPQUFPLENBQUMseUNBQXlDLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDOUQsQ0FBQztJQUNILENBQUM7SUFFRCxJQUFJLE9BQU8sQ0FBQyxJQUFJLEtBQUssTUFBTSxFQUFFO1FBQzNCLE9BQU8sQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDaEQ7SUFJRCxTQUFnQixRQUFRLENBQUksSUFBWSxFQUFFLEtBQVM7UUFDakQsTUFBTSxJQUFJLEdBQVEsRUFBRSxDQUFDO1FBQ3JCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDN0IsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFNLENBQUMsQ0FBQztTQUNuQjtRQUNELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQU5ELDRCQU1DIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyBzaHggZnJvbSAnc2hlbGxqcyc7XG5cbmZ1bmN0aW9uIG1haW4oYXJnczogc3RyaW5nW10pOiBudW1iZXIge1xuICAvLyBFeGl0IGltbWVkaWF0ZWx5IHdoZW4gZW5jb3VudGVyaW5nIGFuIGVycm9yLlxuICBzaHguc2V0KCctZScpO1xuXG4gIC8vIEtlZXAgdHJhY2sgb2Ygd2hldGhlciBhbiBlcnJvciBoYXMgb2NjdXJlZCBzbyB0aGF0IHdlIGNhbiByZXR1cm4gYW4gYXBwcm9wcmlhdGUgZXhpdCBjb2RlLlxuICBsZXQgZXJyb3JIYXNPY2N1cmVkID0gZmFsc2U7XG5cbiAgLy8gVGhpcyB1dGlsaXR5IGV4cGVjdHMgYWxsIG9mIGl0cyBhcmd1bWVudHMgdG8gYmUgc3BlY2lmaWVkIGluIGEgcGFyYW1zIGZpbGUgZ2VuZXJhdGVkIGJ5XG4gIC8vIGJhemVsIChzZWUgaHR0cHM6Ly9kb2NzLmJhemVsLmJ1aWxkL3ZlcnNpb25zL21hc3Rlci9za3lsYXJrL2xpYi9BcmdzLmh0bWwjdXNlX3BhcmFtX2ZpbGUpLlxuICBjb25zdCBwYXJhbUZpbGVQYXRoID0gYXJnc1swXTtcblxuICAvLyBCYXplbCBwYXJhbXMgbWF5IGJlIHN1cnJvdW5kZWQgd2l0aCBxdW90ZXNcbiAgZnVuY3Rpb24gdW5xdW90ZVBhcmFtZXRlcihzOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKC9eJyguKiknJC8sICckMScpO1xuICB9XG5cbiAgLy8gUGFyYW1ldGVycyBhcmUgc3BlY2lmaWVkIGluIHRoZSBmaWxlIG9uZSBwZXIgbGluZS5cbiAgY29uc3QgcGFyYW1zID0gZnMucmVhZEZpbGVTeW5jKHBhcmFtRmlsZVBhdGgsICd1dGYtOCcpLnNwbGl0KCdcXG4nKS5tYXAodW5xdW90ZVBhcmFtZXRlcik7XG5cbiAgY29uc3QgW1xuICAgICAgLy8gT3V0cHV0IGRpcmVjdG9yeSBmb3IgdGhlIG5wbSBwYWNrYWdlLlxuICAgICAgb3V0LFxuXG4gICAgICAvLyBUaGUgcGFja2FnZSBzZWdtZW50IG9mIHRoZSBuZ19wYWNrYWdlIHJ1bGUncyBsYWJlbCAoZS5nLiAncGFja2FnZS9jb21tb24nKS5cbiAgICAgIHNyY0RpcixcblxuICAgICAgLy8gVGhlIGJhemVsLWJpbiBkaXIgam9pbmVkIHdpdGggdGhlIHNyY0RpciAoZS5nLiAnYmF6ZWwtYmluL3BhY2thZ2UuY29tbW9uJykuXG4gICAgICAvLyBUaGlzIGlzIHRoZSBpbnRlbmRlZCBvdXRwdXQgbG9jYXRpb24gZm9yIHBhY2thZ2UgYXJ0aWZhY3RzLlxuICAgICAgYmluRGlyLFxuXG4gICAgICAvLyBUaGUgYmF6ZWwtZ2VuZmlsZXMgZGlyIGpvaW5lZCB3aXRoIHRoZSBzcmNEaXIgKGUuZy4gJ2JhemVsLWJpbi9wYWNrYWdlLmNvbW1vbicpLlxuICAgICAgZ2VuZmlsZXNEaXIsXG5cbiAgICAgIC8vIEpTT04gZGF0YSBtYXBwaW5nIGVhY2ggZW50cnkgcG9pbnQgdG8gdGhlIGdlbmVyYXRlZCBidW5kbGUgaW5kZXggYW5kXG4gICAgICAvLyBmbGF0IG1vZHVsZSBtZXRhZGF0YSwgZm9yIGV4YW1wbGVcbiAgICAgIC8vIHtcIkBhbmd1bGFyL2NvcmVcIjoge1xuICAgICAgLy8gICAgIFwiaW5kZXhcIjogXCJiYXplbC1iaW4vcGFja2FnZXMvY29yZS9jb3JlLmpzXCIsXG4gICAgICAvLyAgICAgXCJ0eXBpbmdzXCI6IFwiYmF6ZWwtYmluL3BhY2thZ2VzL2NvcmUvY29yZS5kLnRzXCIsXG4gICAgICAvLyAgICAgXCJtZXRhZGF0YVwiOiBcImJhemVsLWJpbi9wYWNrYWdlcy9jb3JlL2NvcmUubWV0YWRhdGEuanNvblwiXG4gICAgICAvLyAgfSxcbiAgICAgIC8vIC4uLlxuICAgICAgLy8gfVxuICAgICAgbW9kdWxlc01hbmlmZXN0QXJnLFxuXG4gICAgICAvLyBQYXRoIHRvIHRoZSBwYWNrYWdlJ3MgUkVBRE1FLm1kLlxuICAgICAgcmVhZG1lTWQsXG5cbiAgICAgIC8vIExpc3Qgb2Ygcm9sbGVkLXVwIGZsYXQgRVMyMDE1IG1vZHVsZXNcbiAgICAgIGZlc20yMDE1QXJnLFxuXG4gICAgICAvLyBMaXN0IG9mIHJvbGxlZC11cCBmbGF0IEVTNSBtb2R1bGVzXG4gICAgICBmZXNtNUFyZyxcblxuICAgICAgLy8gTGlzdCBvZiBpbmRpdmlkdWFsIEVTMjAxNSBtb2R1bGVzXG4gICAgICBlc20yMDE1QXJnLFxuXG4gICAgICAvLyBMaXN0IG9mIGluZGl2aWR1YWwgRVM1IG1vZHVsZXNcbiAgICAgIGVzbTVBcmcsXG5cbiAgICAgIC8vIExpc3Qgb2YgYWxsIFVNRCBidW5kbGVzIGdlbmVyYXRlZCBieSByb2xsdXAuXG4gICAgICBidW5kbGVzQXJnLFxuXG4gICAgICAvLyBMaXN0IG9mIGFsbCBmaWxlcyBpbiB0aGUgbmdfcGFja2FnZSBydWxlJ3Mgc3Jjcy5cbiAgICAgIHNyY3NBcmcsXG5cbiAgICAgIC8vIExpc3Qgb2YgYWxsIHR5cGUgZGVmaW5pdGlvbnMgdGhhdCBuZWVkIHRvIHBhY2thZ2VkIGludG8gdGhlIG5nX3BhY2thZ2UuXG4gICAgICB0eXBlRGVmaW5pdGlvbnNBcmcsXG5cbiAgICAgIC8vIExpc3Qgb2YgYWxsIGZpbGVzIGluIHRoZSBuZ19wYWNrYWdlIHJ1bGUncyBkYXRhLlxuICAgICAgZGF0YUFyZyxcblxuICAgICAgLy8gUGF0aCB0byB0aGUgcGFja2FnZSdzIExJQ0VOU0UuXG4gICAgICBsaWNlbnNlRmlsZSxcblxuICAgICAgLy8gTGlzdCBvZiBhbGwgZHRzIGJ1bmRsZXMgZ2VuZXJhdGVkIGJ5IHRoZSBBUEkgZXh0cmFjdG9yLlxuICAgICAgZHRzQnVuZGxlQXJnLFxuXG4gICAgICAvLyBUaGUgZHRzIGJ1bmRsZSBmaWxlIHN1ZmZpeCBleGFtcGxlOiAnLmJ1bmRsZS5kLnRzJ1xuICAgICAgZHRzQnVuZGxlRmlsZVN1ZmZpeCxcbiAgXSA9IHBhcmFtcztcblxuICBjb25zdCBmZXNtMjAxNSA9IGZlc20yMDE1QXJnLnNwbGl0KCcsJykuZmlsdGVyKHMgPT4gISFzKTtcbiAgY29uc3QgZmVzbTUgPSBmZXNtNUFyZy5zcGxpdCgnLCcpLmZpbHRlcihzID0+ICEhcyk7XG4gIGNvbnN0IGVzbTIwMTUgPSBlc20yMDE1QXJnLnNwbGl0KCcsJykuZmlsdGVyKHMgPT4gISFzKTtcbiAgY29uc3QgZXNtNSA9IGVzbTVBcmcuc3BsaXQoJywnKS5maWx0ZXIocyA9PiAhIXMpO1xuICBjb25zdCBidW5kbGVzID0gYnVuZGxlc0FyZy5zcGxpdCgnLCcpLmZpbHRlcihzID0+ICEhcyk7XG4gIGNvbnN0IHR5cGVEZWZpbml0aW9ucyA9IHR5cGVEZWZpbml0aW9uc0FyZy5zcGxpdCgnLCcpLmZpbHRlcihzID0+ICEhcyk7XG4gIGNvbnN0IHNyY3MgPSBzcmNzQXJnLnNwbGl0KCcsJykuZmlsdGVyKHMgPT4gISFzKTtcbiAgY29uc3QgZGF0YUZpbGVzOiBzdHJpbmdbXSA9IGRhdGFBcmcuc3BsaXQoJywnKS5maWx0ZXIocyA9PiAhIXMpO1xuICBjb25zdCBtb2R1bGVzTWFuaWZlc3QgPSBKU09OLnBhcnNlKG1vZHVsZXNNYW5pZmVzdEFyZyk7XG4gIGNvbnN0IGR0c0J1bmRsZXM6IHN0cmluZ1tdID0gZHRzQnVuZGxlQXJnLnNwbGl0KCcsJykuZmlsdGVyKHMgPT4gISFzKTtcblxuICAvKipcbiAgICogTGlzdCBvZiBrbm93biBgcGFja2FnZS5qc29uYCBmaWVsZHMgd2hpY2ggcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dFxuICAgKiBzdXBwb3J0ZWQgcGFja2FnZSBmb3JtYXRzIGFuZCB0aGVpciBhc3NvY2lhdGVkIGVudHJ5IHBhdGhzLlxuICAgKi9cbiAgY29uc3Qga25vd25Gb3JtYXRQYWNrYWdlSnNvbkZpZWxkcyA9XG4gICAgICBbJ21haW4nLCAnZmVzbTIwMTUnLCAnZXNtMjAxNScsICd0eXBpbmdzJywgJ21vZHVsZScsICdlczIwMTUnXTtcblxuICBpZiAocmVhZG1lTWQpIHtcbiAgICBjb3B5RmlsZShyZWFkbWVNZCwgb3V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZXMgYSBmaWxlIGludG8gdGhlIHBhY2thZ2UgYmFzZWQgb24gaXRzIGlucHV0IHBhdGgsIHJlbGF0aXZpemluZyB0byB0aGUgcGFja2FnZSBwYXRoLlxuICAgKiBAcGFyYW0gaW5wdXRQYXRoIFBhdGggdG8gdGhlIGZpbGUgaW4gdGhlIGlucHV0IHRyZWUuXG4gICAqIEBwYXJhbSBmaWxlQ29udGVudCBDb250ZW50IG9mIHRoZSBmaWxlLlxuICAgKi9cbiAgZnVuY3Rpb24gd3JpdGVGaWxlRnJvbUlucHV0UGF0aChpbnB1dFBhdGg6IHN0cmluZywgZmlsZUNvbnRlbnQ6IHN0cmluZ3xCdWZmZXIpIHtcbiAgICAvLyBXZSB3YW50IHRoZSByZWxhdGl2ZSBwYXRoIGZyb20gdGhlIGdpdmVuIGZpbGUgdG8gaXRzIGFuY2VzdG9yIFwicm9vdFwiIGRpcmVjdG9yeS5cbiAgICAvLyBUaGlzIHJvb3QgZGVwZW5kcyBvbiB3aGV0aGVyIHRoZSBmaWxlIGxpdmVzIGluIHRoZSBzb3VyY2UgdHJlZSAoc3JjRGlyKSBhcyBhIGJhc2ljIGZpbGVcbiAgICAvLyBpbnB1dCB0byBuZ19wYWNrYWdlLCB0aGUgYmluIG91dHB1dCB0cmVlIChiaW5EaXIpIGFzIHRoZSBvdXRwdXQgb2YgYW5vdGhlciBydWxlLCBvclxuICAgIC8vIHRoZSBnZW5maWxlcyBvdXRwdXQgdHJlZSAoZ2VuZmlsZXNEaXIpIGFzIHRoZSBvdXRwdXQgb2YgYSBnZW5ydWxlLlxuICAgIGxldCByb290RGlyOiBzdHJpbmc7XG4gICAgaWYgKGlucHV0UGF0aC5pbmNsdWRlcyhiaW5EaXIpKSB7XG4gICAgICByb290RGlyID0gYmluRGlyO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRQYXRoLmluY2x1ZGVzKGdlbmZpbGVzRGlyKSkge1xuICAgICAgcm9vdERpciA9IGdlbmZpbGVzRGlyO1xuICAgIH0gZWxzZSB7XG4gICAgICByb290RGlyID0gc3JjRGlyO1xuICAgIH1cblxuICAgIGNvbnN0IG91dHB1dFBhdGggPSBwYXRoLmpvaW4ob3V0LCBwYXRoLnJlbGF0aXZlKHJvb3REaXIsIGlucHV0UGF0aCkpO1xuXG4gICAgLy8gQWx3YXlzIGVuc3VyZSB0aGF0IHRoZSB0YXJnZXQgZGlyZWN0b3J5IGV4aXN0cy5cbiAgICBzaHgubWtkaXIoJy1wJywgcGF0aC5kaXJuYW1lKG91dHB1dFBhdGgpKTtcbiAgICBmcy53cml0ZUZpbGVTeW5jKG91dHB1dFBhdGgsIGZpbGVDb250ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3BpZXMgYSBmaWxlIGludG8gdGhlIHBhY2thZ2UgYmFzZWQgb24gaXRzIGlucHV0IHBhdGgsIHJlbGF0aXZpemluZyB0byB0aGUgcGFja2FnZSBwYXRoLlxuICAgKiBAcGFyYW0gaW5wdXRQYXRoIGEgcGF0aCByZWxhdGl2ZSB0byB0aGUgYmluRGlyLCB0eXBpY2FsbHkgZnJvbSBhIGZpbGUgaW4gdGhlIGRlcHNbXVxuICAgKi9cbiAgZnVuY3Rpb24gY29weUZpbGVGcm9tSW5wdXRQYXRoKGlucHV0UGF0aDogc3RyaW5nKSB7XG4gICAgd3JpdGVGaWxlRnJvbUlucHV0UGF0aChpbnB1dFBhdGgsIGZzLnJlYWRGaWxlU3luYyhpbnB1dFBhdGgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxhdGl2aXplIHRoZSBwYXRoIHdoZXJlIGEgZmlsZSBpcyB3cml0dGVuLlxuICAgKiBAcGFyYW0gZmlsZSBhIHBhdGggY29udGFpbmluZyBhIHJlLXJvb3RlZCBzZWdtZW50IGxpa2UgLmVzbTVcbiAgICogQHBhcmFtIHN1ZmZpeCB0aGUgcmUtcm9vdGVkIGRpcmVjdG9yeVxuICAgKiBAcGFyYW0gb3V0RGlyIHBhdGggd2hlcmUgd2UgY29weSB0aGUgZmlsZSwgcmVsYXRpdmUgdG8gdGhlIG91dFxuICAgKi9cbiAgZnVuY3Rpb24gd3JpdGVFc21GaWxlKGZpbGU6IHN0cmluZywgc3VmZml4OiBzdHJpbmcsIG91dERpcjogc3RyaW5nKSB7XG4gICAgZnVuY3Rpb24gcmVsUGF0aChmaWxlOiBzdHJpbmcsIHN1ZmZpeDogc3RyaW5nKSB7XG4gICAgICBpZiAoc3VmZml4KSB7XG4gICAgICAgIC8vIE5vdGUgdGhhdCB0aGUgc3BlY2lmaWVkIGZpbGUgcGF0aCBpcyBhbHdheXMgdXNpbmcgdGhlIHBvc2l4IHBhdGggZGVsaW1pdGVyLlxuICAgICAgICBjb25zdCByb290ID1cbiAgICAgICAgICAgIHN1ZmZpeCA/IGZpbGUuc3Vic3RyKDAsIGZpbGUubGFzdEluZGV4T2YoYCR7c3VmZml4fS9gKSArIHN1ZmZpeC5sZW5ndGggKyAxKSA6IGJpbkRpcjtcbiAgICAgICAgcmV0dXJuIHBhdGguZGlybmFtZShwYXRoLnJlbGF0aXZlKHBhdGguam9pbihyb290LCBzcmNEaXIpLCBmaWxlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcGF0aC5kaXJuYW1lKHBhdGgucmVsYXRpdmUoYmluRGlyLCBmaWxlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlbCA9IHJlbFBhdGgoZmlsZSwgc3VmZml4KTtcbiAgICBpZiAoIXJlbC5zdGFydHNXaXRoKCcuLicpKSB7XG4gICAgICBjb3B5RmlsZShmaWxlLCBwYXRoLmpvaW4ob3V0LCBvdXREaXIpLCByZWwpO1xuICAgIH1cbiAgfVxuXG4gIGVzbTIwMTUuZm9yRWFjaChmaWxlID0+IHdyaXRlRXNtRmlsZShmaWxlLCAnJywgJ2VzbTIwMTUnKSk7XG5cbiAgYnVuZGxlcy5mb3JFYWNoKGJ1bmRsZSA9PiB7XG4gICAgY29weUZpbGUoYnVuZGxlLCBvdXQsICdidW5kbGVzJyk7XG4gIH0pO1xuICBmZXNtMjAxNS5mb3JFYWNoKGZpbGUgPT4ge1xuICAgIGNvcHlGaWxlKGZpbGUsIG91dCwgJ2Zlc20yMDE1Jyk7XG4gIH0pO1xuXG4gIC8vIENvcHkgYWxsIHR5cGUgZGVmaW5pdGlvbnMgaW50byB0aGUgcGFja2FnZS4gVGhpcyBpcyBuZWNlc3Nhcnkgc28gdGhhdCBkZXZlbG9wZXJzIGNhbiB1c2VcbiAgLy8gdGhlIHBhY2thZ2Ugd2l0aCB0eXBlIGRlZmluaXRpb25zLlxuICB0eXBlRGVmaW5pdGlvbnMuZm9yRWFjaChmID0+IHdyaXRlRmlsZUZyb21JbnB1dFBhdGgoZiwgcmVhZFR5cGluZ3NBbmRTdHJpcEFtZE1vZHVsZShmKSkpO1xuXG4gIC8vIENvcHkgYWxsIGBkYXRhYCBmaWxlcyBpbnRvIHRoZSBwYWNrYWdlLiBUaGVzZSBhcmUgZmlsZXMgdGhhdCBhcmVuJ3QgYnVpbHQgYnkgdGhlIG5nX3BhY2thZ2VcbiAgLy8gcnVsZSwgYnV0IGluc3RlYWQgYXJlIGp1c3Qgc3RyYWlnaHQgY29waWVkIGludG8gdGhlIHBhY2thZ2UsIGUuZy4gZ2xvYmFsIENTUyBhc3NldHMuXG4gIGRhdGFGaWxlcy5mb3JFYWNoKGYgPT4gY29weUZpbGVGcm9tSW5wdXRQYXRoKGYpKTtcblxuICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIGVudHJ5IHBvaW50IG1vZHVsZXNcbiAgLy8gV2UgZG8gdGhpcyBmaXJzdCBiZWNhdXNlIHdlIGFsc28gcmVjb3JkIG5ldyBwYXRocyBmb3IgdGhlIGVzbTUgYW5kIGVzbTIwMTUgY29waWVzXG4gIC8vIG9mIHRoZSBpbmRleCBKUyBmaWxlLCB3aGljaCB3ZSBuZWVkIHRvIGFtZW5kIHRoZSBwYWNrYWdlLmpzb24uXG4gIE9iamVjdC5rZXlzKG1vZHVsZXNNYW5pZmVzdCkuZm9yRWFjaChtb2R1bGVOYW1lID0+IHtcbiAgICBjb25zdCBtb2R1bGVGaWxlcyA9IG1vZHVsZXNNYW5pZmVzdFttb2R1bGVOYW1lXTtcbiAgICBjb25zdCByZWxhdGl2ZSA9IHBhdGgucmVsYXRpdmUoYmluRGlyLCBtb2R1bGVGaWxlc1snaW5kZXgnXSk7XG5cbiAgICBtb2R1bGVGaWxlc1snZXNtNV9pbmRleCddID0gcGF0aC5qb2luKGJpbkRpciwgJ2VzbTUnLCByZWxhdGl2ZSk7XG4gICAgbW9kdWxlRmlsZXNbJ2VzbTIwMTVfaW5kZXgnXSA9IHBhdGguam9pbihiaW5EaXIsICdlc20yMDE1JywgcmVsYXRpdmUpO1xuXG4gICAgLy8gTWV0YWRhdGEgZmlsZSBpcyBvcHRpb25hbCBhcyBlbnRyeS1wb2ludHMgY2FuIGJlIGFsc28gYnVpbHRcbiAgICAvLyB3aXRoIHRoZSBcInRzX2xpYnJhcnlcIiBydWxlLlxuICAgIGNvbnN0IG1ldGFkYXRhRmlsZSA9IG1vZHVsZUZpbGVzWydtZXRhZGF0YSddO1xuICAgIGlmICghbWV0YWRhdGFGaWxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdHlwaW5nc091dEZpbGUgPSBtb2R1bGVGaWxlc1sndHlwaW5ncyddO1xuICAgIC8vIFdlIG9ubHkgc3VwcG9ydCBhbGwgbW9kdWxlcyB3aXRoaW4gYSBwYWNrYWdlIHRvIGJlIGR0cyBidW5kbGVkXG4gICAgLy8gaWU6IGlmIEBhbmd1bGFyL2NvbW1vbi9odHRwIGhhcyBmbGF0IGR0cywgc28gc2hvdWxkIEBhbmd1bGFyL2NvbW1vblxuICAgIGlmIChkdHNCdW5kbGVzLmxlbmd0aCkge1xuICAgICAgY29uc3QgbWV0YWRhdGFDb250ZW50ID0gcmV3aXJlTWV0YWRhdGEobWV0YWRhdGFGaWxlLCB0eXBpbmdzT3V0RmlsZSk7XG4gICAgICB3cml0ZUZpbGVGcm9tSW5wdXRQYXRoKG1ldGFkYXRhRmlsZSwgbWV0YWRhdGFDb250ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29weUZpbGVGcm9tSW5wdXRQYXRoKG1ldGFkYXRhRmlsZSk7XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBsaWNlbnNlQmFubmVyID0gbGljZW5zZUZpbGUgPyBmcy5yZWFkRmlsZVN5bmMobGljZW5zZUZpbGUsICd1dGYtOCcpIDogJyc7XG5cbiAgZHRzQnVuZGxlcy5mb3JFYWNoKGJ1bmRsZUZpbGUgPT4ge1xuICAgIGNvbnN0IGNsZWFuRGlzdFBhdGggPSBidW5kbGVGaWxlLnJlcGxhY2UoZHRzQnVuZGxlRmlsZVN1ZmZpeCwgJy5kLnRzJyk7XG4gICAgLy8gQVBJIGV4dHJhY3RvciB3aWxsIG5vdCBkZWR1cGUgbGljZW5zZSBjb21tZW50cyBmcm9tIHZhcmlvdXMgZmlsZXNcbiAgICAvLyB0aGlzIHdpbGwgcmVtb3ZlIGFsbCB0aGUgbGljZW5zZSBjb21tZW50cyBhbmQgYXBwZW5kIHRoZSBsaWNlbnNlIGJhbm5lci5cbiAgICBjb25zdCBjb250ZW50ID0gbGljZW5zZUJhbm5lciArICdcXG4nICtcbiAgICAgICAgcmVhZFR5cGluZ3NBbmRTdHJpcEFtZE1vZHVsZShidW5kbGVGaWxlKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyhcXC9cXCpcXCpcXHMrXFwqXFxzXFxAbGljZW5zZSgoKD8hXFwqXFwvKS58XFxzKSopXFwqXFwvKS9nbSwgJycpO1xuXG4gICAgd3JpdGVGaWxlRnJvbUlucHV0UGF0aChjbGVhbkRpc3RQYXRoLCBjb250ZW50KTtcbiAgfSk7XG5cbiAgLy8gUm9vdCBwYWNrYWdlIG5hbWUgKGUuZy4gJ0Bhbmd1bGFyL2NvbW1vbicpLCBjYXB0dXJlcyBhcyB3ZSBpdGVyYXRlIHRocm91Z2ggc291cmNlcyBiZWxvdy5cbiAgbGV0IHJvb3RQYWNrYWdlTmFtZSA9ICcnO1xuICBjb25zdCBwYWNrYWdlc1dpdGhFeGlzdGluZ1BhY2thZ2VKc29uID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgZm9yIChjb25zdCBzcmMgb2Ygc3Jjcykge1xuICAgIGlmIChzcmMuaW5jbHVkZXMoYmluRGlyKSB8fCBzcmMuaW5jbHVkZXMoZ2VuZmlsZXNEaXIpKSB7XG4gICAgICBlcnJvckhhc09jY3VyZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAnVGhlIFwic3Jjc1wiIGZvciBuZ19wYWNrYWdlIHNob3VsZCBub3QgaW5jbHVkZSBvdXRwdXQgb2Ygb3RoZXIgcnVsZXMuIEZvdW5kOlxcbicgK1xuICAgICAgICAgIGAgICR7c3JjfWApO1xuICAgIH1cblxuICAgIGxldCBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKHNyYywgJ3V0Zi04Jyk7XG4gICAgLy8gTW9kaWZ5IHBhY2thZ2UuanNvbiBmaWxlcyBhcyBuZWNlc3NhcnkgZm9yIHB1Ymxpc2hpbmdcbiAgICBpZiAocGF0aC5iYXNlbmFtZShzcmMpID09PSAncGFja2FnZS5qc29uJykge1xuICAgICAgY29uc3QgcGFja2FnZUpzb24gPSBKU09OLnBhcnNlKGNvbnRlbnQpO1xuICAgICAgY29udGVudCA9IGFtZW5kUGFja2FnZUpzb24oc3JjLCBwYWNrYWdlSnNvbiwgZmFsc2UpO1xuXG4gICAgICBjb25zdCBwYWNrYWdlTmFtZSA9IHBhY2thZ2VKc29uWyduYW1lJ107XG4gICAgICBwYWNrYWdlc1dpdGhFeGlzdGluZ1BhY2thZ2VKc29uLmFkZChwYWNrYWdlTmFtZSk7XG5cbiAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIHJvb3QgcGFja2FnZSBuYW1lLCBlLmcuIFwiQGFuZ3VsYXIvY29tbW9uXCIuIFdlIGFzc3VtZSB0aGF0IHRoZVxuICAgICAgLy8gcm9vdCBuYW1lIHdpbGwgYmUgc2hvcnRlc3QgYmVjYXVzZSBzZWNvbmRhcnkgZW50cnktcG9pbnRzIHdpbGwgYXBwZW5kIHRvIGl0XG4gICAgICAvLyAoZS5nLiBcIkBhbmd1bGFyL2NvbW1vbi9odHRwXCIpLlxuICAgICAgaWYgKCFyb290UGFja2FnZU5hbWUgfHwgcGFja2FnZU5hbWUubGVuZ3RoIDwgcm9vdFBhY2thZ2VOYW1lLmxlbmd0aCkge1xuICAgICAgICByb290UGFja2FnZU5hbWUgPSBwYWNrYWdlSnNvblsnbmFtZSddO1xuICAgICAgfVxuICAgIH1cbiAgICB3cml0ZUZpbGVGcm9tSW5wdXRQYXRoKHNyYywgY29udGVudCk7XG4gIH1cblxuICAvLyBHZW5lcmF0ZSBleHRyYSBmaWxlcyBmb3Igc2Vjb25kYXJ5IGVudHJ5LXBvaW50cy5cbiAgT2JqZWN0LmtleXMobW9kdWxlc01hbmlmZXN0KS5mb3JFYWNoKGVudHJ5UG9pbnRQYWNrYWdlTmFtZSA9PiB7XG4gICAgY29uc3QgZW50cnlQb2ludE5hbWUgPSBlbnRyeVBvaW50UGFja2FnZU5hbWUuc3Vic3RyKHJvb3RQYWNrYWdlTmFtZS5sZW5ndGggKyAxKTtcbiAgICBpZiAoIWVudHJ5UG9pbnROYW1lKSByZXR1cm47XG5cbiAgICBjb25zdCBtZXRhZGF0YUZpbGVQYXRoID0gbW9kdWxlc01hbmlmZXN0W2VudHJ5UG9pbnRQYWNrYWdlTmFtZV1bJ21ldGFkYXRhJ107XG4gICAgaWYgKG1ldGFkYXRhRmlsZVBhdGgpIHtcbiAgICAgIGNyZWF0ZU1ldGFkYXRhUmVleHBvcnRGaWxlKFxuICAgICAgICAgIGVudHJ5UG9pbnROYW1lLCBtb2R1bGVzTWFuaWZlc3RbZW50cnlQb2ludFBhY2thZ2VOYW1lXVsnbWV0YWRhdGEnXSxcbiAgICAgICAgICBlbnRyeVBvaW50UGFja2FnZU5hbWUpO1xuICAgIH1cblxuICAgIGNyZWF0ZVR5cGluZ3NSZWV4cG9ydEZpbGUoXG4gICAgICAgIGVudHJ5UG9pbnROYW1lLCBsaWNlbnNlQmFubmVyLCBtb2R1bGVzTWFuaWZlc3RbZW50cnlQb2ludFBhY2thZ2VOYW1lXVsndHlwaW5ncyddKTtcblxuICAgIGlmICghcGFja2FnZXNXaXRoRXhpc3RpbmdQYWNrYWdlSnNvbi5oYXMoZW50cnlQb2ludFBhY2thZ2VOYW1lKSkge1xuICAgICAgY3JlYXRlRW50cnlQb2ludFBhY2thZ2VKc29uKGVudHJ5UG9pbnROYW1lLCBlbnRyeVBvaW50UGFja2FnZU5hbWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGVycm9ySGFzT2NjdXJlZCA/IDEgOiAwO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgYmluRGlyLXJlbGF0aXZlIHBhdGggdG8gc3JjRGlyLXJlbGF0aXZlXG4gICAqIEBwYXJhbSBmcm9tIHBhdGggdG8gYSBmaWxlIHVuZGVyIHRoZSBzcmNEaXIsIGxpa2UgcGFja2FnZXMvY29yZS90ZXN0aW5nL3BhY2thZ2UuanNvblxuICAgKiBAcGFyYW0gZmlsZSBwYXRoIHRvIGEgZmlsZSB1bmRlciB0aGUgYmluRGlyLCBsaWtlIGJhemVsLWJpbi9jb3JlL3Rlc3RpbmcvZ2VuZXJhdGVkLmpzXG4gICAqL1xuICBmdW5jdGlvbiBzcmNEaXJSZWxhdGl2ZShmcm9tOiBzdHJpbmcsIGZpbGU6IHN0cmluZykge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5vcm1hbGl6ZVNlcGFyYXRvcnMoXG4gICAgICAgIHBhdGgucmVsYXRpdmUocGF0aC5kaXJuYW1lKGZyb20pLCBwYXRoLmpvaW4oc3JjRGlyLCBwYXRoLnJlbGF0aXZlKGJpbkRpciwgZmlsZSkpKSk7XG4gICAgaWYgKHJlc3VsdC5zdGFydHNXaXRoKCcuLicpKSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiBgLi8ke3Jlc3VsdH1gO1xuICB9XG5cbiAgZnVuY3Rpb24gY29weUZpbGUoZmlsZTogc3RyaW5nLCBiYXNlRGlyOiBzdHJpbmcsIHJlbGF0aXZlID0gJy4nKSB7XG4gICAgY29uc3QgZGlyID0gcGF0aC5qb2luKGJhc2VEaXIsIHJlbGF0aXZlKTtcbiAgICAvLyBvdXRwdXQgZmlsZSBpcyAuanMgaWYgdGhlIGlucHV0IGZpbGUgaXMgLm1qc1xuICAgIGNvbnN0IG91dEZpbGUgPSBwYXRoLnBvc2l4LmpvaW4oXG4gICAgICAgIGRpciwgcGF0aC5iYXNlbmFtZShmaWxlLmVuZHNXaXRoKCcubWpzJykgPyBmaWxlLnJlcGxhY2UoL1xcLm1qcyQvLCAnLmpzJykgOiBmaWxlKSk7XG4gICAgc2h4Lm1rZGlyKCctcCcsIGRpcik7XG4gICAgc2h4LmNwKGZpbGUsIG91dEZpbGUpO1xuICAgIC8vIERvdWJsZS11bmRlcnNjb3JlIGlzIHVzZWQgdG8gZXNjYXBlIGZvcndhcmQgc2xhc2ggaW4gRkVTTSBmaWxlbmFtZXMuXG4gICAgLy8gU2VlIG5nX3BhY2thZ2UuYnpsOlxuICAgIC8vICAgZmVzbV9vdXRwdXRfZmlsZW5hbWUgPSBlbnRyeV9wb2ludC5yZXBsYWNlKFwiL1wiLCBcIl9fXCIpXG4gICAgLy8gV2UgbmVlZCB0byB1bmVzY2FwZSB0aGVzZS5cbiAgICBpZiAob3V0RmlsZS5pbmRleE9mKCdfXycpID49IDApIHtcbiAgICAgIGNvbnN0IG91dHB1dFBhdGggPSBwYXRoLmpvaW4oZGlyLCAuLi5wYXRoLmJhc2VuYW1lKG91dEZpbGUpLnNwbGl0KCdfXycpKTtcbiAgICAgIHNoeC5ta2RpcignLXAnLCBwYXRoLmRpcm5hbWUob3V0cHV0UGF0aCkpO1xuICAgICAgc2h4Lm12KHBhdGguam9pbihkaXIsIHBhdGguYmFzZW5hbWUoZmlsZSkpLCBvdXRwdXRQYXRoKTtcblxuICAgICAgLy8gaWYgd2UgYXJlIHJlbmFtaW5nIHRoZSAuanMgZmlsZSwgd2UnbGwgYWxzbyBuZWVkIHRvIHVwZGF0ZSB0aGUgc291cmNlTWFwcGluZ1VSTCBpbiB0aGUgZmlsZVxuICAgICAgaWYgKG91dEZpbGUuZW5kc1dpdGgoJy5qcycpKSB7XG4gICAgICAgIHNoeC5jaG1vZCgnK3cnLCBvdXRwdXRQYXRoKTtcbiAgICAgICAgc2h4LnNlZCgnLWknLCBgJHtwYXRoLmJhc2VuYW1lKGZpbGUpfS5tYXBgLCBgJHtwYXRoLmJhc2VuYW1lKG91dHB1dFBhdGgpfS5tYXBgLCBvdXRwdXRQYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0cyBvciBlZGl0cyBwcm9wZXJ0aWVzIGludG8gdGhlIHBhY2thZ2UuanNvbiBmaWxlKHMpIGluIHRoZSBwYWNrYWdlIHNvIHRoYXRcbiAgICogdGhleSBwb2ludCB0byBhbGwgdGhlIHJpZ2h0IGdlbmVyYXRlZCBhcnRpZmFjdHMuXG4gICAqXG4gICAqIEBwYXJhbSBwYWNrYWdlSnNvbiBUaGUgcGF0aCB0byB0aGUgcGFja2FnZS5qc29uIGZpbGUuXG4gICAqIEBwYXJhbSBwYXJzZWRQYWNrYWdlIFBhcnNlZCBwYWNrYWdlLmpzb24gY29udGVudFxuICAgKiBAcGFyYW0gaXNHZW5lcmF0ZWRQYWNrYWdlSnNvbiBXaGV0aGVyIHRoZSBwYXNzZWQgcGFja2FnZS5qc29uIGhhcyBiZWVuIGdlbmVyYXRlZC5cbiAgICovXG4gIGZ1bmN0aW9uIGFtZW5kUGFja2FnZUpzb24oXG4gICAgICBwYWNrYWdlSnNvbjogc3RyaW5nLCBwYXJzZWRQYWNrYWdlOiB7W2tleTogc3RyaW5nXTogc3RyaW5nfSxcbiAgICAgIGlzR2VuZXJhdGVkUGFja2FnZUpzb246IGJvb2xlYW4pIHtcbiAgICBjb25zdCBwYWNrYWdlTmFtZSA9IHBhcnNlZFBhY2thZ2VbJ25hbWUnXTtcbiAgICBjb25zdCBtb2R1bGVEYXRhID0gbW9kdWxlc01hbmlmZXN0W3BhY2thZ2VOYW1lXTtcblxuICAgIC8vIElmIGEgcGFja2FnZSBqc29uIGZpbGUgaGFzIGJlZW4gZGlzY292ZXJlZCB0aGF0IGRvZXMgbm90IG1hdGNoIGFueVxuICAgIC8vIG1vZHVsZSBpbiB0aGUgbWFuaWZlc3QsIHdlIHJlcG9ydCBhIHdhcm5pbmcgYXMgbW9zdCBsaWtlbHkgdGhlIHRhcmdldFxuICAgIC8vIGlzIGNvbmZpZ3VyZWQgaW5jb3JyZWN0bHkgKGUuZy4gbWlzc2luZyBgbW9kdWxlX25hbWVgIGF0dHJpYnV0ZSkuXG4gICAgaWYgKCFtb2R1bGVEYXRhKSB7XG4gICAgICAvLyBJZGVhbGx5IHdlIHNob3VsZCB0aHJvdyBoZXJlLCBhcyB3ZSBnb3QgYW4gZW50cnkgcG9pbnQgdGhhdCBkb2Vzbid0XG4gICAgICAvLyBoYXZlIGZsYXQgbW9kdWxlIG1ldGFkYXRhIC8gYnVuZGxlIGluZGV4LCBzbyBpdCBtYXkgaGF2ZSBiZWVuIGFuXG4gICAgICAvLyBuZ19tb2R1bGUgdGhhdCdzIG1pc3NpbmcgYSBtb2R1bGVfbmFtZSBhdHRyaWJ1dGUuXG4gICAgICAvLyBIb3dldmVyLCBAYW5ndWxhci9jb21waWxlciBjYW4ndCBiZSBhbiBuZ19tb2R1bGUsIGFzIGl0J3MgdGhlIGludGVybmFsc1xuICAgICAgLy8gb2YgdGhlIG5nYyBjb21waWxlciwgeWV0IHdlIHdhbnQgdG8gYnVpbGQgYW4gbmdfcGFja2FnZSBmb3IgaXQuXG4gICAgICAvLyBTbyBpZ25vcmUgcGFja2FnZS5qc29uIGZpbGVzIHdoZW4gd2UgYXJlIG1pc3NpbmcgZGF0YS5cbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1dBUk5JTkc6IG5vIG1vZHVsZSBtZXRhZGF0YSBmb3IgcGFja2FnZScsIHBhY2thZ2VOYW1lKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyAgIE5vdCB1cGRhdGluZyB0aGUgcGFja2FnZS5qc29uIGZpbGUgdG8gcG9pbnQgdG8gaXQnKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgJyAgIFRoZSBuZ19tb2R1bGUgZm9yIHRoaXMgcGFja2FnZSBpcyBwb3NzaWJseSBtaXNzaW5nIHRoZSBtb2R1bGVfbmFtZSBhdHRyaWJ1dGUgJyk7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGFyc2VkUGFja2FnZSwgbnVsbCwgMik7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZ3Vlc3NlZCB0aGUgaW5kZXggcGF0aHMgZm9yIGEgbW9kdWxlLCBhbmQgaXQgY29udGFpbnMgYW4gZXhwbGljaXQgYHBhY2thZ2UuanNvbmBcbiAgICAvLyBmaWxlIHRoYXQgYWxyZWFkeSBzZXRzIGZvcm1hdCBwcm9wZXJ0aWVzLCB3ZSBza2lwIGF1dG9tYXRpYyBpbnNlcnRpb24gb2YgZm9ybWF0XG4gICAgLy8gcHJvcGVydGllcyBidXQgcmVwb3J0IGEgd2FybmluZyBpbiBjYXNlIHByb3BlcnRpZXMgaGF2ZSBiZWVuIHNldCBieSBhY2NpZGVudC5cbiAgICBpZiAobW9kdWxlRGF0YS5ndWVzc2VkUGF0aHMgJiYgIWlzR2VuZXJhdGVkUGFja2FnZUpzb24gJiZcbiAgICAgICAgaGFzRXhwbGljaXRGb3JtYXRQcm9wZXJ0aWVzKHBhcnNlZFBhY2thZ2UpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdXQVJOSU5HOiBgcGFja2FnZS5qc29uYCBleHBsaWNpdGx5IHNldHMgZm9ybWF0IHByb3BlcnRpZXMgKGxpa2UgYG1haW5gKS4nKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgJyAgICBTa2lwcGluZyBhdXRvbWF0aWMgaW5zZXJ0aW9uIG9mIGZvcm1hdCBwcm9wZXJ0aWVzIGFzIGV4cGxpY2l0ICcgK1xuICAgICAgICAgICdmb3JtYXQgcHJvcGVydGllcyBhcmUgc2V0LicpO1xuICAgICAgY29uc29sZS5lcnJvcignICAgIElnbm9yZSB0aGlzIHdhcm5pbmcgaWYgZXhwbGljaXQgcHJvcGVydGllcyBhcmUgc2V0IGludGVudGlvbmFsbHkuJyk7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGFyc2VkUGFja2FnZSwgbnVsbCwgMik7XG4gICAgfVxuXG4gICAgLy8gRGVyaXZlIHRoZSBwYXRocyB0byB0aGUgZmlsZXMgZnJvbSB0aGUgaGFyZC1jb2RlZCBuYW1lcyB3ZSBnYXZlIHRoZW0uXG4gICAgLy8gVE9ETyhhbGV4ZWFnbGUpOiBpdCB3b3VsZCBiZSBiZXR0ZXIgdG8gdHJhbnNmZXIgdGhpcyBpbmZvcm1hdGlvbiBmcm9tIHRoZSBwbGFjZVxuICAgIC8vIHdoZXJlIHdlIGNyZWF0ZWQgdGhlIGZpbGVuYW1lcywgdmlhIHRoZSBtb2R1bGVzTWFuaWZlc3RBcmdcbiAgICBwYXJzZWRQYWNrYWdlWydtYWluJ10gPSBnZXRCdW5kbGVOYW1lKHBhY2thZ2VOYW1lLCAnYnVuZGxlcycpO1xuICAgIHBhcnNlZFBhY2thZ2VbJ2Zlc20yMDE1J10gPSBnZXRCdW5kbGVOYW1lKHBhY2thZ2VOYW1lLCAnZmVzbTIwMTUnKTtcblxuICAgIHBhcnNlZFBhY2thZ2VbJ2VzbTIwMTUnXSA9IHNyY0RpclJlbGF0aXZlKHBhY2thZ2VKc29uLCBtb2R1bGVEYXRhWydlc20yMDE1X2luZGV4J10pO1xuICAgIHBhcnNlZFBhY2thZ2VbJ3R5cGluZ3MnXSA9IHNyY0RpclJlbGF0aXZlKHBhY2thZ2VKc29uLCBtb2R1bGVEYXRhWyd0eXBpbmdzJ10pO1xuXG4gICAgLy8gRm9yIG5vdywgd2UgcG9pbnQgdGhlIHByaW1hcnkgZW50cnkgcG9pbnRzIGF0IHRoZSBmZXNtIGZpbGVzLCBiZWNhdXNlIG9mIFdlYnBhY2tcbiAgICAvLyBwZXJmb3JtYW5jZSBpc3N1ZXMgd2l0aCBhIGxhcmdlIG51bWJlciBvZiBpbmRpdmlkdWFsIGZpbGVzLlxuICAgIHBhcnNlZFBhY2thZ2VbJ21vZHVsZSddID0gcGFyc2VkUGFja2FnZVsnZmVzbTIwMTUnXTtcbiAgICBwYXJzZWRQYWNrYWdlWydlczIwMTUnXSA9IHBhcnNlZFBhY2thZ2VbJ2Zlc20yMDE1J107XG5cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGFyc2VkUGFja2FnZSwgbnVsbCwgMik7XG4gIH1cblxuICAvLyBlLmcuIEBhbmd1bGFyL2NvbW1vbi9odHRwL3Rlc3RpbmcgLT4gLi4vLi4vYnVuZGxlcy9jb21tb24taHR0cC10ZXN0aW5nLnVtZC5qc1xuICAvLyBvciAgIEBhbmd1bGFyL2NvbW1vbi9odHRwL3Rlc3RpbmcgLT4gLi4vLi4vZmVzbTUvaHR0cC90ZXN0aW5nLmpzXG4gIGZ1bmN0aW9uIGdldEJ1bmRsZU5hbWUocGFja2FnZU5hbWU6IHN0cmluZywgZGlyOiBzdHJpbmcpIHtcbiAgICBjb25zdCBwYXJ0cyA9IHBhY2thZ2VOYW1lLnNwbGl0KCcvJyk7XG4gICAgLy8gUmVtb3ZlIHRoZSBzY29wZWQgcGFja2FnZSBwYXJ0LCBsaWtlIEBhbmd1bGFyIGlmIHByZXNlbnRcbiAgICBjb25zdCBuYW1lUGFydHMgPSBwYWNrYWdlTmFtZS5zdGFydHNXaXRoKCdAJykgPyBwYXJ0cy5zcGxpY2UoMSkgOiBwYXJ0cztcbiAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBuZXdBcnJheShuYW1lUGFydHMubGVuZ3RoIC0gMSwgJy4uJykuam9pbignLycpIHx8ICcuJztcbiAgICBsZXQgYmFzZW5hbWU6IHN0cmluZztcbiAgICBpZiAoZGlyID09PSAnYnVuZGxlcycpIHtcbiAgICAgIGJhc2VuYW1lID0gbmFtZVBhcnRzLmpvaW4oJy0nKSArICcudW1kJztcbiAgICB9IGVsc2UgaWYgKG5hbWVQYXJ0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGJhc2VuYW1lID0gbmFtZVBhcnRzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlbmFtZSA9IG5hbWVQYXJ0cy5zbGljZSgxKS5qb2luKCcvJyk7XG4gICAgfVxuICAgIHJldHVybiBbcmVsYXRpdmVQYXRoLCBkaXIsIGJhc2VuYW1lICsgJy5qcyddLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8qKiBXaGV0aGVyIHRoZSBwYWNrYWdlIGV4cGxpY2l0bHkgc2V0cyBhbnkgb2YgdGhlIGZvcm1hdCBwcm9wZXJ0aWVzIChsaWtlIGBtYWluYCkuICovXG4gIGZ1bmN0aW9uIGhhc0V4cGxpY2l0Rm9ybWF0UHJvcGVydGllcyhwYXJzZWRQYWNrYWdlOiB7W2tleTogc3RyaW5nXTogc3RyaW5nfSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhwYXJzZWRQYWNrYWdlKVxuICAgICAgICAuc29tZShwcm9wZXJ0eU5hbWUgPT4ga25vd25Gb3JtYXRQYWNrYWdlSnNvbkZpZWxkcy5pbmNsdWRlcyhwcm9wZXJ0eU5hbWUpKTtcbiAgfVxuXG4gIC8qKiBDcmVhdGVzIG1ldGFkYXRhIHJlLWV4cG9ydCBmaWxlIGZvciBhIHNlY29uZGFyeSBlbnRyeS1wb2ludC4gKi9cbiAgZnVuY3Rpb24gY3JlYXRlTWV0YWRhdGFSZWV4cG9ydEZpbGUoXG4gICAgICBlbnRyeVBvaW50TmFtZTogc3RyaW5nLCBtZXRhZGF0YUZpbGU6IHN0cmluZywgcGFja2FnZU5hbWU6IHN0cmluZykge1xuICAgIGNvbnN0IGlucHV0UGF0aCA9IHBhdGguam9pbihzcmNEaXIsIGAke2VudHJ5UG9pbnROYW1lfS5tZXRhZGF0YS5qc29uYCk7XG4gICAgd3JpdGVGaWxlRnJvbUlucHV0UGF0aChpbnB1dFBhdGgsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICdfX3N5bWJvbGljJzogJ21vZHVsZScsXG4gICAgICAndmVyc2lvbic6IDMsXG4gICAgICAnbWV0YWRhdGEnOiB7fSxcbiAgICAgICdleHBvcnRzJzpcbiAgICAgICAgICBbeydmcm9tJzogYCR7c3JjRGlyUmVsYXRpdmUoaW5wdXRQYXRoLCBtZXRhZGF0YUZpbGUucmVwbGFjZSgvLm1ldGFkYXRhLmpzb24kLywgJycpKX1gfV0sXG4gICAgICAnZmxhdE1vZHVsZUluZGV4UmVkaXJlY3QnOiB0cnVlLFxuICAgICAgJ2ltcG9ydEFzJzogcGFja2FnZU5hbWVcbiAgICB9KSArICdcXG4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdHlwaW5ncyAoZC50cykgcmUtZXhwb3J0IGZpbGUgZm9yIGEgc2Vjb25kYXJ5LWVudHJ5IHBvaW50LFxuICAgKiBlLmcuLCBgZXhwb3J0ICogZnJvbSAnLi9jb21tb24vY29tbW9uJ2BcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZVR5cGluZ3NSZWV4cG9ydEZpbGUoZW50cnlQb2ludE5hbWU6IHN0cmluZywgbGljZW5zZTogc3RyaW5nLCB0eXBpbmdzRmlsZTogc3RyaW5nKSB7XG4gICAgY29uc3QgaW5wdXRQYXRoID0gcGF0aC5qb2luKHNyY0RpciwgYCR7ZW50cnlQb2ludE5hbWV9LmQudHNgKTtcbiAgICBjb25zdCBjb250ZW50ID0gYCR7bGljZW5zZX1cbmV4cG9ydCAqIGZyb20gJyR7c3JjRGlyUmVsYXRpdmUoaW5wdXRQYXRoLCB0eXBpbmdzRmlsZS5yZXBsYWNlKC9cXC5kXFwudHN4PyQvLCAnJykpfSc7XG5gO1xuICAgIHdyaXRlRmlsZUZyb21JbnB1dFBhdGgoaW5wdXRQYXRoLCBjb250ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcGFja2FnZS5qc29uIGZvciBhIHNlY29uZGFyeSBlbnRyeS1wb2ludC5cbiAgICogQHBhcmFtIGRpciBUaGUgZGlyZWN0b3J5IHVuZGVyIHdoaWNoIHRoZSBwYWNrYWdlLmpzb24gc2hvdWxkIGJlIHdyaXR0ZW4uXG4gICAqIEBwYXJhbSBlbnRyeVBvaW50UGFja2FnZU5hbWUgVGhlIGZ1bGwgcGFja2FnZSBuYW1lIGZvciB0aGUgZW50cnkgcG9pbnQsXG4gICAqICAgICBlLmcuICdAYW5ndWxhci9jb21tb24vaHR0cCcuXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVFbnRyeVBvaW50UGFja2FnZUpzb24oZGlyOiBzdHJpbmcsIGVudHJ5UG9pbnRQYWNrYWdlTmFtZTogc3RyaW5nKSB7XG4gICAgY29uc3QgcGtnSnNvbiA9IHBhdGguam9pbihzcmNEaXIsIGRpciwgJ3BhY2thZ2UuanNvbicpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBhbWVuZFBhY2thZ2VKc29uKHBrZ0pzb24sIHtuYW1lOiBlbnRyeVBvaW50UGFja2FnZU5hbWV9LCB0cnVlKTtcbiAgICB3cml0ZUZpbGVGcm9tSW5wdXRQYXRoKHBrZ0pzb24sIGNvbnRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZXMgdGhlIHNwZWNpZmllZCBwYXRoIGJ5IHJlcGxhY2luZyBiYWNrc2xhc2ggc2VwYXJhdG9ycyB3aXRoIFBvc2l4XG4gICAqIGZvcndhcmQgc2xhc2ggc2VwYXJhdG9ycy5cbiAgICovXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVNlcGFyYXRvcnMocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gcGF0aC5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG4gIH1cblxuICAvKipcbiAgICogUmV3aXJlcyBtZXRhZGF0YSB0byBwb2ludCB0byB0aGUgZmxhdHRlbmVkIGR0cyBmaWxlLlxuICAgKlxuICAgKiBAcGFyYW0gbWV0YWRhdGFQYXRoIHRoZSBtZXRhZGF0YSBmaWxlIHBhdGhcbiAgICogQHBhcmFtIHR5cGluZ3NQYXRoIHRoZSB0eXBpbmdzIGJ1bmRsZSBlbnRyeXBvaW50XG4gICAqL1xuICBmdW5jdGlvbiByZXdpcmVNZXRhZGF0YShtZXRhZGF0YVBhdGg6IHN0cmluZywgdHlwaW5nc1BhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyhtZXRhZGF0YVBhdGgsICd1dGYtOCcpKTtcblxuICAgIGxldCB0eXBpbmdzUmVsYXRpdmVQYXRoID1cbiAgICAgICAgbm9ybWFsaXplU2VwYXJhdG9ycyhwYXRoLnJlbGF0aXZlKHBhdGguZGlybmFtZShtZXRhZGF0YVBhdGgpLCB0eXBpbmdzUGF0aCkpO1xuICAgIGlmICghdHlwaW5nc1JlbGF0aXZlUGF0aC5zdGFydHNXaXRoKCcuLicpKSB7XG4gICAgICB0eXBpbmdzUmVsYXRpdmVQYXRoID0gYC4vJHt0eXBpbmdzUmVsYXRpdmVQYXRofWA7XG4gICAgfVxuXG4gICAgdHlwaW5nc1JlbGF0aXZlUGF0aCA9IHR5cGluZ3NSZWxhdGl2ZVBhdGgucmVwbGFjZSgnLmQudHMnLCAnJyk7XG5cbiAgICAvLyB0aGUgcmVnZXhwIGhlcmUgY2F0Y2hlcyBhbGwgcmVsYXRpdmUgcGF0aHMgc3VjaCBhczpcbiAgICAvLyAuL3NyYy9jb3JlL2Zvby5kLnRzIGFuZCAuLi9zcmMvY29yZS9mb28uZC50c1xuICAgIGNvbnN0IHJlbGF0aXZlUGF0aFJlZ2V4ID0gL1xcLj9cXC5cXC9bXFx3XFwuXFwtX1xcL10rL2c7XG4gICAgaWYgKG1ldGFkYXRhLmV4cG9ydHMpIHtcbiAgICAgIC8vIFN0cmlwIHJlLWV4cG9ydHMgd2hpY2ggYXJlIG5vdyBzZWxmLXJlZmVyZW5jZXNcbiAgICAgIG1ldGFkYXRhLmV4cG9ydHMgPVxuICAgICAgICAgIG1ldGFkYXRhLmV4cG9ydHMuZmlsdGVyKChlOiB7ZnJvbTogc3RyaW5nfSkgPT4gIWUuZnJvbS5tYXRjaChyZWxhdGl2ZVBhdGhSZWdleCkpO1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpLnJlcGxhY2UocmVsYXRpdmVQYXRoUmVnZXgsIHR5cGluZ3NSZWxhdGl2ZVBhdGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0cmlwIHRoZSBuYW1lZCBBTUQgbW9kdWxlIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWJhemVsIHVzZXJzIGZyb20gdHlwaW5ncyBjb250ZW50XG4gICAqIEBwYXJhbSBmaWxlUGF0aCBkdHMgZmlsZSBwYXRoXG4gICAqL1xuICBmdW5jdGlvbiByZWFkVHlwaW5nc0FuZFN0cmlwQW1kTW9kdWxlKGZpbGVQYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBmc1xuICAgICAgICAucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCAndXRmLTgnKVxuICAgICAgICAvLyBTdHJpcCB0aGUgbmFtZWQgQU1EIG1vZHVsZSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1iYXplbCB1c2Vyc1xuICAgICAgICAucmVwbGFjZSgvXlxcL1xcL1xcLyA8YW1kLW1vZHVsZSBuYW1lPS4qXFwvPltcXHJcXG5dKy9nbSwgJycpO1xuICB9XG59XG5cbmlmIChyZXF1aXJlLm1haW4gPT09IG1vZHVsZSkge1xuICBwcm9jZXNzLmV4aXRDb2RlID0gbWFpbihwcm9jZXNzLmFyZ3Yuc2xpY2UoMikpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbmV3QXJyYXk8VCA9IGFueT4oc2l6ZTogbnVtYmVyKTogVFtdO1xuZXhwb3J0IGZ1bmN0aW9uIG5ld0FycmF5PFQ+KHNpemU6IG51bWJlciwgdmFsdWU6IFQpOiBUW107XG5leHBvcnQgZnVuY3Rpb24gbmV3QXJyYXk8VD4oc2l6ZTogbnVtYmVyLCB2YWx1ZT86IFQpOiBUW10ge1xuICBjb25zdCBsaXN0OiBUW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICBsaXN0LnB1c2godmFsdWUhKTtcbiAgfVxuICByZXR1cm4gbGlzdDtcbn1cbiJdfQ==