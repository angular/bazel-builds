/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("angular/packages/bazel/src/ng_package/packager", ["require", "exports", "fs", "path", "shelljs"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const fs = require("fs");
    const path = require("path");
    const shx = require("shelljs");
    /**
     * List of known `package.json` fields which provide information about
     * supported package formats and their associated entry paths.
     */
    const knownFormatPackageJsonFormatFields = ['main', 'fesm2020', 'esm2020', 'es2020', 'typings', 'module', 'fesm2015'];
    function main(args) {
        // Exit immediately when encountering an error.
        shx.set('-e');
        // This utility expects all of its arguments to be specified in a params file generated by
        // bazel (see https://docs.bazel.build/versions/master/skylark/lib/Args.html#use_param_file).
        const paramFilePath = args[0];
        // Bazel params may be surrounded with quotes
        function unquoteParameter(s) {
            return s.replace(/^'(.*)'$/, '$1');
        }
        // Parameters are specified in the file one per line.
        const params = fs.readFileSync(paramFilePath, 'utf-8').split('\n').map(unquoteParameter);
        const [
        // Output directory for the npm package.
        outputDirExecPath, 
        // The package segment of the ng_package rule's label (e.g. 'package/common').
        owningPackageName, 
        // JSON data capturing metadata of the package being built. See `PackageMetadata`.
        metadataArg, 
        // Path to the package's README.md.
        readmeMd, 
        // List of rolled-up flat ES2020 modules
        fesm2020Arg, 
        // List of individual ES2020 modules
        esm2020Arg, 
        // List of rolled-up flat ES2015 modules
        fesm2015Arg, 
        // List of static files that should be copied into the package.
        staticFilesArg, 
        // List of all type definitions that need to packaged into the ng_package.
        typeDefinitionsArg, 
        // Path to the package's LICENSE.
        licenseFile, 
        // List of all dts bundles generated by the API extractor.
        dtsBundleArg, 
        // The dts bundle file suffix example: '.bundle.d.ts'
        dtsBundleFileSuffix,] = params;
        const fesm2020 = JSON.parse(fesm2020Arg);
        const esm2020 = JSON.parse(esm2020Arg);
        const fesm2015 = JSON.parse(fesm2015Arg);
        const typeDefinitions = JSON.parse(typeDefinitionsArg);
        const staticFiles = JSON.parse(staticFilesArg);
        const metadata = JSON.parse(metadataArg);
        const dtsBundles = JSON.parse(dtsBundleArg);
        if (readmeMd) {
            copyFile(readmeMd, 'README.md');
        }
        /**
         * Writes a file with the specified content into the package output.
         * @param outputRelativePath Relative path in the output directory where the
         *   file is written to.
         * @param fileContent Content of the file.
         */
        function writeFile(outputRelativePath, fileContent) {
            const outputPath = path.join(outputDirExecPath, outputRelativePath);
            // Always ensure that the target directory exists.
            shx.mkdir('-p', path.dirname(outputPath));
            fs.writeFileSync(outputPath, fileContent);
        }
        /**
         * Copies a file into the package output to the specified location.
         * @param inputPath File that should be copied.
         * @param outputRelativePath Relative path in the output directory where the
         *   file is written to.
         */
        function copyFile(inputPath, outputRelativePath) {
            const fileContent = fs.readFileSync(inputPath, 'utf8');
            writeFile(outputRelativePath, fileContent);
        }
        /**
         * Gets the relative path for the given file within the owning package. This
         * assumes the file is contained in the owning package.
         *
         * e.g. consider the owning package is `packages/core` and the input file
         * is `packages/core/testing/index.d.ts`. This function would return the
         * relative path as followed: `testing/index.d.ts`.
         */
        function getOwningPackageRelativePath(file) {
            return path.relative(owningPackageName, file.shortPath);
        }
        /** Writes an ESM file into the `esm2020` output directory. */
        function writeEsm2020File(file) {
            // Note: files which do not belong to the owning package of this `ng_package` are omitted.
            // this prevents us from accidentally bringing in transitive node module dependencies.
            const packageRelativePath = getOwningPackageRelativePath(file);
            if (!packageRelativePath.startsWith('..')) {
                copyFile(file.path, getEsm2020OutputRelativePath(file));
            }
        }
        /** Gets the output-relative path where the given flat ESM file should be written to. */
        function getFlatEsmOutputRelativePath(file) {
            // Flat ESM files should be put into their owning package relative sub-path. e.g. if
            // there is a bundle in `packages/animations/fesm2020/browser/testing.mjs` then we
            // want the bundle to be stored in `fesm2020/browser/testing.mjs`. Same thing applies
            // for the `fesm2015` bundles. The directory name for `fesm` is already declared as
            // part of the Bazel action generating these files. See `ng_package.bzl`.
            return getOwningPackageRelativePath(file);
        }
        /** Gets the output-relative path where a non-flat ESM2020 file should be written to. */
        function getEsm2020OutputRelativePath(file) {
            // Path computed relative to the current package in bazel-bin. e.g. a ES2020 output file
            // in `bazel-out/<..>/packages/core/src/di.mjs` should be stored in `esm2020/src/di.mjs`.
            return path.join('esm2020', getOwningPackageRelativePath(file));
        }
        /** Gets the output-relative path where the typing file is being written to. */
        function getTypingOutputRelativePath(file) {
            // Type definitions are intended to be copied into the package output while preserving the
            // sub-path from the owning package. e.g. a file like `packages/animations/browser/index.d.ts`
            // will end up being written to `<pkg-out>/browser/index.d.ts`
            return getOwningPackageRelativePath(file);
        }
        /**
         * Gets the entry-point sub-path from the package root. e.g. if the package name
         * is `@angular/cdk`, then for `@angular/cdk/a11y` just `a11y` would be returned.
         */
        function getEntryPointSubpath(moduleName) {
            return moduleName.slice(`${metadata.npmPackageName}/`.length);
        }
        /**
         * Gets whether the given module name resolves to a secondary entry-point.
         * e.g. if the package name is `@angular/cdk`, then for `@angular/cdk/a11y`
         * this would return `true`.
         */
        function isSecondaryEntryPoint(moduleName) {
            return getEntryPointSubpath(moduleName) !== '';
        }
        esm2020.forEach(file => writeEsm2020File(file));
        // Copy all FESM files into the package output.
        fesm2020.forEach(f => copyFile(f.path, getFlatEsmOutputRelativePath(f)));
        fesm2015.forEach(f => copyFile(f.path, getFlatEsmOutputRelativePath(f)));
        // Copy all type definitions into the package, preserving the sub-path from the
        // owning package. e.g. a file like `packages/animations/browser/index.d.ts` will
        // end up in `browser/index.d.ts`
        typeDefinitions.forEach(f => writeFile(getTypingOutputRelativePath(f), readTypingsAndStripAmdModule(f.path)));
        const licenseBanner = licenseFile ? fs.readFileSync(licenseFile, 'utf8') : '';
        dtsBundles.forEach(bundleDtsFile => {
            // We copy the `d.ts` bundles while preserving the sub-path from the owning
            // package. e.g. `packages/animations/animations.bundle.d.ts` will end up being
            // copied into `<pkg-out>/animations.d.ts`. Notice how the `.bundle` suffix
            // has been removed. The `ng_module` appends this to avoid conflicts with the
            // actual typings files being generated by the TS/Angular compilation.
            const outputRelativePath = getTypingOutputRelativePath(bundleDtsFile).replace(dtsBundleFileSuffix, '.d.ts');
            // API extractor will not dedupe license comments from various files
            // this will remove all the license comments and append the license banner.
            const content = licenseBanner + '\n' +
                readTypingsAndStripAmdModule(bundleDtsFile.path)
                    .replace(/(\/\*\*\s+\*\s\@license(((?!\*\/).|\s)*)\*\/)/gm, '');
            writeFile(outputRelativePath, content);
        });
        const modulesWithExistingPackageJson = new Set();
        for (const file of staticFiles) {
            // We copy all files into the package output while preserving the sub-path from
            // the owning package. e.g. `packages/core/package.json` ends up `<pkg-out>/package.json`.
            const outputRelativePath = getOwningPackageRelativePath(file);
            let content = fs.readFileSync(file.path, 'utf8');
            // Modify package.json files as necessary for publishing
            if (path.basename(file.path) === 'package.json') {
                const isPrimaryPackageJson = outputRelativePath === 'package.json';
                const packageJson = JSON.parse(content);
                const packageName = packageJson['name'];
                // Check if the `name` field of the `package.json` files are matching with
                // name of the NPM package. This is an additional safety check.
                if (isPrimaryPackageJson && packageName !== metadata.npmPackageName) {
                    throw Error(`Primary "package.json" has mismatching package name. Expected the ` +
                        `package to be named "${metadata.npmPackageName}", but is set to: ${packageName}.`);
                }
                if (!isPrimaryPackageJson && !packageName.startsWith(`${metadata.npmPackageName}/`)) {
                    throw Error(`Found a "package.json" which does not start with the name of the primary ` +
                        `entry-point. Secondary entry-points need to start with "${metadata.npmPackageName}/", ` +
                        `but is set to: ${packageName}.`);
                }
                let newPackageJson = insertFormatFieldsIntoPackageJson(outputRelativePath, packageJson, false);
                if (isPrimaryPackageJson) {
                    newPackageJson = updatePrimaryPackageJson(newPackageJson);
                }
                // Keep track of the modules we have `package.json` files provided as part of
                // the sources. We use this later to skip generation of `package.json` files
                // for the modules the consumer already created a file.
                modulesWithExistingPackageJson.add(packageName);
                // Update the content with the new `package.json` file content.
                content = JSON.stringify(newPackageJson, null, 2);
            }
            writeFile(outputRelativePath, content);
        }
        // Generate extra files for secondary entry-points.
        Object.keys(metadata.entryPoints).forEach(moduleName => {
            if (!isSecondaryEntryPoint(moduleName)) {
                return;
            }
            // If there is a `package.json` already defined as part of the sources,
            // skip generation of the secondary `package.json` file.
            if (modulesWithExistingPackageJson.has(moduleName)) {
                return;
            }
            const packageJsonDir = getEntryPointSubpath(moduleName);
            createSecondaryEntryPointPackageJson(packageJsonDir, moduleName);
        });
        /**
         * Inserts or edits properties into the package.json file(s) in the package so that
         * they point to all the right generated artifacts.
         *
         * @param packageJsonOutRelativePath Path where the `package.json` is stored in
         *   the package output.
         * @param parsedPackage Parsed package.json content
         * @param isGeneratedPackageJson Whether the passed package.json has been generated.
         */
        function insertFormatFieldsIntoPackageJson(packageJsonOutRelativePath, parsedPackage, isGeneratedPackageJson) {
            const packageJson = Object.assign({}, parsedPackage);
            const packageName = packageJson['name'];
            const entryPointInfo = metadata.entryPoints[packageName];
            const packageJsonContainingDir = path.dirname(packageJsonOutRelativePath);
            // If a package json file has been discovered that does not match any
            // entry-point in the metadata, we report a warning as most likely the target
            // is configured incorrectly (e.g. missing `module_name` attribute).
            if (!entryPointInfo) {
                // Ideally we should throw here, as we got an entry point that doesn't
                // have flat module metadata / bundle index, so it may have been an
                // ng_module that's missing a module_name attribute.
                // However, @angular/compiler can't be an ng_module, as it's the internals
                // of the ngc compiler, yet we want to build an ng_package for it.
                // So ignore package.json files when we are missing data.
                console.error('WARNING: no module metadata for package', packageName);
                console.error('   Not updating the package.json file to point to it');
                console.error('   The ng_module for this package is possibly missing the module_name attribute ');
                return packageJson;
            }
            // If we guessed the index paths for a module, and it contains an explicit `package.json`
            // file that already sets format properties, we skip automatic insertion of format
            // properties but report a warning in case properties have been set by accident.
            if (entryPointInfo.guessedPaths && !isGeneratedPackageJson &&
                hasExplicitFormatProperties(packageJson)) {
                console.error('WARNING: `package.json` explicitly sets format properties (like `main`).');
                console.error('    Skipping automatic insertion of format properties as explicit ' +
                    'format properties are set.');
                console.error('    Ignore this warning if explicit properties are set intentionally.');
                return packageJson;
            }
            const fesm2020RelativeOutPath = getFlatEsmOutputRelativePath(entryPointInfo.fesm2020Bundle);
            const fesm2015RelativeOutPath = getFlatEsmOutputRelativePath(entryPointInfo.fesm2015Bundle);
            const esm2020RelativeOutPath = getEsm2020OutputRelativePath(entryPointInfo.index);
            const typingsRelativeOutPath = getTypingOutputRelativePath(entryPointInfo.typings);
            packageJson.fesm2020 =
                normalizePath(path.relative(packageJsonContainingDir, fesm2020RelativeOutPath));
            packageJson.fesm2015 =
                normalizePath(path.relative(packageJsonContainingDir, fesm2015RelativeOutPath));
            packageJson.esm2020 =
                normalizePath(path.relative(packageJsonContainingDir, esm2020RelativeOutPath));
            packageJson.typings =
                normalizePath(path.relative(packageJsonContainingDir, typingsRelativeOutPath));
            // For now, we point the primary entry points at the fesm files, because of Webpack
            // performance issues with a large number of individual files.
            packageJson.module = packageJson.fesm2015;
            packageJson.es2020 = packageJson.fesm2020;
            return packageJson;
        }
        /**
         * Updates the primary `package.json` file of the NPM package to specify
         * the module conditional exports and the ESM module type.
         */
        function updatePrimaryPackageJson(packageJson) {
            if (packageJson.type !== undefined) {
                throw Error('The primary "package.json" file of the package sets the "type" field ' +
                    'that is controlled by the packager. Please unset it.');
            }
            const newPackageJson = Object.assign({}, packageJson);
            newPackageJson.type = 'module';
            // The `package.json` file is made publicly accessible for tools that
            // might want to query information from the Angular NPM package.
            insertExportMappingOrError(newPackageJson, './package.json', { default: './package.json' });
            // Capture all entry-points in the `exports` field using the subpath export declarations:
            // https://nodejs.org/api/packages.html#packages_subpath_exports.
            for (const [moduleName, entryPoint] of Object.entries(metadata.entryPoints)) {
                const subpath = isSecondaryEntryPoint(moduleName) ? `./${getEntryPointSubpath(moduleName)}` : '.';
                const esm2020IndexOutRelativePath = getEsm2020OutputRelativePath(entryPoint.index);
                const fesm2020OutRelativePath = getFlatEsmOutputRelativePath(entryPoint.fesm2020Bundle);
                const fesm2015OutRelativePath = getFlatEsmOutputRelativePath(entryPoint.fesm2015Bundle);
                const typesOutRelativePath = getTypingOutputRelativePath(entryPoint.typings);
                // Insert the export mapping for the entry-point. We set `default` to the FESM 2020
                // output, and also set the `types` condition which will be respected by TS 4.5.
                // https://github.com/microsoft/TypeScript/pull/45884.
                insertExportMappingOrError(newPackageJson, subpath, {
                    types: normalizePath(typesOutRelativePath),
                    esm2020: normalizePath(esm2020IndexOutRelativePath),
                    es2020: normalizePath(fesm2020OutRelativePath),
                    // We also expose a non-standard condition that would allow consumers to resolve
                    // to the `ES2015` output outside of NodeJS, if desired.
                    // TODO(devversion): remove/replace this if NodeJS v12 is no longer supported.
                    es2015: normalizePath(fesm2015OutRelativePath),
                    // We declare the `node` condition and point to the ES2015 output as we currently still
                    // support NodeJS v12 which does not fully support ES2020 output. We chose ES2015 over
                    // ES2020 because we wan async/await downleveled as this allows for patching withZoneJS.
                    // TODO(devversion): remove/replace this if NodeJS v12 is no longer supported.
                    node: normalizePath(fesm2015OutRelativePath),
                    // Note: The default conditions needs to be the last one.
                    default: normalizePath(fesm2020OutRelativePath),
                });
            }
            return newPackageJson;
        }
        /**
         * Inserts a subpath export mapping into the specified `package.json` object.
         * @throws An error if the mapping is already defined and would conflict.
         */
        function insertExportMappingOrError(packageJson, subpath, mapping) {
            if (packageJson.exports === undefined) {
                packageJson.exports = {};
            }
            if (packageJson.exports[subpath] === undefined) {
                packageJson.exports[subpath] = {};
            }
            const subpathExport = packageJson.exports[subpath];
            // Go through all conditions that should be inserted. If the condition is already
            // manually set of the subpath export, we throw an error. In general, we allow for
            // additional conditions to be set. These will always precede the generated ones.
            for (const conditionName of Object.keys(mapping)) {
                if (subpathExport[conditionName] !== undefined) {
                    throw Error(`Found a conflicting export condition for "${subpath}". The "${conditionName}" ` +
                        `condition would be overridden by the packager. Please unset it.`);
                }
                // **Note**: The order of the conditions is preserved even though we are setting
                // the conditions once at a time (the latest assignment will be at the end).
                subpathExport[conditionName] = mapping[conditionName];
            }
        }
        /** Whether the package explicitly sets any of the format properties (like `main`). */
        function hasExplicitFormatProperties(parsedPackage) {
            return Object.keys(parsedPackage)
                .some((fieldName) => knownFormatPackageJsonFormatFields.includes(fieldName));
        }
        /**
         * Creates a package.json for a secondary entry-point.
         * @param dir The directory under which the package.json should be written.
         * @param entryPointPackageName The full package name for the entry point,
         *     e.g. '@angular/common/http'.
         */
        function createSecondaryEntryPointPackageJson(dir, entryPointPackageName) {
            const relativeOutPath = path.join(dir, 'package.json');
            const content = insertFormatFieldsIntoPackageJson(relativeOutPath, { name: entryPointPackageName }, true);
            writeFile(relativeOutPath, JSON.stringify(content, null, 2));
        }
        /**
         * Normalizes the specified path by replacing backslash separators with Posix
         * forward slash separators.
         */
        function normalizePath(path) {
            const result = path.replace(/\\/g, '/');
            return result.startsWith('.') ? result : `./${result}`;
        }
        /**
         * Strip the named AMD module for compatibility with non-bazel users from typings content
         * @param filePath dts file path
         */
        function readTypingsAndStripAmdModule(filePath) {
            return fs
                .readFileSync(filePath, 'utf-8')
                // Strip the named AMD module for compatibility with non-bazel users
                .replace(/^\/\/\/ <amd-module name=.*\/>[\r\n]+/gm, '');
        }
    }
    if (require.main === module) {
        main(process.argv.slice(2));
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFja2FnZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9iYXplbC9zcmMvbmdfcGFja2FnZS9wYWNrYWdlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7Ozs7Ozs7Ozs7OztJQUVILHlCQUF5QjtJQUN6Qiw2QkFBNkI7SUFDN0IsK0JBQStCO0lBdUMvQjs7O09BR0c7SUFDSCxNQUFNLGtDQUFrQyxHQUNwQyxDQUFDLE1BQU0sRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLFVBQVUsQ0FBVSxDQUFDO0lBMkJ4RixTQUFTLElBQUksQ0FBQyxJQUFjO1FBQzFCLCtDQUErQztRQUMvQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRWQsMEZBQTBGO1FBQzFGLDZGQUE2RjtRQUM3RixNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFOUIsNkNBQTZDO1FBQzdDLFNBQVMsZ0JBQWdCLENBQUMsQ0FBUztZQUNqQyxPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ3JDLENBQUM7UUFFRCxxREFBcUQ7UUFDckQsTUFBTSxNQUFNLEdBQUcsRUFBRSxDQUFDLFlBQVksQ0FBQyxhQUFhLEVBQUUsT0FBTyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1FBRXpGLE1BQU07UUFDRix3Q0FBd0M7UUFDeEMsaUJBQWlCO1FBRWpCLDhFQUE4RTtRQUM5RSxpQkFBaUI7UUFFakIsa0ZBQWtGO1FBQ2xGLFdBQVc7UUFFWCxtQ0FBbUM7UUFDbkMsUUFBUTtRQUVSLHdDQUF3QztRQUN4QyxXQUFXO1FBRVgsb0NBQW9DO1FBQ3BDLFVBQVU7UUFFVix3Q0FBd0M7UUFDeEMsV0FBVztR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QUF5QyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQzlELENBQUM7SUFDSCxDQUFDO0lBRUQsSUFBSSxPQUFPLENBQUMsSUFBSSxLQUFLLE1BQU0sRUFBRTtRQUMzQixJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUM3QiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgc2h4IGZyb20gJ3NoZWxsanMnO1xuXG4vKipcbiAqIEludGVyZmFjZSBkZXNjcmliaW5nIGEgZmlsZSBjYXB0dXJlZCBpbiB0aGUgQmF6ZWwgYWN0aW9uLlxuICogaHR0cHM6Ly9kb2NzLmJhemVsLmJ1aWxkL3ZlcnNpb25zL21haW4vc2t5bGFyay9saWIvRmlsZS5odG1sLlxuICovXG5pbnRlcmZhY2UgQmF6ZWxGaWxlSW5mbyB7XG4gIC8qKiBFeGVjcm9vdC1yZWxhdGl2ZSBwYXRoIHBvaW50aW5nIHRvIHRoZSBmaWxlLiAqL1xuICBwYXRoOiBzdHJpbmc7XG4gIC8qKiBUaGUgcGF0aCBvZiB0aGlzIGZpbGUgcmVsYXRpdmUgdG8gaXRzIHJvb3QuIGUuZy4gb21pdHRpbmcgYGJhemVsLW91dC88Li4+L2JpbmAuICovXG4gIHNob3J0UGF0aDogc3RyaW5nO1xufVxuXG4vKiogSW50ZXJmYWNlIGRlc2NyaWJpbmcgYW4gZW50cnktcG9pbnQuICovXG5pbnRlcmZhY2UgRW50cnlQb2ludEluZm8ge1xuICAvKiogRVMyMDIwIGluZGV4IGZpbGUgZm9yIHRoZSBBUEYgZW50cnktcG9pbnQuICovXG4gIGluZGV4OiBCYXplbEZpbGVJbmZvO1xuICAvKiogRmxhdCBFUzIwMjAgRVMgbW9kdWxlIGJ1bmRsZSBmaWxlLiAqL1xuICBmZXNtMjAyMEJ1bmRsZTogQmF6ZWxGaWxlSW5mbztcbiAgLyoqIEZsYXQgRVMyMDE1IEVTIG1vZHVsZSBidW5kbGUgZmlsZS4gKi9cbiAgZmVzbTIwMTVCdW5kbGU6IEJhemVsRmlsZUluZm87XG4gIC8qKiBJbmRleCB0eXBlIGRlZmluaXRpb24gZmlsZSBmb3IgdGhlIEFQRiBlbnRyeS1wb2ludC4gKi9cbiAgdHlwaW5nczogQmF6ZWxGaWxlSW5mbztcbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGluZGV4IG9yIHR5cGluZyBwYXRocyBoYXZlIGJlZW4gZ3Vlc3NlZC4gRm9yIGVudHJ5LXBvaW50cyBidWlsdFxuICAgKiB0aHJvdWdoIGB0c19saWJyYXJ5YCwgdGhlcmUgaXMgbm8gZXhwbGljaXQgc2V0dGluZyB0aGF0IGRlY2xhcmVzIHRoZSBlbnRyeS1wb2ludFxuICAgKiBzbyB0aGUgaW5kZXggZmlsZSBpcyBndWVzc2VkLlxuICAgKi9cbiAgZ3Vlc3NlZFBhdGhzOiBib29sZWFuO1xufVxuXG4vKiogSW50ZXJmYWNlIGNhcHR1cmluZyByZWxldmFudCBtZXRhZGF0YSBmb3IgcGFja2FnaW5nLiAqL1xuaW50ZXJmYWNlIFBhY2thZ2VNZXRhZGF0YSB7XG4gIC8qKiBOUE0gcGFja2FnZSBuYW1lIG9mIHRoZSBvdXRwdXQuICovXG4gIG5wbVBhY2thZ2VOYW1lOiBzdHJpbmc7XG4gIC8qKiBSZWNvcmQgb2YgZW50cnktcG9pbnRzIChpbmNsdWRpbmcgdGhlIHByaW1hcnkgb25lKSBhbmQgdGhlaXIgaW5mby4gKi9cbiAgZW50cnlQb2ludHM6IFJlY29yZDxzdHJpbmcsIEVudHJ5UG9pbnRJbmZvPjtcbn1cblxuLyoqXG4gKiBMaXN0IG9mIGtub3duIGBwYWNrYWdlLmpzb25gIGZpZWxkcyB3aGljaCBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0XG4gKiBzdXBwb3J0ZWQgcGFja2FnZSBmb3JtYXRzIGFuZCB0aGVpciBhc3NvY2lhdGVkIGVudHJ5IHBhdGhzLlxuICovXG5jb25zdCBrbm93bkZvcm1hdFBhY2thZ2VKc29uRm9ybWF0RmllbGRzID1cbiAgICBbJ21haW4nLCAnZmVzbTIwMjAnLCAnZXNtMjAyMCcsICdlczIwMjAnLCAndHlwaW5ncycsICdtb2R1bGUnLCAnZmVzbTIwMTUnXSBhcyBjb25zdDtcblxuLyoqIFVuaW9uIHR5cGUgbWF0Y2hpbmcga25vd24gYHBhY2thZ2UuanNvbmAgZm9ybWF0IGZpZWxkcy4gKi9cbnR5cGUgS25vd25QYWNrYWdlSnNvbkZvcm1hdEZpZWxkcyA9IHR5cGVvZiBrbm93bkZvcm1hdFBhY2thZ2VKc29uRm9ybWF0RmllbGRzW251bWJlcl07XG5cbi8qKlxuICogVHlwZSBkZXNjcmliaW5nIHRoZSBjb25kaXRpb25hbCBleHBvcnRzIGRlc2NyaXB0b3IgZm9yIGFuIGVudHJ5LXBvaW50LlxuICogaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9wYWNrYWdlcy5odG1sI3BhY2thZ2VzX2NvbmRpdGlvbmFsX2V4cG9ydHNcbiAqL1xudHlwZSBDb25kaXRpb25hbEV4cG9ydCA9IHtcbiAgbm9kZT86IHN0cmluZztcbiAgdHlwZXM/OiBzdHJpbmc7XG4gIGVzbTIwMjA/OiBzdHJpbmc7XG4gIGVzMjAyMD86IHN0cmluZztcbiAgZXMyMDE1Pzogc3RyaW5nO1xuICBkZWZhdWx0Pzogc3RyaW5nO1xufTtcblxuLyoqIFR5cGUgZGVzY3JpYmluZyBhIGBwYWNrYWdlLmpzb25gIHRoZSBwYWNrYWdlciBkZWFscyB3aXRoLiAqL1xudHlwZSBQYWNrYWdlSnNvbiA9IHtcbiAgW2tleSBpbiBLbm93blBhY2thZ2VKc29uRm9ybWF0RmllbGRzXT86IHN0cmluZ1xufSZ7XG4gIG5hbWU6IHN0cmluZztcbiAgdHlwZT86IHN0cmluZztcbiAgZXhwb3J0cz86IFJlY29yZDxzdHJpbmcsIENvbmRpdGlvbmFsRXhwb3J0Pjtcbn07XG5cbmZ1bmN0aW9uIG1haW4oYXJnczogc3RyaW5nW10pOiB2b2lkIHtcbiAgLy8gRXhpdCBpbW1lZGlhdGVseSB3aGVuIGVuY291bnRlcmluZyBhbiBlcnJvci5cbiAgc2h4LnNldCgnLWUnKTtcblxuICAvLyBUaGlzIHV0aWxpdHkgZXhwZWN0cyBhbGwgb2YgaXRzIGFyZ3VtZW50cyB0byBiZSBzcGVjaWZpZWQgaW4gYSBwYXJhbXMgZmlsZSBnZW5lcmF0ZWQgYnlcbiAgLy8gYmF6ZWwgKHNlZSBodHRwczovL2RvY3MuYmF6ZWwuYnVpbGQvdmVyc2lvbnMvbWFzdGVyL3NreWxhcmsvbGliL0FyZ3MuaHRtbCN1c2VfcGFyYW1fZmlsZSkuXG4gIGNvbnN0IHBhcmFtRmlsZVBhdGggPSBhcmdzWzBdO1xuXG4gIC8vIEJhemVsIHBhcmFtcyBtYXkgYmUgc3Vycm91bmRlZCB3aXRoIHF1b3Rlc1xuICBmdW5jdGlvbiB1bnF1b3RlUGFyYW1ldGVyKHM6IHN0cmluZykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoL14nKC4qKSckLywgJyQxJyk7XG4gIH1cblxuICAvLyBQYXJhbWV0ZXJzIGFyZSBzcGVjaWZpZWQgaW4gdGhlIGZpbGUgb25lIHBlciBsaW5lLlxuICBjb25zdCBwYXJhbXMgPSBmcy5yZWFkRmlsZVN5bmMocGFyYW1GaWxlUGF0aCwgJ3V0Zi04Jykuc3BsaXQoJ1xcbicpLm1hcCh1bnF1b3RlUGFyYW1ldGVyKTtcblxuICBjb25zdCBbXG4gICAgICAvLyBPdXRwdXQgZGlyZWN0b3J5IGZvciB0aGUgbnBtIHBhY2thZ2UuXG4gICAgICBvdXRwdXREaXJFeGVjUGF0aCxcblxuICAgICAgLy8gVGhlIHBhY2thZ2Ugc2VnbWVudCBvZiB0aGUgbmdfcGFja2FnZSBydWxlJ3MgbGFiZWwgKGUuZy4gJ3BhY2thZ2UvY29tbW9uJykuXG4gICAgICBvd25pbmdQYWNrYWdlTmFtZSxcblxuICAgICAgLy8gSlNPTiBkYXRhIGNhcHR1cmluZyBtZXRhZGF0YSBvZiB0aGUgcGFja2FnZSBiZWluZyBidWlsdC4gU2VlIGBQYWNrYWdlTWV0YWRhdGFgLlxuICAgICAgbWV0YWRhdGFBcmcsXG5cbiAgICAgIC8vIFBhdGggdG8gdGhlIHBhY2thZ2UncyBSRUFETUUubWQuXG4gICAgICByZWFkbWVNZCxcblxuICAgICAgLy8gTGlzdCBvZiByb2xsZWQtdXAgZmxhdCBFUzIwMjAgbW9kdWxlc1xuICAgICAgZmVzbTIwMjBBcmcsXG5cbiAgICAgIC8vIExpc3Qgb2YgaW5kaXZpZHVhbCBFUzIwMjAgbW9kdWxlc1xuICAgICAgZXNtMjAyMEFyZyxcblxuICAgICAgLy8gTGlzdCBvZiByb2xsZWQtdXAgZmxhdCBFUzIwMTUgbW9kdWxlc1xuICAgICAgZmVzbTIwMTVBcmcsXG5cbiAgICAgIC8vIExpc3Qgb2Ygc3RhdGljIGZpbGVzIHRoYXQgc2hvdWxkIGJlIGNvcGllZCBpbnRvIHRoZSBwYWNrYWdlLlxuICAgICAgc3RhdGljRmlsZXNBcmcsXG5cbiAgICAgIC8vIExpc3Qgb2YgYWxsIHR5cGUgZGVmaW5pdGlvbnMgdGhhdCBuZWVkIHRvIHBhY2thZ2VkIGludG8gdGhlIG5nX3BhY2thZ2UuXG4gICAgICB0eXBlRGVmaW5pdGlvbnNBcmcsXG5cbiAgICAgIC8vIFBhdGggdG8gdGhlIHBhY2thZ2UncyBMSUNFTlNFLlxuICAgICAgbGljZW5zZUZpbGUsXG5cbiAgICAgIC8vIExpc3Qgb2YgYWxsIGR0cyBidW5kbGVzIGdlbmVyYXRlZCBieSB0aGUgQVBJIGV4dHJhY3Rvci5cbiAgICAgIGR0c0J1bmRsZUFyZyxcblxuICAgICAgLy8gVGhlIGR0cyBidW5kbGUgZmlsZSBzdWZmaXggZXhhbXBsZTogJy5idW5kbGUuZC50cydcbiAgICAgIGR0c0J1bmRsZUZpbGVTdWZmaXgsXG4gIF0gPSBwYXJhbXM7XG5cbiAgY29uc3QgZmVzbTIwMjAgPSBKU09OLnBhcnNlKGZlc20yMDIwQXJnKSBhcyBCYXplbEZpbGVJbmZvW107XG4gIGNvbnN0IGVzbTIwMjAgPSBKU09OLnBhcnNlKGVzbTIwMjBBcmcpIGFzIEJhemVsRmlsZUluZm9bXTtcbiAgY29uc3QgZmVzbTIwMTUgPSBKU09OLnBhcnNlKGZlc20yMDE1QXJnKSBhcyBCYXplbEZpbGVJbmZvW107XG4gIGNvbnN0IHR5cGVEZWZpbml0aW9ucyA9IEpTT04ucGFyc2UodHlwZURlZmluaXRpb25zQXJnKSBhcyBCYXplbEZpbGVJbmZvW107XG4gIGNvbnN0IHN0YXRpY0ZpbGVzID0gSlNPTi5wYXJzZShzdGF0aWNGaWxlc0FyZykgYXMgQmF6ZWxGaWxlSW5mb1tdO1xuICBjb25zdCBtZXRhZGF0YSA9IEpTT04ucGFyc2UobWV0YWRhdGFBcmcpIGFzIFBhY2thZ2VNZXRhZGF0YTtcbiAgY29uc3QgZHRzQnVuZGxlcyA9IEpTT04ucGFyc2UoZHRzQnVuZGxlQXJnKSBhcyBCYXplbEZpbGVJbmZvW107XG5cbiAgaWYgKHJlYWRtZU1kKSB7XG4gICAgY29weUZpbGUocmVhZG1lTWQsICdSRUFETUUubWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZXMgYSBmaWxlIHdpdGggdGhlIHNwZWNpZmllZCBjb250ZW50IGludG8gdGhlIHBhY2thZ2Ugb3V0cHV0LlxuICAgKiBAcGFyYW0gb3V0cHV0UmVsYXRpdmVQYXRoIFJlbGF0aXZlIHBhdGggaW4gdGhlIG91dHB1dCBkaXJlY3Rvcnkgd2hlcmUgdGhlXG4gICAqICAgZmlsZSBpcyB3cml0dGVuIHRvLlxuICAgKiBAcGFyYW0gZmlsZUNvbnRlbnQgQ29udGVudCBvZiB0aGUgZmlsZS5cbiAgICovXG4gIGZ1bmN0aW9uIHdyaXRlRmlsZShvdXRwdXRSZWxhdGl2ZVBhdGg6IHN0cmluZywgZmlsZUNvbnRlbnQ6IHN0cmluZ3xCdWZmZXIpIHtcbiAgICBjb25zdCBvdXRwdXRQYXRoID0gcGF0aC5qb2luKG91dHB1dERpckV4ZWNQYXRoLCBvdXRwdXRSZWxhdGl2ZVBhdGgpO1xuXG4gICAgLy8gQWx3YXlzIGVuc3VyZSB0aGF0IHRoZSB0YXJnZXQgZGlyZWN0b3J5IGV4aXN0cy5cbiAgICBzaHgubWtkaXIoJy1wJywgcGF0aC5kaXJuYW1lKG91dHB1dFBhdGgpKTtcbiAgICBmcy53cml0ZUZpbGVTeW5jKG91dHB1dFBhdGgsIGZpbGVDb250ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3BpZXMgYSBmaWxlIGludG8gdGhlIHBhY2thZ2Ugb3V0cHV0IHRvIHRoZSBzcGVjaWZpZWQgbG9jYXRpb24uXG4gICAqIEBwYXJhbSBpbnB1dFBhdGggRmlsZSB0aGF0IHNob3VsZCBiZSBjb3BpZWQuXG4gICAqIEBwYXJhbSBvdXRwdXRSZWxhdGl2ZVBhdGggUmVsYXRpdmUgcGF0aCBpbiB0aGUgb3V0cHV0IGRpcmVjdG9yeSB3aGVyZSB0aGVcbiAgICogICBmaWxlIGlzIHdyaXR0ZW4gdG8uXG4gICAqL1xuICBmdW5jdGlvbiBjb3B5RmlsZShpbnB1dFBhdGg6IHN0cmluZywgb3V0cHV0UmVsYXRpdmVQYXRoOiBzdHJpbmcpIHtcbiAgICBjb25zdCBmaWxlQ29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhpbnB1dFBhdGgsICd1dGY4Jyk7XG4gICAgd3JpdGVGaWxlKG91dHB1dFJlbGF0aXZlUGF0aCwgZmlsZUNvbnRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHJlbGF0aXZlIHBhdGggZm9yIHRoZSBnaXZlbiBmaWxlIHdpdGhpbiB0aGUgb3duaW5nIHBhY2thZ2UuIFRoaXNcbiAgICogYXNzdW1lcyB0aGUgZmlsZSBpcyBjb250YWluZWQgaW4gdGhlIG93bmluZyBwYWNrYWdlLlxuICAgKlxuICAgKiBlLmcuIGNvbnNpZGVyIHRoZSBvd25pbmcgcGFja2FnZSBpcyBgcGFja2FnZXMvY29yZWAgYW5kIHRoZSBpbnB1dCBmaWxlXG4gICAqIGlzIGBwYWNrYWdlcy9jb3JlL3Rlc3RpbmcvaW5kZXguZC50c2AuIFRoaXMgZnVuY3Rpb24gd291bGQgcmV0dXJuIHRoZVxuICAgKiByZWxhdGl2ZSBwYXRoIGFzIGZvbGxvd2VkOiBgdGVzdGluZy9pbmRleC5kLnRzYC5cbiAgICovXG4gIGZ1bmN0aW9uIGdldE93bmluZ1BhY2thZ2VSZWxhdGl2ZVBhdGgoZmlsZTogQmF6ZWxGaWxlSW5mbyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHBhdGgucmVsYXRpdmUob3duaW5nUGFja2FnZU5hbWUsIGZpbGUuc2hvcnRQYXRoKTtcbiAgfVxuXG4gIC8qKiBXcml0ZXMgYW4gRVNNIGZpbGUgaW50byB0aGUgYGVzbTIwMjBgIG91dHB1dCBkaXJlY3RvcnkuICovXG4gIGZ1bmN0aW9uIHdyaXRlRXNtMjAyMEZpbGUoZmlsZTogQmF6ZWxGaWxlSW5mbykge1xuICAgIC8vIE5vdGU6IGZpbGVzIHdoaWNoIGRvIG5vdCBiZWxvbmcgdG8gdGhlIG93bmluZyBwYWNrYWdlIG9mIHRoaXMgYG5nX3BhY2thZ2VgIGFyZSBvbWl0dGVkLlxuICAgIC8vIHRoaXMgcHJldmVudHMgdXMgZnJvbSBhY2NpZGVudGFsbHkgYnJpbmdpbmcgaW4gdHJhbnNpdGl2ZSBub2RlIG1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gICAgY29uc3QgcGFja2FnZVJlbGF0aXZlUGF0aCA9IGdldE93bmluZ1BhY2thZ2VSZWxhdGl2ZVBhdGgoZmlsZSk7XG4gICAgaWYgKCFwYWNrYWdlUmVsYXRpdmVQYXRoLnN0YXJ0c1dpdGgoJy4uJykpIHtcbiAgICAgIGNvcHlGaWxlKGZpbGUucGF0aCwgZ2V0RXNtMjAyME91dHB1dFJlbGF0aXZlUGF0aChmaWxlKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEdldHMgdGhlIG91dHB1dC1yZWxhdGl2ZSBwYXRoIHdoZXJlIHRoZSBnaXZlbiBmbGF0IEVTTSBmaWxlIHNob3VsZCBiZSB3cml0dGVuIHRvLiAqL1xuICBmdW5jdGlvbiBnZXRGbGF0RXNtT3V0cHV0UmVsYXRpdmVQYXRoKGZpbGU6IEJhemVsRmlsZUluZm8pIHtcbiAgICAvLyBGbGF0IEVTTSBmaWxlcyBzaG91bGQgYmUgcHV0IGludG8gdGhlaXIgb3duaW5nIHBhY2thZ2UgcmVsYXRpdmUgc3ViLXBhdGguIGUuZy4gaWZcbiAgICAvLyB0aGVyZSBpcyBhIGJ1bmRsZSBpbiBgcGFja2FnZXMvYW5pbWF0aW9ucy9mZXNtMjAyMC9icm93c2VyL3Rlc3RpbmcubWpzYCB0aGVuIHdlXG4gICAgLy8gd2FudCB0aGUgYnVuZGxlIHRvIGJlIHN0b3JlZCBpbiBgZmVzbTIwMjAvYnJvd3Nlci90ZXN0aW5nLm1qc2AuIFNhbWUgdGhpbmcgYXBwbGllc1xuICAgIC8vIGZvciB0aGUgYGZlc20yMDE1YCBidW5kbGVzLiBUaGUgZGlyZWN0b3J5IG5hbWUgZm9yIGBmZXNtYCBpcyBhbHJlYWR5IGRlY2xhcmVkIGFzXG4gICAgLy8gcGFydCBvZiB0aGUgQmF6ZWwgYWN0aW9uIGdlbmVyYXRpbmcgdGhlc2UgZmlsZXMuIFNlZSBgbmdfcGFja2FnZS5iemxgLlxuICAgIHJldHVybiBnZXRPd25pbmdQYWNrYWdlUmVsYXRpdmVQYXRoKGZpbGUpO1xuICB9XG5cbiAgLyoqIEdldHMgdGhlIG91dHB1dC1yZWxhdGl2ZSBwYXRoIHdoZXJlIGEgbm9uLWZsYXQgRVNNMjAyMCBmaWxlIHNob3VsZCBiZSB3cml0dGVuIHRvLiAqL1xuICBmdW5jdGlvbiBnZXRFc20yMDIwT3V0cHV0UmVsYXRpdmVQYXRoKGZpbGU6IEJhemVsRmlsZUluZm8pIHtcbiAgICAvLyBQYXRoIGNvbXB1dGVkIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBhY2thZ2UgaW4gYmF6ZWwtYmluLiBlLmcuIGEgRVMyMDIwIG91dHB1dCBmaWxlXG4gICAgLy8gaW4gYGJhemVsLW91dC88Li4+L3BhY2thZ2VzL2NvcmUvc3JjL2RpLm1qc2Agc2hvdWxkIGJlIHN0b3JlZCBpbiBgZXNtMjAyMC9zcmMvZGkubWpzYC5cbiAgICByZXR1cm4gcGF0aC5qb2luKCdlc20yMDIwJywgZ2V0T3duaW5nUGFja2FnZVJlbGF0aXZlUGF0aChmaWxlKSk7XG4gIH1cblxuICAvKiogR2V0cyB0aGUgb3V0cHV0LXJlbGF0aXZlIHBhdGggd2hlcmUgdGhlIHR5cGluZyBmaWxlIGlzIGJlaW5nIHdyaXR0ZW4gdG8uICovXG4gIGZ1bmN0aW9uIGdldFR5cGluZ091dHB1dFJlbGF0aXZlUGF0aChmaWxlOiBCYXplbEZpbGVJbmZvKSB7XG4gICAgLy8gVHlwZSBkZWZpbml0aW9ucyBhcmUgaW50ZW5kZWQgdG8gYmUgY29waWVkIGludG8gdGhlIHBhY2thZ2Ugb3V0cHV0IHdoaWxlIHByZXNlcnZpbmcgdGhlXG4gICAgLy8gc3ViLXBhdGggZnJvbSB0aGUgb3duaW5nIHBhY2thZ2UuIGUuZy4gYSBmaWxlIGxpa2UgYHBhY2thZ2VzL2FuaW1hdGlvbnMvYnJvd3Nlci9pbmRleC5kLnRzYFxuICAgIC8vIHdpbGwgZW5kIHVwIGJlaW5nIHdyaXR0ZW4gdG8gYDxwa2ctb3V0Pi9icm93c2VyL2luZGV4LmQudHNgXG4gICAgcmV0dXJuIGdldE93bmluZ1BhY2thZ2VSZWxhdGl2ZVBhdGgoZmlsZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgZW50cnktcG9pbnQgc3ViLXBhdGggZnJvbSB0aGUgcGFja2FnZSByb290LiBlLmcuIGlmIHRoZSBwYWNrYWdlIG5hbWVcbiAgICogaXMgYEBhbmd1bGFyL2Nka2AsIHRoZW4gZm9yIGBAYW5ndWxhci9jZGsvYTExeWAganVzdCBgYTExeWAgd291bGQgYmUgcmV0dXJuZWQuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRFbnRyeVBvaW50U3VicGF0aChtb2R1bGVOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBtb2R1bGVOYW1lLnNsaWNlKGAke21ldGFkYXRhLm5wbVBhY2thZ2VOYW1lfS9gLmxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB3aGV0aGVyIHRoZSBnaXZlbiBtb2R1bGUgbmFtZSByZXNvbHZlcyB0byBhIHNlY29uZGFyeSBlbnRyeS1wb2ludC5cbiAgICogZS5nLiBpZiB0aGUgcGFja2FnZSBuYW1lIGlzIGBAYW5ndWxhci9jZGtgLCB0aGVuIGZvciBgQGFuZ3VsYXIvY2RrL2ExMXlgXG4gICAqIHRoaXMgd291bGQgcmV0dXJuIGB0cnVlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGlzU2Vjb25kYXJ5RW50cnlQb2ludChtb2R1bGVOYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZ2V0RW50cnlQb2ludFN1YnBhdGgobW9kdWxlTmFtZSkgIT09ICcnO1xuICB9XG5cbiAgZXNtMjAyMC5mb3JFYWNoKGZpbGUgPT4gd3JpdGVFc20yMDIwRmlsZShmaWxlKSk7XG5cbiAgLy8gQ29weSBhbGwgRkVTTSBmaWxlcyBpbnRvIHRoZSBwYWNrYWdlIG91dHB1dC5cbiAgZmVzbTIwMjAuZm9yRWFjaChmID0+IGNvcHlGaWxlKGYucGF0aCwgZ2V0RmxhdEVzbU91dHB1dFJlbGF0aXZlUGF0aChmKSkpO1xuICBmZXNtMjAxNS5mb3JFYWNoKGYgPT4gY29weUZpbGUoZi5wYXRoLCBnZXRGbGF0RXNtT3V0cHV0UmVsYXRpdmVQYXRoKGYpKSk7XG5cbiAgLy8gQ29weSBhbGwgdHlwZSBkZWZpbml0aW9ucyBpbnRvIHRoZSBwYWNrYWdlLCBwcmVzZXJ2aW5nIHRoZSBzdWItcGF0aCBmcm9tIHRoZVxuICAvLyBvd25pbmcgcGFja2FnZS4gZS5nLiBhIGZpbGUgbGlrZSBgcGFja2FnZXMvYW5pbWF0aW9ucy9icm93c2VyL2luZGV4LmQudHNgIHdpbGxcbiAgLy8gZW5kIHVwIGluIGBicm93c2VyL2luZGV4LmQudHNgXG4gIHR5cGVEZWZpbml0aW9ucy5mb3JFYWNoKFxuICAgICAgZiA9PiB3cml0ZUZpbGUoZ2V0VHlwaW5nT3V0cHV0UmVsYXRpdmVQYXRoKGYpLCByZWFkVHlwaW5nc0FuZFN0cmlwQW1kTW9kdWxlKGYucGF0aCkpKTtcblxuICBjb25zdCBsaWNlbnNlQmFubmVyID0gbGljZW5zZUZpbGUgPyBmcy5yZWFkRmlsZVN5bmMobGljZW5zZUZpbGUsICd1dGY4JykgOiAnJztcblxuICBkdHNCdW5kbGVzLmZvckVhY2goYnVuZGxlRHRzRmlsZSA9PiB7XG4gICAgLy8gV2UgY29weSB0aGUgYGQudHNgIGJ1bmRsZXMgd2hpbGUgcHJlc2VydmluZyB0aGUgc3ViLXBhdGggZnJvbSB0aGUgb3duaW5nXG4gICAgLy8gcGFja2FnZS4gZS5nLiBgcGFja2FnZXMvYW5pbWF0aW9ucy9hbmltYXRpb25zLmJ1bmRsZS5kLnRzYCB3aWxsIGVuZCB1cCBiZWluZ1xuICAgIC8vIGNvcGllZCBpbnRvIGA8cGtnLW91dD4vYW5pbWF0aW9ucy5kLnRzYC4gTm90aWNlIGhvdyB0aGUgYC5idW5kbGVgIHN1ZmZpeFxuICAgIC8vIGhhcyBiZWVuIHJlbW92ZWQuIFRoZSBgbmdfbW9kdWxlYCBhcHBlbmRzIHRoaXMgdG8gYXZvaWQgY29uZmxpY3RzIHdpdGggdGhlXG4gICAgLy8gYWN0dWFsIHR5cGluZ3MgZmlsZXMgYmVpbmcgZ2VuZXJhdGVkIGJ5IHRoZSBUUy9Bbmd1bGFyIGNvbXBpbGF0aW9uLlxuICAgIGNvbnN0IG91dHB1dFJlbGF0aXZlUGF0aCA9XG4gICAgICAgIGdldFR5cGluZ091dHB1dFJlbGF0aXZlUGF0aChidW5kbGVEdHNGaWxlKS5yZXBsYWNlKGR0c0J1bmRsZUZpbGVTdWZmaXgsICcuZC50cycpO1xuICAgIC8vIEFQSSBleHRyYWN0b3Igd2lsbCBub3QgZGVkdXBlIGxpY2Vuc2UgY29tbWVudHMgZnJvbSB2YXJpb3VzIGZpbGVzXG4gICAgLy8gdGhpcyB3aWxsIHJlbW92ZSBhbGwgdGhlIGxpY2Vuc2UgY29tbWVudHMgYW5kIGFwcGVuZCB0aGUgbGljZW5zZSBiYW5uZXIuXG4gICAgY29uc3QgY29udGVudCA9IGxpY2Vuc2VCYW5uZXIgKyAnXFxuJyArXG4gICAgICAgIHJlYWRUeXBpbmdzQW5kU3RyaXBBbWRNb2R1bGUoYnVuZGxlRHRzRmlsZS5wYXRoKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyhcXC9cXCpcXCpcXHMrXFwqXFxzXFxAbGljZW5zZSgoKD8hXFwqXFwvKS58XFxzKSopXFwqXFwvKS9nbSwgJycpO1xuXG4gICAgd3JpdGVGaWxlKG91dHB1dFJlbGF0aXZlUGF0aCwgY29udGVudCk7XG4gIH0pO1xuXG4gIGNvbnN0IG1vZHVsZXNXaXRoRXhpc3RpbmdQYWNrYWdlSnNvbiA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gIGZvciAoY29uc3QgZmlsZSBvZiBzdGF0aWNGaWxlcykge1xuICAgIC8vIFdlIGNvcHkgYWxsIGZpbGVzIGludG8gdGhlIHBhY2thZ2Ugb3V0cHV0IHdoaWxlIHByZXNlcnZpbmcgdGhlIHN1Yi1wYXRoIGZyb21cbiAgICAvLyB0aGUgb3duaW5nIHBhY2thZ2UuIGUuZy4gYHBhY2thZ2VzL2NvcmUvcGFja2FnZS5qc29uYCBlbmRzIHVwIGA8cGtnLW91dD4vcGFja2FnZS5qc29uYC5cbiAgICBjb25zdCBvdXRwdXRSZWxhdGl2ZVBhdGggPSBnZXRPd25pbmdQYWNrYWdlUmVsYXRpdmVQYXRoKGZpbGUpO1xuICAgIGxldCBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKGZpbGUucGF0aCwgJ3V0ZjgnKTtcblxuICAgIC8vIE1vZGlmeSBwYWNrYWdlLmpzb24gZmlsZXMgYXMgbmVjZXNzYXJ5IGZvciBwdWJsaXNoaW5nXG4gICAgaWYgKHBhdGguYmFzZW5hbWUoZmlsZS5wYXRoKSA9PT0gJ3BhY2thZ2UuanNvbicpIHtcbiAgICAgIGNvbnN0IGlzUHJpbWFyeVBhY2thZ2VKc29uID0gb3V0cHV0UmVsYXRpdmVQYXRoID09PSAncGFja2FnZS5qc29uJztcbiAgICAgIGNvbnN0IHBhY2thZ2VKc29uID0gSlNPTi5wYXJzZShjb250ZW50KSBhcyBQYWNrYWdlSnNvbjtcbiAgICAgIGNvbnN0IHBhY2thZ2VOYW1lID0gcGFja2FnZUpzb25bJ25hbWUnXTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGBuYW1lYCBmaWVsZCBvZiB0aGUgYHBhY2thZ2UuanNvbmAgZmlsZXMgYXJlIG1hdGNoaW5nIHdpdGhcbiAgICAgIC8vIG5hbWUgb2YgdGhlIE5QTSBwYWNrYWdlLiBUaGlzIGlzIGFuIGFkZGl0aW9uYWwgc2FmZXR5IGNoZWNrLlxuICAgICAgaWYgKGlzUHJpbWFyeVBhY2thZ2VKc29uICYmIHBhY2thZ2VOYW1lICE9PSBtZXRhZGF0YS5ucG1QYWNrYWdlTmFtZSkge1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIGBQcmltYXJ5IFwicGFja2FnZS5qc29uXCIgaGFzIG1pc21hdGNoaW5nIHBhY2thZ2UgbmFtZS4gRXhwZWN0ZWQgdGhlIGAgK1xuICAgICAgICAgICAgYHBhY2thZ2UgdG8gYmUgbmFtZWQgXCIke21ldGFkYXRhLm5wbVBhY2thZ2VOYW1lfVwiLCBidXQgaXMgc2V0IHRvOiAke3BhY2thZ2VOYW1lfS5gKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc1ByaW1hcnlQYWNrYWdlSnNvbiAmJiAhcGFja2FnZU5hbWUuc3RhcnRzV2l0aChgJHttZXRhZGF0YS5ucG1QYWNrYWdlTmFtZX0vYCkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBgRm91bmQgYSBcInBhY2thZ2UuanNvblwiIHdoaWNoIGRvZXMgbm90IHN0YXJ0IHdpdGggdGhlIG5hbWUgb2YgdGhlIHByaW1hcnkgYCArXG4gICAgICAgICAgICBgZW50cnktcG9pbnQuIFNlY29uZGFyeSBlbnRyeS1wb2ludHMgbmVlZCB0byBzdGFydCB3aXRoIFwiJHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YS5ucG1QYWNrYWdlTmFtZX0vXCIsIGAgK1xuICAgICAgICAgICAgYGJ1dCBpcyBzZXQgdG86ICR7cGFja2FnZU5hbWV9LmApO1xuICAgICAgfVxuXG4gICAgICBsZXQgbmV3UGFja2FnZUpzb24gPVxuICAgICAgICAgIGluc2VydEZvcm1hdEZpZWxkc0ludG9QYWNrYWdlSnNvbihvdXRwdXRSZWxhdGl2ZVBhdGgsIHBhY2thZ2VKc29uLCBmYWxzZSk7XG5cbiAgICAgIGlmIChpc1ByaW1hcnlQYWNrYWdlSnNvbikge1xuICAgICAgICBuZXdQYWNrYWdlSnNvbiA9IHVwZGF0ZVByaW1hcnlQYWNrYWdlSnNvbihuZXdQYWNrYWdlSnNvbik7XG4gICAgICB9XG5cbiAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIG1vZHVsZXMgd2UgaGF2ZSBgcGFja2FnZS5qc29uYCBmaWxlcyBwcm92aWRlZCBhcyBwYXJ0IG9mXG4gICAgICAvLyB0aGUgc291cmNlcy4gV2UgdXNlIHRoaXMgbGF0ZXIgdG8gc2tpcCBnZW5lcmF0aW9uIG9mIGBwYWNrYWdlLmpzb25gIGZpbGVzXG4gICAgICAvLyBmb3IgdGhlIG1vZHVsZXMgdGhlIGNvbnN1bWVyIGFscmVhZHkgY3JlYXRlZCBhIGZpbGUuXG4gICAgICBtb2R1bGVzV2l0aEV4aXN0aW5nUGFja2FnZUpzb24uYWRkKHBhY2thZ2VOYW1lKTtcblxuICAgICAgLy8gVXBkYXRlIHRoZSBjb250ZW50IHdpdGggdGhlIG5ldyBgcGFja2FnZS5qc29uYCBmaWxlIGNvbnRlbnQuXG4gICAgICBjb250ZW50ID0gSlNPTi5zdHJpbmdpZnkobmV3UGFja2FnZUpzb24sIG51bGwsIDIpO1xuICAgIH1cblxuICAgIHdyaXRlRmlsZShvdXRwdXRSZWxhdGl2ZVBhdGgsIGNvbnRlbnQpO1xuICB9XG5cbiAgLy8gR2VuZXJhdGUgZXh0cmEgZmlsZXMgZm9yIHNlY29uZGFyeSBlbnRyeS1wb2ludHMuXG4gIE9iamVjdC5rZXlzKG1ldGFkYXRhLmVudHJ5UG9pbnRzKS5mb3JFYWNoKG1vZHVsZU5hbWUgPT4ge1xuICAgIGlmICghaXNTZWNvbmRhcnlFbnRyeVBvaW50KG1vZHVsZU5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSBgcGFja2FnZS5qc29uYCBhbHJlYWR5IGRlZmluZWQgYXMgcGFydCBvZiB0aGUgc291cmNlcyxcbiAgICAvLyBza2lwIGdlbmVyYXRpb24gb2YgdGhlIHNlY29uZGFyeSBgcGFja2FnZS5qc29uYCBmaWxlLlxuICAgIGlmIChtb2R1bGVzV2l0aEV4aXN0aW5nUGFja2FnZUpzb24uaGFzKG1vZHVsZU5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcGFja2FnZUpzb25EaXIgPSBnZXRFbnRyeVBvaW50U3VicGF0aChtb2R1bGVOYW1lKTtcbiAgICBjcmVhdGVTZWNvbmRhcnlFbnRyeVBvaW50UGFja2FnZUpzb24ocGFja2FnZUpzb25EaXIsIG1vZHVsZU5hbWUpO1xuICB9KTtcblxuICAvKipcbiAgICogSW5zZXJ0cyBvciBlZGl0cyBwcm9wZXJ0aWVzIGludG8gdGhlIHBhY2thZ2UuanNvbiBmaWxlKHMpIGluIHRoZSBwYWNrYWdlIHNvIHRoYXRcbiAgICogdGhleSBwb2ludCB0byBhbGwgdGhlIHJpZ2h0IGdlbmVyYXRlZCBhcnRpZmFjdHMuXG4gICAqXG4gICAqIEBwYXJhbSBwYWNrYWdlSnNvbk91dFJlbGF0aXZlUGF0aCBQYXRoIHdoZXJlIHRoZSBgcGFja2FnZS5qc29uYCBpcyBzdG9yZWQgaW5cbiAgICogICB0aGUgcGFja2FnZSBvdXRwdXQuXG4gICAqIEBwYXJhbSBwYXJzZWRQYWNrYWdlIFBhcnNlZCBwYWNrYWdlLmpzb24gY29udGVudFxuICAgKiBAcGFyYW0gaXNHZW5lcmF0ZWRQYWNrYWdlSnNvbiBXaGV0aGVyIHRoZSBwYXNzZWQgcGFja2FnZS5qc29uIGhhcyBiZWVuIGdlbmVyYXRlZC5cbiAgICovXG4gIGZ1bmN0aW9uIGluc2VydEZvcm1hdEZpZWxkc0ludG9QYWNrYWdlSnNvbihcbiAgICAgIHBhY2thZ2VKc29uT3V0UmVsYXRpdmVQYXRoOiBzdHJpbmcsIHBhcnNlZFBhY2thZ2U6IFJlYWRvbmx5PFBhY2thZ2VKc29uPixcbiAgICAgIGlzR2VuZXJhdGVkUGFja2FnZUpzb246IGJvb2xlYW4pOiBQYWNrYWdlSnNvbiB7XG4gICAgY29uc3QgcGFja2FnZUpzb246IFBhY2thZ2VKc29uID0gey4uLnBhcnNlZFBhY2thZ2V9O1xuICAgIGNvbnN0IHBhY2thZ2VOYW1lID0gcGFja2FnZUpzb25bJ25hbWUnXTtcbiAgICBjb25zdCBlbnRyeVBvaW50SW5mbyA9IG1ldGFkYXRhLmVudHJ5UG9pbnRzW3BhY2thZ2VOYW1lXTtcbiAgICBjb25zdCBwYWNrYWdlSnNvbkNvbnRhaW5pbmdEaXIgPSBwYXRoLmRpcm5hbWUocGFja2FnZUpzb25PdXRSZWxhdGl2ZVBhdGgpO1xuXG4gICAgLy8gSWYgYSBwYWNrYWdlIGpzb24gZmlsZSBoYXMgYmVlbiBkaXNjb3ZlcmVkIHRoYXQgZG9lcyBub3QgbWF0Y2ggYW55XG4gICAgLy8gZW50cnktcG9pbnQgaW4gdGhlIG1ldGFkYXRhLCB3ZSByZXBvcnQgYSB3YXJuaW5nIGFzIG1vc3QgbGlrZWx5IHRoZSB0YXJnZXRcbiAgICAvLyBpcyBjb25maWd1cmVkIGluY29ycmVjdGx5IChlLmcuIG1pc3NpbmcgYG1vZHVsZV9uYW1lYCBhdHRyaWJ1dGUpLlxuICAgIGlmICghZW50cnlQb2ludEluZm8pIHtcbiAgICAgIC8vIElkZWFsbHkgd2Ugc2hvdWxkIHRocm93IGhlcmUsIGFzIHdlIGdvdCBhbiBlbnRyeSBwb2ludCB0aGF0IGRvZXNuJ3RcbiAgICAgIC8vIGhhdmUgZmxhdCBtb2R1bGUgbWV0YWRhdGEgLyBidW5kbGUgaW5kZXgsIHNvIGl0IG1heSBoYXZlIGJlZW4gYW5cbiAgICAgIC8vIG5nX21vZHVsZSB0aGF0J3MgbWlzc2luZyBhIG1vZHVsZV9uYW1lIGF0dHJpYnV0ZS5cbiAgICAgIC8vIEhvd2V2ZXIsIEBhbmd1bGFyL2NvbXBpbGVyIGNhbid0IGJlIGFuIG5nX21vZHVsZSwgYXMgaXQncyB0aGUgaW50ZXJuYWxzXG4gICAgICAvLyBvZiB0aGUgbmdjIGNvbXBpbGVyLCB5ZXQgd2Ugd2FudCB0byBidWlsZCBhbiBuZ19wYWNrYWdlIGZvciBpdC5cbiAgICAgIC8vIFNvIGlnbm9yZSBwYWNrYWdlLmpzb24gZmlsZXMgd2hlbiB3ZSBhcmUgbWlzc2luZyBkYXRhLlxuICAgICAgY29uc29sZS5lcnJvcignV0FSTklORzogbm8gbW9kdWxlIG1ldGFkYXRhIGZvciBwYWNrYWdlJywgcGFja2FnZU5hbWUpO1xuICAgICAgY29uc29sZS5lcnJvcignICAgTm90IHVwZGF0aW5nIHRoZSBwYWNrYWdlLmpzb24gZmlsZSB0byBwb2ludCB0byBpdCcpO1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAnICAgVGhlIG5nX21vZHVsZSBmb3IgdGhpcyBwYWNrYWdlIGlzIHBvc3NpYmx5IG1pc3NpbmcgdGhlIG1vZHVsZV9uYW1lIGF0dHJpYnV0ZSAnKTtcbiAgICAgIHJldHVybiBwYWNrYWdlSnNvbjtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBndWVzc2VkIHRoZSBpbmRleCBwYXRocyBmb3IgYSBtb2R1bGUsIGFuZCBpdCBjb250YWlucyBhbiBleHBsaWNpdCBgcGFja2FnZS5qc29uYFxuICAgIC8vIGZpbGUgdGhhdCBhbHJlYWR5IHNldHMgZm9ybWF0IHByb3BlcnRpZXMsIHdlIHNraXAgYXV0b21hdGljIGluc2VydGlvbiBvZiBmb3JtYXRcbiAgICAvLyBwcm9wZXJ0aWVzIGJ1dCByZXBvcnQgYSB3YXJuaW5nIGluIGNhc2UgcHJvcGVydGllcyBoYXZlIGJlZW4gc2V0IGJ5IGFjY2lkZW50LlxuICAgIGlmIChlbnRyeVBvaW50SW5mby5ndWVzc2VkUGF0aHMgJiYgIWlzR2VuZXJhdGVkUGFja2FnZUpzb24gJiZcbiAgICAgICAgaGFzRXhwbGljaXRGb3JtYXRQcm9wZXJ0aWVzKHBhY2thZ2VKc29uKSkge1xuICAgICAgY29uc29sZS5lcnJvcignV0FSTklORzogYHBhY2thZ2UuanNvbmAgZXhwbGljaXRseSBzZXRzIGZvcm1hdCBwcm9wZXJ0aWVzIChsaWtlIGBtYWluYCkuJyk7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICcgICAgU2tpcHBpbmcgYXV0b21hdGljIGluc2VydGlvbiBvZiBmb3JtYXQgcHJvcGVydGllcyBhcyBleHBsaWNpdCAnICtcbiAgICAgICAgICAnZm9ybWF0IHByb3BlcnRpZXMgYXJlIHNldC4nKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyAgICBJZ25vcmUgdGhpcyB3YXJuaW5nIGlmIGV4cGxpY2l0IHByb3BlcnRpZXMgYXJlIHNldCBpbnRlbnRpb25hbGx5LicpO1xuICAgICAgcmV0dXJuIHBhY2thZ2VKc29uO1xuICAgIH1cblxuICAgIGNvbnN0IGZlc20yMDIwUmVsYXRpdmVPdXRQYXRoID0gZ2V0RmxhdEVzbU91dHB1dFJlbGF0aXZlUGF0aChlbnRyeVBvaW50SW5mby5mZXNtMjAyMEJ1bmRsZSk7XG4gICAgY29uc3QgZmVzbTIwMTVSZWxhdGl2ZU91dFBhdGggPSBnZXRGbGF0RXNtT3V0cHV0UmVsYXRpdmVQYXRoKGVudHJ5UG9pbnRJbmZvLmZlc20yMDE1QnVuZGxlKTtcbiAgICBjb25zdCBlc20yMDIwUmVsYXRpdmVPdXRQYXRoID0gZ2V0RXNtMjAyME91dHB1dFJlbGF0aXZlUGF0aChlbnRyeVBvaW50SW5mby5pbmRleCk7XG4gICAgY29uc3QgdHlwaW5nc1JlbGF0aXZlT3V0UGF0aCA9IGdldFR5cGluZ091dHB1dFJlbGF0aXZlUGF0aChlbnRyeVBvaW50SW5mby50eXBpbmdzKTtcblxuICAgIHBhY2thZ2VKc29uLmZlc20yMDIwID1cbiAgICAgICAgbm9ybWFsaXplUGF0aChwYXRoLnJlbGF0aXZlKHBhY2thZ2VKc29uQ29udGFpbmluZ0RpciwgZmVzbTIwMjBSZWxhdGl2ZU91dFBhdGgpKTtcbiAgICBwYWNrYWdlSnNvbi5mZXNtMjAxNSA9XG4gICAgICAgIG5vcm1hbGl6ZVBhdGgocGF0aC5yZWxhdGl2ZShwYWNrYWdlSnNvbkNvbnRhaW5pbmdEaXIsIGZlc20yMDE1UmVsYXRpdmVPdXRQYXRoKSk7XG4gICAgcGFja2FnZUpzb24uZXNtMjAyMCA9XG4gICAgICAgIG5vcm1hbGl6ZVBhdGgocGF0aC5yZWxhdGl2ZShwYWNrYWdlSnNvbkNvbnRhaW5pbmdEaXIsIGVzbTIwMjBSZWxhdGl2ZU91dFBhdGgpKTtcbiAgICBwYWNrYWdlSnNvbi50eXBpbmdzID1cbiAgICAgICAgbm9ybWFsaXplUGF0aChwYXRoLnJlbGF0aXZlKHBhY2thZ2VKc29uQ29udGFpbmluZ0RpciwgdHlwaW5nc1JlbGF0aXZlT3V0UGF0aCkpO1xuXG4gICAgLy8gRm9yIG5vdywgd2UgcG9pbnQgdGhlIHByaW1hcnkgZW50cnkgcG9pbnRzIGF0IHRoZSBmZXNtIGZpbGVzLCBiZWNhdXNlIG9mIFdlYnBhY2tcbiAgICAvLyBwZXJmb3JtYW5jZSBpc3N1ZXMgd2l0aCBhIGxhcmdlIG51bWJlciBvZiBpbmRpdmlkdWFsIGZpbGVzLlxuICAgIHBhY2thZ2VKc29uLm1vZHVsZSA9IHBhY2thZ2VKc29uLmZlc20yMDE1O1xuICAgIHBhY2thZ2VKc29uLmVzMjAyMCA9IHBhY2thZ2VKc29uLmZlc20yMDIwO1xuXG4gICAgcmV0dXJuIHBhY2thZ2VKc29uO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHByaW1hcnkgYHBhY2thZ2UuanNvbmAgZmlsZSBvZiB0aGUgTlBNIHBhY2thZ2UgdG8gc3BlY2lmeVxuICAgKiB0aGUgbW9kdWxlIGNvbmRpdGlvbmFsIGV4cG9ydHMgYW5kIHRoZSBFU00gbW9kdWxlIHR5cGUuXG4gICAqL1xuICBmdW5jdGlvbiB1cGRhdGVQcmltYXJ5UGFja2FnZUpzb24ocGFja2FnZUpzb246IFJlYWRvbmx5PFBhY2thZ2VKc29uPik6IFBhY2thZ2VKc29uIHtcbiAgICBpZiAocGFja2FnZUpzb24udHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAnVGhlIHByaW1hcnkgXCJwYWNrYWdlLmpzb25cIiBmaWxlIG9mIHRoZSBwYWNrYWdlIHNldHMgdGhlIFwidHlwZVwiIGZpZWxkICcgK1xuICAgICAgICAgICd0aGF0IGlzIGNvbnRyb2xsZWQgYnkgdGhlIHBhY2thZ2VyLiBQbGVhc2UgdW5zZXQgaXQuJyk7XG4gICAgfVxuXG4gICAgY29uc3QgbmV3UGFja2FnZUpzb246IFBhY2thZ2VKc29uID0gey4uLnBhY2thZ2VKc29ufTtcblxuICAgIG5ld1BhY2thZ2VKc29uLnR5cGUgPSAnbW9kdWxlJztcblxuICAgIC8vIFRoZSBgcGFja2FnZS5qc29uYCBmaWxlIGlzIG1hZGUgcHVibGljbHkgYWNjZXNzaWJsZSBmb3IgdG9vbHMgdGhhdFxuICAgIC8vIG1pZ2h0IHdhbnQgdG8gcXVlcnkgaW5mb3JtYXRpb24gZnJvbSB0aGUgQW5ndWxhciBOUE0gcGFja2FnZS5cbiAgICBpbnNlcnRFeHBvcnRNYXBwaW5nT3JFcnJvcihuZXdQYWNrYWdlSnNvbiwgJy4vcGFja2FnZS5qc29uJywge2RlZmF1bHQ6ICcuL3BhY2thZ2UuanNvbid9KTtcblxuICAgIC8vIENhcHR1cmUgYWxsIGVudHJ5LXBvaW50cyBpbiB0aGUgYGV4cG9ydHNgIGZpZWxkIHVzaW5nIHRoZSBzdWJwYXRoIGV4cG9ydCBkZWNsYXJhdGlvbnM6XG4gICAgLy8gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9wYWNrYWdlcy5odG1sI3BhY2thZ2VzX3N1YnBhdGhfZXhwb3J0cy5cbiAgICBmb3IgKGNvbnN0IFttb2R1bGVOYW1lLCBlbnRyeVBvaW50XSBvZiBPYmplY3QuZW50cmllcyhtZXRhZGF0YS5lbnRyeVBvaW50cykpIHtcbiAgICAgIGNvbnN0IHN1YnBhdGggPVxuICAgICAgICAgIGlzU2Vjb25kYXJ5RW50cnlQb2ludChtb2R1bGVOYW1lKSA/IGAuLyR7Z2V0RW50cnlQb2ludFN1YnBhdGgobW9kdWxlTmFtZSl9YCA6ICcuJztcbiAgICAgIGNvbnN0IGVzbTIwMjBJbmRleE91dFJlbGF0aXZlUGF0aCA9IGdldEVzbTIwMjBPdXRwdXRSZWxhdGl2ZVBhdGgoZW50cnlQb2ludC5pbmRleCk7XG4gICAgICBjb25zdCBmZXNtMjAyME91dFJlbGF0aXZlUGF0aCA9IGdldEZsYXRFc21PdXRwdXRSZWxhdGl2ZVBhdGgoZW50cnlQb2ludC5mZXNtMjAyMEJ1bmRsZSk7XG4gICAgICBjb25zdCBmZXNtMjAxNU91dFJlbGF0aXZlUGF0aCA9IGdldEZsYXRFc21PdXRwdXRSZWxhdGl2ZVBhdGgoZW50cnlQb2ludC5mZXNtMjAxNUJ1bmRsZSk7XG4gICAgICBjb25zdCB0eXBlc091dFJlbGF0aXZlUGF0aCA9IGdldFR5cGluZ091dHB1dFJlbGF0aXZlUGF0aChlbnRyeVBvaW50LnR5cGluZ3MpO1xuXG4gICAgICAvLyBJbnNlcnQgdGhlIGV4cG9ydCBtYXBwaW5nIGZvciB0aGUgZW50cnktcG9pbnQuIFdlIHNldCBgZGVmYXVsdGAgdG8gdGhlIEZFU00gMjAyMFxuICAgICAgLy8gb3V0cHV0LCBhbmQgYWxzbyBzZXQgdGhlIGB0eXBlc2AgY29uZGl0aW9uIHdoaWNoIHdpbGwgYmUgcmVzcGVjdGVkIGJ5IFRTIDQuNS5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9wdWxsLzQ1ODg0LlxuICAgICAgaW5zZXJ0RXhwb3J0TWFwcGluZ09yRXJyb3IobmV3UGFja2FnZUpzb24sIHN1YnBhdGgsIHtcbiAgICAgICAgdHlwZXM6IG5vcm1hbGl6ZVBhdGgodHlwZXNPdXRSZWxhdGl2ZVBhdGgpLFxuICAgICAgICBlc20yMDIwOiBub3JtYWxpemVQYXRoKGVzbTIwMjBJbmRleE91dFJlbGF0aXZlUGF0aCksXG4gICAgICAgIGVzMjAyMDogbm9ybWFsaXplUGF0aChmZXNtMjAyME91dFJlbGF0aXZlUGF0aCksXG4gICAgICAgIC8vIFdlIGFsc28gZXhwb3NlIGEgbm9uLXN0YW5kYXJkIGNvbmRpdGlvbiB0aGF0IHdvdWxkIGFsbG93IGNvbnN1bWVycyB0byByZXNvbHZlXG4gICAgICAgIC8vIHRvIHRoZSBgRVMyMDE1YCBvdXRwdXQgb3V0c2lkZSBvZiBOb2RlSlMsIGlmIGRlc2lyZWQuXG4gICAgICAgIC8vIFRPRE8oZGV2dmVyc2lvbik6IHJlbW92ZS9yZXBsYWNlIHRoaXMgaWYgTm9kZUpTIHYxMiBpcyBubyBsb25nZXIgc3VwcG9ydGVkLlxuICAgICAgICBlczIwMTU6IG5vcm1hbGl6ZVBhdGgoZmVzbTIwMTVPdXRSZWxhdGl2ZVBhdGgpLFxuICAgICAgICAvLyBXZSBkZWNsYXJlIHRoZSBgbm9kZWAgY29uZGl0aW9uIGFuZCBwb2ludCB0byB0aGUgRVMyMDE1IG91dHB1dCBhcyB3ZSBjdXJyZW50bHkgc3RpbGxcbiAgICAgICAgLy8gc3VwcG9ydCBOb2RlSlMgdjEyIHdoaWNoIGRvZXMgbm90IGZ1bGx5IHN1cHBvcnQgRVMyMDIwIG91dHB1dC4gV2UgY2hvc2UgRVMyMDE1IG92ZXJcbiAgICAgICAgLy8gRVMyMDIwIGJlY2F1c2Ugd2Ugd2FuIGFzeW5jL2F3YWl0IGRvd25sZXZlbGVkIGFzIHRoaXMgYWxsb3dzIGZvciBwYXRjaGluZyB3aXRoWm9uZUpTLlxuICAgICAgICAvLyBUT0RPKGRldnZlcnNpb24pOiByZW1vdmUvcmVwbGFjZSB0aGlzIGlmIE5vZGVKUyB2MTIgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC5cbiAgICAgICAgbm9kZTogbm9ybWFsaXplUGF0aChmZXNtMjAxNU91dFJlbGF0aXZlUGF0aCksXG4gICAgICAgIC8vIE5vdGU6IFRoZSBkZWZhdWx0IGNvbmRpdGlvbnMgbmVlZHMgdG8gYmUgdGhlIGxhc3Qgb25lLlxuICAgICAgICBkZWZhdWx0OiBub3JtYWxpemVQYXRoKGZlc20yMDIwT3V0UmVsYXRpdmVQYXRoKSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdQYWNrYWdlSnNvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIGEgc3VicGF0aCBleHBvcnQgbWFwcGluZyBpbnRvIHRoZSBzcGVjaWZpZWQgYHBhY2thZ2UuanNvbmAgb2JqZWN0LlxuICAgKiBAdGhyb3dzIEFuIGVycm9yIGlmIHRoZSBtYXBwaW5nIGlzIGFscmVhZHkgZGVmaW5lZCBhbmQgd291bGQgY29uZmxpY3QuXG4gICAqL1xuICBmdW5jdGlvbiBpbnNlcnRFeHBvcnRNYXBwaW5nT3JFcnJvcihcbiAgICAgIHBhY2thZ2VKc29uOiBQYWNrYWdlSnNvbiwgc3VicGF0aDogc3RyaW5nLCBtYXBwaW5nOiBDb25kaXRpb25hbEV4cG9ydCkge1xuICAgIGlmIChwYWNrYWdlSnNvbi5leHBvcnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhY2thZ2VKc29uLmV4cG9ydHMgPSB7fTtcbiAgICB9XG4gICAgaWYgKHBhY2thZ2VKc29uLmV4cG9ydHNbc3VicGF0aF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcGFja2FnZUpzb24uZXhwb3J0c1tzdWJwYXRoXSA9IHt9O1xuICAgIH1cblxuICAgIGNvbnN0IHN1YnBhdGhFeHBvcnQgPSBwYWNrYWdlSnNvbi5leHBvcnRzW3N1YnBhdGhdO1xuXG4gICAgLy8gR28gdGhyb3VnaCBhbGwgY29uZGl0aW9ucyB0aGF0IHNob3VsZCBiZSBpbnNlcnRlZC4gSWYgdGhlIGNvbmRpdGlvbiBpcyBhbHJlYWR5XG4gICAgLy8gbWFudWFsbHkgc2V0IG9mIHRoZSBzdWJwYXRoIGV4cG9ydCwgd2UgdGhyb3cgYW4gZXJyb3IuIEluIGdlbmVyYWwsIHdlIGFsbG93IGZvclxuICAgIC8vIGFkZGl0aW9uYWwgY29uZGl0aW9ucyB0byBiZSBzZXQuIFRoZXNlIHdpbGwgYWx3YXlzIHByZWNlZGUgdGhlIGdlbmVyYXRlZCBvbmVzLlxuICAgIGZvciAoY29uc3QgY29uZGl0aW9uTmFtZSBvZiBPYmplY3Qua2V5cyhtYXBwaW5nKSBhcyBba2V5b2YgQ29uZGl0aW9uYWxFeHBvcnRdKSB7XG4gICAgICBpZiAoc3VicGF0aEV4cG9ydFtjb25kaXRpb25OYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgYEZvdW5kIGEgY29uZmxpY3RpbmcgZXhwb3J0IGNvbmRpdGlvbiBmb3IgXCIke3N1YnBhdGh9XCIuIFRoZSBcIiR7Y29uZGl0aW9uTmFtZX1cIiBgICtcbiAgICAgICAgICAgIGBjb25kaXRpb24gd291bGQgYmUgb3ZlcnJpZGRlbiBieSB0aGUgcGFja2FnZXIuIFBsZWFzZSB1bnNldCBpdC5gKTtcbiAgICAgIH1cblxuICAgICAgLy8gKipOb3RlKio6IFRoZSBvcmRlciBvZiB0aGUgY29uZGl0aW9ucyBpcyBwcmVzZXJ2ZWQgZXZlbiB0aG91Z2ggd2UgYXJlIHNldHRpbmdcbiAgICAgIC8vIHRoZSBjb25kaXRpb25zIG9uY2UgYXQgYSB0aW1lICh0aGUgbGF0ZXN0IGFzc2lnbm1lbnQgd2lsbCBiZSBhdCB0aGUgZW5kKS5cbiAgICAgIHN1YnBhdGhFeHBvcnRbY29uZGl0aW9uTmFtZV0gPSBtYXBwaW5nW2NvbmRpdGlvbk5hbWVdO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBXaGV0aGVyIHRoZSBwYWNrYWdlIGV4cGxpY2l0bHkgc2V0cyBhbnkgb2YgdGhlIGZvcm1hdCBwcm9wZXJ0aWVzIChsaWtlIGBtYWluYCkuICovXG4gIGZ1bmN0aW9uIGhhc0V4cGxpY2l0Rm9ybWF0UHJvcGVydGllcyhwYXJzZWRQYWNrYWdlOiBSZWFkb25seTxQYWNrYWdlSnNvbj4pOiBib29sZWFuIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocGFyc2VkUGFja2FnZSlcbiAgICAgICAgLnNvbWUoXG4gICAgICAgICAgICAoZmllbGROYW1lOiBLbm93blBhY2thZ2VKc29uRm9ybWF0RmllbGRzKSA9PlxuICAgICAgICAgICAgICAgIGtub3duRm9ybWF0UGFja2FnZUpzb25Gb3JtYXRGaWVsZHMuaW5jbHVkZXMoZmllbGROYW1lKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHBhY2thZ2UuanNvbiBmb3IgYSBzZWNvbmRhcnkgZW50cnktcG9pbnQuXG4gICAqIEBwYXJhbSBkaXIgVGhlIGRpcmVjdG9yeSB1bmRlciB3aGljaCB0aGUgcGFja2FnZS5qc29uIHNob3VsZCBiZSB3cml0dGVuLlxuICAgKiBAcGFyYW0gZW50cnlQb2ludFBhY2thZ2VOYW1lIFRoZSBmdWxsIHBhY2thZ2UgbmFtZSBmb3IgdGhlIGVudHJ5IHBvaW50LFxuICAgKiAgICAgZS5nLiAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnLlxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlU2Vjb25kYXJ5RW50cnlQb2ludFBhY2thZ2VKc29uKGRpcjogc3RyaW5nLCBlbnRyeVBvaW50UGFja2FnZU5hbWU6IHN0cmluZykge1xuICAgIGNvbnN0IHJlbGF0aXZlT3V0UGF0aCA9IHBhdGguam9pbihkaXIsICdwYWNrYWdlLmpzb24nKTtcbiAgICBjb25zdCBjb250ZW50ID1cbiAgICAgICAgaW5zZXJ0Rm9ybWF0RmllbGRzSW50b1BhY2thZ2VKc29uKHJlbGF0aXZlT3V0UGF0aCwge25hbWU6IGVudHJ5UG9pbnRQYWNrYWdlTmFtZX0sIHRydWUpO1xuICAgIHdyaXRlRmlsZShyZWxhdGl2ZU91dFBhdGgsIEpTT04uc3RyaW5naWZ5KGNvbnRlbnQsIG51bGwsIDIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemVzIHRoZSBzcGVjaWZpZWQgcGF0aCBieSByZXBsYWNpbmcgYmFja3NsYXNoIHNlcGFyYXRvcnMgd2l0aCBQb3NpeFxuICAgKiBmb3J3YXJkIHNsYXNoIHNlcGFyYXRvcnMuXG4gICAqL1xuICBmdW5jdGlvbiBub3JtYWxpemVQYXRoKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgcmVzdWx0ID0gcGF0aC5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG4gICAgcmV0dXJuIHJlc3VsdC5zdGFydHNXaXRoKCcuJykgPyByZXN1bHQgOiBgLi8ke3Jlc3VsdH1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0cmlwIHRoZSBuYW1lZCBBTUQgbW9kdWxlIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWJhemVsIHVzZXJzIGZyb20gdHlwaW5ncyBjb250ZW50XG4gICAqIEBwYXJhbSBmaWxlUGF0aCBkdHMgZmlsZSBwYXRoXG4gICAqL1xuICBmdW5jdGlvbiByZWFkVHlwaW5nc0FuZFN0cmlwQW1kTW9kdWxlKGZpbGVQYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBmc1xuICAgICAgICAucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCAndXRmLTgnKVxuICAgICAgICAvLyBTdHJpcCB0aGUgbmFtZWQgQU1EIG1vZHVsZSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1iYXplbCB1c2Vyc1xuICAgICAgICAucmVwbGFjZSgvXlxcL1xcL1xcLyA8YW1kLW1vZHVsZSBuYW1lPS4qXFwvPltcXHJcXG5dKy9nbSwgJycpO1xuICB9XG59XG5cbmlmIChyZXF1aXJlLm1haW4gPT09IG1vZHVsZSkge1xuICBtYWluKHByb2Nlc3MuYXJndi5zbGljZSgyKSk7XG59XG4iXX0=