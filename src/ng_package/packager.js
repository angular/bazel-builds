/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("npm_angular_bazel/src/ng_package/packager", ["require", "exports", "fs", "path", "shelljs"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const fs = require("fs");
    const path = require("path");
    const shx = require("shelljs");
    function main(args) {
        // Exit immediately when encountering an error.
        shx.set('-e');
        // Keep track of whether an error has occured so that we can return an appropriate exit code.
        let errorHasOccured = false;
        // This utility expects all of its arguments to be specified in a params file generated by
        // bazel (see https://docs.bazel.build/versions/master/skylark/lib/Args.html#use_param_file).
        const paramFilePath = args[0];
        // Bazel params may be surrounded with quotes
        function unquoteParameter(s) { return s.replace(/^'(.*)'$/, '$1'); }
        // Parameters are specified in the file one per line.
        const params = fs.readFileSync(paramFilePath, 'utf-8').split('\n').map(unquoteParameter);
        const [
        // Output directory for the npm package.
        out, 
        // The package segment of the ng_package rule's label (e.g. 'package/common').
        srcDir, 
        // The bazel-bin dir joined with the srcDir (e.g. 'bazel-bin/package.common').
        // This is the intended output location for package artifacts.
        binDir, 
        // The bazel-genfiles dir joined with the srcDir (e.g. 'bazel-bin/package.common').
        genfilesDir, 
        // JSON data mapping each entry point to the generated bundle index and
        // flat module metadata, for example
        // {"@angular/core": {
        //     "index": "bazel-bin/packages/core/core.js",
        //     "typings": "bazel-bin/packages/core/core.d.ts",
        //     "metadata": "bazel-bin/packages/core/core.metadata.json"
        //  },
        // ...
        // }
        modulesManifestArg, 
        // Path to the package's README.md.
        readmeMd, 
        // List of rolled-up flat ES2015 modules
        fesm2015Arg, 
        // List of rolled-up flat ES5 modules
        fesm5Arg, 
        // List of individual ES2015 modules
        esm2015Arg, 
        // List of individual ES5 modules
        esm5Arg, 
        // List of all UMD bundles generated by rollup.
        bundlesArg, 
        // List of all files in the ng_package rule's srcs.
        srcsArg, 
        // List of all type definitions that need to packaged into the ng_package.
        typeDefinitionsArg, 
        // List of all files in the ng_package rule's data.
        dataArg, 
        // Path to the package's LICENSE.
        licenseFile, 
        // List of all dts bundles generated by the API extractor.
        dtsBundleArg, 
        // The dts bundle file suffix example: '.bundle.d.ts'
        dtsBundleFileSuffix,] = params;
        const fesm2015 = fesm2015Arg.split(',').filter(s => !!s);
        const fesm5 = fesm5Arg.split(',').filter(s => !!s);
        const esm2015 = esm2015Arg.split(',').filter(s => !!s);
        const esm5 = esm5Arg.split(',').filter(s => !!s);
        const bundles = bundlesArg.split(',').filter(s => !!s);
        const typeDefinitions = typeDefinitionsArg.split(',').filter(s => !!s);
        const srcs = srcsArg.split(',').filter(s => !!s);
        const dataFiles = dataArg.split(',').filter(s => !!s);
        const modulesManifest = JSON.parse(modulesManifestArg);
        const dtsBundles = dtsBundleArg.split(',').filter(s => !!s);
        if (readmeMd) {
            copyFile(readmeMd, out);
        }
        /**
         * Writes a file into the package based on its input path, relativizing to the package path.
         * @param inputPath Path to the file in the input tree.
         * @param fileContent Content of the file.
         */
        function writeFileFromInputPath(inputPath, fileContent) {
            // We want the relative path from the given file to its ancestor "root" directory.
            // This root depends on whether the file lives in the source tree (srcDir) as a basic file
            // input to ng_package, the bin output tree (binDir) as the output of another rule, or
            // the genfiles output tree (genfilesDir) as the output of a genrule.
            let rootDir;
            if (inputPath.includes(binDir)) {
                rootDir = binDir;
            }
            else if (inputPath.includes(genfilesDir)) {
                rootDir = genfilesDir;
            }
            else {
                rootDir = srcDir;
            }
            const outputPath = path.join(out, path.relative(rootDir, inputPath));
            // Always ensure that the target directory exists.
            shx.mkdir('-p', path.dirname(outputPath));
            fs.writeFileSync(outputPath, fileContent, 'utf-8');
        }
        /**
         * Copies a file into the package based on its input path, relativizing to the package path.
         * @param inputPath a path relative to the binDir, typically from a file in the deps[]
         */
        function copyFileFromInputPath(inputPath) {
            writeFileFromInputPath(inputPath, fs.readFileSync(inputPath, 'utf-8'));
        }
        /**
         * Relativize the path where a file is written.
         * @param file a path containing a re-rooted segment like .esm5 or .es6
         * @param suffix the re-rooted directory
         * @param outDir path where we copy the file, relative to the out
         */
        function writeEsmFile(file, suffix, outDir) {
            // Note that the specified file path is always using the posix path delimiter.
            const root = file.substr(0, file.lastIndexOf(`${suffix}/`) + suffix.length + 1);
            const rel = path.dirname(path.relative(path.join(root, srcDir), file));
            if (!rel.startsWith('..')) {
                copyFile(file, path.join(out, outDir), rel);
            }
        }
        esm2015.forEach(file => writeEsmFile(file, '.es6', 'esm2015'));
        esm5.forEach(file => writeEsmFile(file, '.esm5', 'esm5'));
        bundles.forEach(bundle => { copyFile(bundle, out, 'bundles'); });
        fesm2015.forEach(file => { copyFile(file, out, 'fesm2015'); });
        fesm5.forEach(file => { copyFile(file, out, 'fesm5'); });
        // Copy all type definitions into the package. This is necessary so that developers can use
        // the package with type definitions.
        typeDefinitions.forEach(f => writeFileFromInputPath(f, readTypingsAndStripAmdModule(f)));
        // Copy all `data` files into the package. These are files that aren't built by the ng_package
        // rule, but instead are just straight copied into the package, e.g. global CSS assets.
        dataFiles.forEach(f => copyFileFromInputPath(f));
        // Iterate through the entry point modules
        // We do this first because we also record new paths for the esm5 and esm2015 copies
        // of the index JS file, which we need to amend the package.json.
        Object.keys(modulesManifest).forEach(moduleName => {
            const moduleFiles = modulesManifest[moduleName];
            const relative = path.relative(binDir, moduleFiles['index']);
            moduleFiles['esm5_index'] = path.join(binDir, 'esm5', relative);
            moduleFiles['esm2015_index'] = path.join(binDir, 'esm2015', relative);
            const metadataFile = moduleFiles['metadata'];
            const typingsOutFile = moduleFiles['typings'];
            // We only support all modules within a package to be dts bundled
            // ie: if @angular/common/http has flat dts, so should @angular/common
            if (dtsBundles.length) {
                const metadataContent = rewireMetadata(metadataFile, typingsOutFile);
                writeFileFromInputPath(metadataFile, metadataContent);
            }
            else {
                copyFileFromInputPath(metadataFile);
            }
        });
        const licenseBanner = licenseFile ? fs.readFileSync(licenseFile, 'utf-8') : '';
        dtsBundles.forEach(bundleFile => {
            const cleanDistPath = bundleFile.replace(dtsBundleFileSuffix, '.d.ts');
            // API extractor will not dedupe license comments from various files
            // this will remove all the license comments and append the license banner.
            const content = licenseBanner + '\n' +
                readTypingsAndStripAmdModule(bundleFile)
                    .replace(/(\/\*\*\s+\*\s\@license(((?!\*\/).|\s)*)\*\/)/gm, '');
            writeFileFromInputPath(cleanDistPath, content);
        });
        // Root package name (e.g. '@angular/common'), captures as we iterate through sources below.
        let rootPackageName = '';
        const packagesWithExistingPackageJson = new Set();
        for (const src of srcs) {
            if (src.includes(binDir) || src.includes(genfilesDir)) {
                errorHasOccured = true;
                console.error('The "srcs" for ng_package should not include output of other rules. Found:\n' +
                    `  ${src}`);
            }
            let content = fs.readFileSync(src, 'utf-8');
            // Modify package.json files as necessary for publishing
            if (path.basename(src) === 'package.json') {
                const packageJson = JSON.parse(content);
                content = amendPackageJson(src, packageJson);
                const packageName = packageJson['name'];
                packagesWithExistingPackageJson.add(packageName);
                // Keep track of the root package name, e.g. "@angular/common". We assume that the
                // root name will be shortest because secondary entry-points will append to it
                // (e.g. "@angular/common/http").
                if (!rootPackageName || packageName.length < rootPackageName.length) {
                    rootPackageName = packageJson['name'];
                }
            }
            writeFileFromInputPath(src, content);
        }
        // Generate extra files for secondary entry-points.
        Object.keys(modulesManifest).forEach(entryPointPackageName => {
            const entryPointName = entryPointPackageName.substr(rootPackageName.length + 1);
            if (!entryPointName)
                return;
            createMetadataReexportFile(entryPointName, modulesManifest[entryPointPackageName]['metadata'], entryPointPackageName);
            createTypingsReexportFile(entryPointName, licenseBanner, modulesManifest[entryPointPackageName]['typings']);
            if (!packagesWithExistingPackageJson.has(entryPointPackageName)) {
                createEntryPointPackageJson(entryPointName, entryPointPackageName);
            }
        });
        return errorHasOccured ? 1 : 0;
        /**
         * Convert a binDir-relative path to srcDir-relative
         * @param from path to a file under the srcDir, like packages/core/testing/package.json
         * @param file path to a file under the binDir, like bazel-bin/core/testing/generated.js
         */
        function srcDirRelative(from, file) {
            const result = normalizeSeparators(path.relative(path.dirname(from), path.join(srcDir, path.relative(binDir, file))));
            if (result.startsWith('..'))
                return result;
            return `./${result}`;
        }
        function copyFile(file, baseDir, relative = '.') {
            const dir = path.join(baseDir, relative);
            shx.mkdir('-p', dir);
            shx.cp(file, dir);
            // Double-underscore is used to escape forward slash in FESM filenames.
            // See ng_package.bzl:
            //   fesm_output_filename = entry_point.replace("/", "__")
            // We need to unescape these.
            if (file.indexOf('__') >= 0) {
                const outputPath = path.join(dir, ...path.basename(file).split('__'));
                shx.mkdir('-p', path.dirname(outputPath));
                shx.mv(path.join(dir, path.basename(file)), outputPath);
                // if we are renaming the .js file, we'll also need to update the sourceMappingURL in the file
                if (file.endsWith('.js')) {
                    shx.chmod('+w', outputPath);
                    shx.sed('-i', `${path.basename(file)}.map`, `${path.basename(outputPath)}.map`, outputPath);
                }
            }
        }
        /**
         * Inserts or edits properties into the package.json file(s) in the package so that
         * they point to all the right generated artifacts.
         *
         * @param packageJson The path to the package.json file.
         * @param parsedPackage Parsed package.json content
         */
        function amendPackageJson(packageJson, parsedPackage) {
            const packageName = parsedPackage['name'];
            const moduleFiles = modulesManifest[packageName];
            if (!moduleFiles) {
                // Ideally we should throw here, as we got an entry point that doesn't
                // have flat module metadata / bundle index, so it may have been an
                // ng_module that's missing a module_name attribute.
                // However, @angular/compiler can't be an ng_module, as it's the internals
                // of the ngc compiler, yet we want to build an ng_package for it.
                // So ignore package.json files when we are missing data.
                console.error('WARNING: no module metadata for package', packageName);
                console.error('   Not updating the package.json file to point to it');
                console.error('   The ng_module for this package is possibly missing the module_name attribute ');
                return JSON.stringify(parsedPackage, null, 2);
            }
            // Derive the paths to the files from the hard-coded names we gave them.
            // TODO(alexeagle): it would be better to transfer this information from the place
            // where we created the filenames, via the modulesManifestArg
            parsedPackage['main'] = getBundleName(packageName, 'bundles');
            parsedPackage['fesm5'] = getBundleName(packageName, 'fesm5');
            parsedPackage['fesm2015'] = getBundleName(packageName, 'fesm2015');
            parsedPackage['esm5'] = srcDirRelative(packageJson, moduleFiles['esm5_index']);
            parsedPackage['esm2015'] = srcDirRelative(packageJson, moduleFiles['esm2015_index']);
            parsedPackage['typings'] = srcDirRelative(packageJson, moduleFiles['typings']);
            // For now, we point the primary entry points at the fesm files, because of Webpack
            // performance issues with a large number of individual files.
            // TODO(iminar): resolve performance issues with the toolchain and point these to esm
            parsedPackage['module'] = parsedPackage['fesm5'];
            parsedPackage['es2015'] = parsedPackage['fesm2015'];
            return JSON.stringify(parsedPackage, null, 2);
        }
        // e.g. @angular/common/http/testing -> ../../bundles/common-http-testing.umd.js
        // or   @angular/common/http/testing -> ../../fesm5/http/testing.js
        function getBundleName(packageName, dir) {
            const parts = packageName.split('/');
            // Remove the scoped package part, like @angular if present
            const nameParts = packageName.startsWith('@') ? parts.splice(1) : parts;
            const relativePath = Array(nameParts.length - 1).fill('..').join('/') || '.';
            let basename;
            if (dir === 'bundles') {
                basename = nameParts.join('-') + '.umd';
            }
            else if (nameParts.length === 1) {
                basename = nameParts[0];
            }
            else {
                basename = nameParts.slice(1).join('/');
            }
            return [relativePath, dir, basename + '.js'].join('/');
        }
        /** Creates metadata re-export file for a secondary entry-point. */
        function createMetadataReexportFile(entryPointName, metadataFile, packageName) {
            const inputPath = path.join(srcDir, `${entryPointName}.metadata.json`);
            writeFileFromInputPath(inputPath, JSON.stringify({
                '__symbolic': 'module',
                'version': 3,
                'metadata': {},
                'exports': [{ 'from': `${srcDirRelative(inputPath, metadataFile.replace(/.metadata.json$/, ''))}` }],
                'flatModuleIndexRedirect': true,
                'importAs': packageName
            }) + '\n');
        }
        /**
         * Creates a typings (d.ts) re-export file for a secondary-entry point,
         * e.g., `export * from './common/common'`
         */
        function createTypingsReexportFile(entryPointName, license, typingsFile) {
            const inputPath = path.join(srcDir, `${entryPointName}.d.ts`);
            const content = `${license}
export * from '${srcDirRelative(inputPath, typingsFile.replace(/\.d\.tsx?$/, ''))}';
`;
            writeFileFromInputPath(inputPath, content);
        }
        /**
         * Creates a package.json for a secondary entry-point.
         * @param dir The directory under which the package.json should be written.
         * @param entryPointPackageName The full package name for the entry point,
         *     e.g. '@angular/common/http'.
         */
        function createEntryPointPackageJson(dir, entryPointPackageName) {
            const pkgJson = path.join(srcDir, dir, 'package.json');
            const content = amendPackageJson(pkgJson, { name: entryPointPackageName });
            writeFileFromInputPath(pkgJson, content);
        }
        /**
         * Normalizes the specified path by replacing backslash separators with Posix
         * forward slash separators.
         */
        function normalizeSeparators(path) { return path.replace(/\\/g, '/'); }
        /**
        * Rewires metadata to point to the flattened dts file.
        *
        * @param metadataPath the metadata file path
        * @param typingsPath the typings bundle entrypoint
        */
        function rewireMetadata(metadataPath, typingsPath) {
            const metadata = JSON.parse(fs.readFileSync(metadataPath, 'utf-8'));
            let typingsRelativePath = normalizeSeparators(path.relative(path.dirname(metadataPath), typingsPath));
            if (!typingsRelativePath.startsWith('..')) {
                typingsRelativePath = `./${typingsRelativePath}`;
            }
            typingsRelativePath = typingsRelativePath.replace('.d.ts', '');
            // the regexp here catches all relative paths such as:
            // ./src/core/foo.d.ts and ../src/core/foo.d.ts
            const relativePathRegex = /\.?\.\/[\w\.\-_\/]+/g;
            if (metadata.exports) {
                // Strip re-exports which are now self-references
                metadata.exports =
                    metadata.exports.filter((e) => !e.from.match(relativePathRegex));
            }
            return JSON.stringify(metadata).replace(relativePathRegex, typingsRelativePath);
        }
        /**
         * Strip the named AMD module for compatibility with non-bazel users from typings content
         * @param filePath dts file path
         */
        function readTypingsAndStripAmdModule(filePath) {
            return fs
                .readFileSync(filePath, 'utf-8')
                // Strip the named AMD module for compatibility with non-bazel users
                .replace(/^\/\/\/ <amd-module name=.*\/>[\r\n]+/gm, '');
        }
    }
    if (require.main === module) {
        process.exitCode = main(process.argv.slice(2));
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFja2FnZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9iYXplbC9zcmMvbmdfcGFja2FnZS9wYWNrYWdlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7Ozs7Ozs7Ozs7OztJQUVILHlCQUF5QjtJQUN6Qiw2QkFBNkI7SUFDN0IsK0JBQStCO0lBRS9CLFNBQVMsSUFBSSxDQUFDLElBQWM7UUFDMUIsK0NBQStDO1FBQy9DLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFZCw2RkFBNkY7UUFDN0YsSUFBSSxlQUFlLEdBQUcsS0FBSyxDQUFDO1FBRTVCLDBGQUEwRjtRQUMxRiw2RkFBNkY7UUFDN0YsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRTlCLDZDQUE2QztRQUM3QyxTQUFTLGdCQUFnQixDQUFDLENBQVMsSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUU1RSxxREFBcUQ7UUFDckQsTUFBTSxNQUFNLEdBQUcsRUFBRSxDQUFDLFlBQVksQ0FBQyxhQUFhLEVBQUUsT0FBTyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1FBRXpGLE1BQU07UUFDRix3Q0FBd0M7UUFDeEMsR0FBRztRQUVILDhFQUE4RTtRQUM5RSxNQUFNO1FBRU4sOEVBQThFO1FBQzlFLDhEQUE4RDtRQUM5RCxNQUFNO1FBRU4sbUZBQW1GO1FBQ25GLFdBQVc7UUFFWCx1RUFBdUU7UUFDdkUsb0NBQW9DO1FBQ3BDLHNCQUFzQjtRQUN0QixrREFBa0Q7UUFDbEQsc0RBQXNEO1FBQ3RELCtEQUErRDtRQUMvRCxNQUFNO1FBQ04sTUFBTTtRQUNOLElBQUk7UUFDSixrQkFBa0I7UUFFbEIsbUNBQW1DO1FBQ25D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QUFPLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBaUIsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUM7YUFDdEY7WUFDRCxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUMsT0FBTyxDQUFDLGlCQUFpQixFQUFFLG1CQUFtQixDQUFDLENBQUM7UUFDbEYsQ0FBQztRQUVEOzs7V0FHRztRQUNILFNBQVMsNEJBQTRCLENBQUMsUUFBZ0I7WUFDcEQsT0FBTyxFQUFFO2lCQUNKLFlBQVksQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDO2dCQUNoQyxvRUFBb0U7aUJBQ25FLE9BQU8sQ0FBQyx5Q0FBeUMsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUM5RCxDQUFDO0lBQ0gsQ0FBQztJQUVELElBQUksT0FBTyxDQUFDLElBQUksS0FBSyxNQUFNLEVBQUU7UUFDM0IsT0FBTyxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNoRCIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCAqIGFzIHNoeCBmcm9tICdzaGVsbGpzJztcblxuZnVuY3Rpb24gbWFpbihhcmdzOiBzdHJpbmdbXSk6IG51bWJlciB7XG4gIC8vIEV4aXQgaW1tZWRpYXRlbHkgd2hlbiBlbmNvdW50ZXJpbmcgYW4gZXJyb3IuXG4gIHNoeC5zZXQoJy1lJyk7XG5cbiAgLy8gS2VlcCB0cmFjayBvZiB3aGV0aGVyIGFuIGVycm9yIGhhcyBvY2N1cmVkIHNvIHRoYXQgd2UgY2FuIHJldHVybiBhbiBhcHByb3ByaWF0ZSBleGl0IGNvZGUuXG4gIGxldCBlcnJvckhhc09jY3VyZWQgPSBmYWxzZTtcblxuICAvLyBUaGlzIHV0aWxpdHkgZXhwZWN0cyBhbGwgb2YgaXRzIGFyZ3VtZW50cyB0byBiZSBzcGVjaWZpZWQgaW4gYSBwYXJhbXMgZmlsZSBnZW5lcmF0ZWQgYnlcbiAgLy8gYmF6ZWwgKHNlZSBodHRwczovL2RvY3MuYmF6ZWwuYnVpbGQvdmVyc2lvbnMvbWFzdGVyL3NreWxhcmsvbGliL0FyZ3MuaHRtbCN1c2VfcGFyYW1fZmlsZSkuXG4gIGNvbnN0IHBhcmFtRmlsZVBhdGggPSBhcmdzWzBdO1xuXG4gIC8vIEJhemVsIHBhcmFtcyBtYXkgYmUgc3Vycm91bmRlZCB3aXRoIHF1b3Rlc1xuICBmdW5jdGlvbiB1bnF1b3RlUGFyYW1ldGVyKHM6IHN0cmluZykgeyByZXR1cm4gcy5yZXBsYWNlKC9eJyguKiknJC8sICckMScpOyB9XG5cbiAgLy8gUGFyYW1ldGVycyBhcmUgc3BlY2lmaWVkIGluIHRoZSBmaWxlIG9uZSBwZXIgbGluZS5cbiAgY29uc3QgcGFyYW1zID0gZnMucmVhZEZpbGVTeW5jKHBhcmFtRmlsZVBhdGgsICd1dGYtOCcpLnNwbGl0KCdcXG4nKS5tYXAodW5xdW90ZVBhcmFtZXRlcik7XG5cbiAgY29uc3QgW1xuICAgICAgLy8gT3V0cHV0IGRpcmVjdG9yeSBmb3IgdGhlIG5wbSBwYWNrYWdlLlxuICAgICAgb3V0LFxuXG4gICAgICAvLyBUaGUgcGFja2FnZSBzZWdtZW50IG9mIHRoZSBuZ19wYWNrYWdlIHJ1bGUncyBsYWJlbCAoZS5nLiAncGFja2FnZS9jb21tb24nKS5cbiAgICAgIHNyY0RpcixcblxuICAgICAgLy8gVGhlIGJhemVsLWJpbiBkaXIgam9pbmVkIHdpdGggdGhlIHNyY0RpciAoZS5nLiAnYmF6ZWwtYmluL3BhY2thZ2UuY29tbW9uJykuXG4gICAgICAvLyBUaGlzIGlzIHRoZSBpbnRlbmRlZCBvdXRwdXQgbG9jYXRpb24gZm9yIHBhY2thZ2UgYXJ0aWZhY3RzLlxuICAgICAgYmluRGlyLFxuXG4gICAgICAvLyBUaGUgYmF6ZWwtZ2VuZmlsZXMgZGlyIGpvaW5lZCB3aXRoIHRoZSBzcmNEaXIgKGUuZy4gJ2JhemVsLWJpbi9wYWNrYWdlLmNvbW1vbicpLlxuICAgICAgZ2VuZmlsZXNEaXIsXG5cbiAgICAgIC8vIEpTT04gZGF0YSBtYXBwaW5nIGVhY2ggZW50cnkgcG9pbnQgdG8gdGhlIGdlbmVyYXRlZCBidW5kbGUgaW5kZXggYW5kXG4gICAgICAvLyBmbGF0IG1vZHVsZSBtZXRhZGF0YSwgZm9yIGV4YW1wbGVcbiAgICAgIC8vIHtcIkBhbmd1bGFyL2NvcmVcIjoge1xuICAgICAgLy8gICAgIFwiaW5kZXhcIjogXCJiYXplbC1iaW4vcGFja2FnZXMvY29yZS9jb3JlLmpzXCIsXG4gICAgICAvLyAgICAgXCJ0eXBpbmdzXCI6IFwiYmF6ZWwtYmluL3BhY2thZ2VzL2NvcmUvY29yZS5kLnRzXCIsXG4gICAgICAvLyAgICAgXCJtZXRhZGF0YVwiOiBcImJhemVsLWJpbi9wYWNrYWdlcy9jb3JlL2NvcmUubWV0YWRhdGEuanNvblwiXG4gICAgICAvLyAgfSxcbiAgICAgIC8vIC4uLlxuICAgICAgLy8gfVxuICAgICAgbW9kdWxlc01hbmlmZXN0QXJnLFxuXG4gICAgICAvLyBQYXRoIHRvIHRoZSBwYWNrYWdlJ3MgUkVBRE1FLm1kLlxuICAgICAgcmVhZG1lTWQsXG5cbiAgICAgIC8vIExpc3Qgb2Ygcm9sbGVkLXVwIGZsYXQgRVMyMDE1IG1vZHVsZXNcbiAgICAgIGZlc20yMDE1QXJnLFxuXG4gICAgICAvLyBMaXN0IG9mIHJvbGxlZC11cCBmbGF0IEVTNSBtb2R1bGVzXG4gICAgICBmZXNtNUFyZyxcblxuICAgICAgLy8gTGlzdCBvZiBpbmRpdmlkdWFsIEVTMjAxNSBtb2R1bGVzXG4gICAgICBlc20yMDE1QXJnLFxuXG4gICAgICAvLyBMaXN0IG9mIGluZGl2aWR1YWwgRVM1IG1vZHVsZXNcbiAgICAgIGVzbTVBcmcsXG5cbiAgICAgIC8vIExpc3Qgb2YgYWxsIFVNRCBidW5kbGVzIGdlbmVyYXRlZCBieSByb2xsdXAuXG4gICAgICBidW5kbGVzQXJnLFxuXG4gICAgICAvLyBMaXN0IG9mIGFsbCBmaWxlcyBpbiB0aGUgbmdfcGFja2FnZSBydWxlJ3Mgc3Jjcy5cbiAgICAgIHNyY3NBcmcsXG5cbiAgICAgIC8vIExpc3Qgb2YgYWxsIHR5cGUgZGVmaW5pdGlvbnMgdGhhdCBuZWVkIHRvIHBhY2thZ2VkIGludG8gdGhlIG5nX3BhY2thZ2UuXG4gICAgICB0eXBlRGVmaW5pdGlvbnNBcmcsXG5cbiAgICAgIC8vIExpc3Qgb2YgYWxsIGZpbGVzIGluIHRoZSBuZ19wYWNrYWdlIHJ1bGUncyBkYXRhLlxuICAgICAgZGF0YUFyZyxcblxuICAgICAgLy8gUGF0aCB0byB0aGUgcGFja2FnZSdzIExJQ0VOU0UuXG4gICAgICBsaWNlbnNlRmlsZSxcblxuICAgICAgLy8gTGlzdCBvZiBhbGwgZHRzIGJ1bmRsZXMgZ2VuZXJhdGVkIGJ5IHRoZSBBUEkgZXh0cmFjdG9yLlxuICAgICAgZHRzQnVuZGxlQXJnLFxuXG4gICAgICAvLyBUaGUgZHRzIGJ1bmRsZSBmaWxlIHN1ZmZpeCBleGFtcGxlOiAnLmJ1bmRsZS5kLnRzJ1xuICAgICAgZHRzQnVuZGxlRmlsZVN1ZmZpeCxcbiAgXSA9IHBhcmFtcztcblxuICBjb25zdCBmZXNtMjAxNSA9IGZlc20yMDE1QXJnLnNwbGl0KCcsJykuZmlsdGVyKHMgPT4gISFzKTtcbiAgY29uc3QgZmVzbTUgPSBmZXNtNUFyZy5zcGxpdCgnLCcpLmZpbHRlcihzID0+ICEhcyk7XG4gIGNvbnN0IGVzbTIwMTUgPSBlc20yMDE1QXJnLnNwbGl0KCcsJykuZmlsdGVyKHMgPT4gISFzKTtcbiAgY29uc3QgZXNtNSA9IGVzbTVBcmcuc3BsaXQoJywnKS5maWx0ZXIocyA9PiAhIXMpO1xuICBjb25zdCBidW5kbGVzID0gYnVuZGxlc0FyZy5zcGxpdCgnLCcpLmZpbHRlcihzID0+ICEhcyk7XG4gIGNvbnN0IHR5cGVEZWZpbml0aW9ucyA9IHR5cGVEZWZpbml0aW9uc0FyZy5zcGxpdCgnLCcpLmZpbHRlcihzID0+ICEhcyk7XG4gIGNvbnN0IHNyY3MgPSBzcmNzQXJnLnNwbGl0KCcsJykuZmlsdGVyKHMgPT4gISFzKTtcbiAgY29uc3QgZGF0YUZpbGVzOiBzdHJpbmdbXSA9IGRhdGFBcmcuc3BsaXQoJywnKS5maWx0ZXIocyA9PiAhIXMpO1xuICBjb25zdCBtb2R1bGVzTWFuaWZlc3QgPSBKU09OLnBhcnNlKG1vZHVsZXNNYW5pZmVzdEFyZyk7XG4gIGNvbnN0IGR0c0J1bmRsZXM6IHN0cmluZ1tdID0gZHRzQnVuZGxlQXJnLnNwbGl0KCcsJykuZmlsdGVyKHMgPT4gISFzKTtcblxuICBpZiAocmVhZG1lTWQpIHtcbiAgICBjb3B5RmlsZShyZWFkbWVNZCwgb3V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZXMgYSBmaWxlIGludG8gdGhlIHBhY2thZ2UgYmFzZWQgb24gaXRzIGlucHV0IHBhdGgsIHJlbGF0aXZpemluZyB0byB0aGUgcGFja2FnZSBwYXRoLlxuICAgKiBAcGFyYW0gaW5wdXRQYXRoIFBhdGggdG8gdGhlIGZpbGUgaW4gdGhlIGlucHV0IHRyZWUuXG4gICAqIEBwYXJhbSBmaWxlQ29udGVudCBDb250ZW50IG9mIHRoZSBmaWxlLlxuICAgKi9cbiAgZnVuY3Rpb24gd3JpdGVGaWxlRnJvbUlucHV0UGF0aChpbnB1dFBhdGg6IHN0cmluZywgZmlsZUNvbnRlbnQ6IHN0cmluZykge1xuICAgIC8vIFdlIHdhbnQgdGhlIHJlbGF0aXZlIHBhdGggZnJvbSB0aGUgZ2l2ZW4gZmlsZSB0byBpdHMgYW5jZXN0b3IgXCJyb290XCIgZGlyZWN0b3J5LlxuICAgIC8vIFRoaXMgcm9vdCBkZXBlbmRzIG9uIHdoZXRoZXIgdGhlIGZpbGUgbGl2ZXMgaW4gdGhlIHNvdXJjZSB0cmVlIChzcmNEaXIpIGFzIGEgYmFzaWMgZmlsZVxuICAgIC8vIGlucHV0IHRvIG5nX3BhY2thZ2UsIHRoZSBiaW4gb3V0cHV0IHRyZWUgKGJpbkRpcikgYXMgdGhlIG91dHB1dCBvZiBhbm90aGVyIHJ1bGUsIG9yXG4gICAgLy8gdGhlIGdlbmZpbGVzIG91dHB1dCB0cmVlIChnZW5maWxlc0RpcikgYXMgdGhlIG91dHB1dCBvZiBhIGdlbnJ1bGUuXG4gICAgbGV0IHJvb3REaXI6IHN0cmluZztcbiAgICBpZiAoaW5wdXRQYXRoLmluY2x1ZGVzKGJpbkRpcikpIHtcbiAgICAgIHJvb3REaXIgPSBiaW5EaXI7XG4gICAgfSBlbHNlIGlmIChpbnB1dFBhdGguaW5jbHVkZXMoZ2VuZmlsZXNEaXIpKSB7XG4gICAgICByb290RGlyID0gZ2VuZmlsZXNEaXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvb3REaXIgPSBzcmNEaXI7XG4gICAgfVxuXG4gICAgY29uc3Qgb3V0cHV0UGF0aCA9IHBhdGguam9pbihvdXQsIHBhdGgucmVsYXRpdmUocm9vdERpciwgaW5wdXRQYXRoKSk7XG5cbiAgICAvLyBBbHdheXMgZW5zdXJlIHRoYXQgdGhlIHRhcmdldCBkaXJlY3RvcnkgZXhpc3RzLlxuICAgIHNoeC5ta2RpcignLXAnLCBwYXRoLmRpcm5hbWUob3V0cHV0UGF0aCkpO1xuICAgIGZzLndyaXRlRmlsZVN5bmMob3V0cHV0UGF0aCwgZmlsZUNvbnRlbnQsICd1dGYtOCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvcGllcyBhIGZpbGUgaW50byB0aGUgcGFja2FnZSBiYXNlZCBvbiBpdHMgaW5wdXQgcGF0aCwgcmVsYXRpdml6aW5nIHRvIHRoZSBwYWNrYWdlIHBhdGguXG4gICAqIEBwYXJhbSBpbnB1dFBhdGggYSBwYXRoIHJlbGF0aXZlIHRvIHRoZSBiaW5EaXIsIHR5cGljYWxseSBmcm9tIGEgZmlsZSBpbiB0aGUgZGVwc1tdXG4gICAqL1xuICBmdW5jdGlvbiBjb3B5RmlsZUZyb21JbnB1dFBhdGgoaW5wdXRQYXRoOiBzdHJpbmcpIHtcbiAgICB3cml0ZUZpbGVGcm9tSW5wdXRQYXRoKGlucHV0UGF0aCwgZnMucmVhZEZpbGVTeW5jKGlucHV0UGF0aCwgJ3V0Zi04JykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbGF0aXZpemUgdGhlIHBhdGggd2hlcmUgYSBmaWxlIGlzIHdyaXR0ZW4uXG4gICAqIEBwYXJhbSBmaWxlIGEgcGF0aCBjb250YWluaW5nIGEgcmUtcm9vdGVkIHNlZ21lbnQgbGlrZSAuZXNtNSBvciAuZXM2XG4gICAqIEBwYXJhbSBzdWZmaXggdGhlIHJlLXJvb3RlZCBkaXJlY3RvcnlcbiAgICogQHBhcmFtIG91dERpciBwYXRoIHdoZXJlIHdlIGNvcHkgdGhlIGZpbGUsIHJlbGF0aXZlIHRvIHRoZSBvdXRcbiAgICovXG4gIGZ1bmN0aW9uIHdyaXRlRXNtRmlsZShmaWxlOiBzdHJpbmcsIHN1ZmZpeDogc3RyaW5nLCBvdXREaXI6IHN0cmluZykge1xuICAgIC8vIE5vdGUgdGhhdCB0aGUgc3BlY2lmaWVkIGZpbGUgcGF0aCBpcyBhbHdheXMgdXNpbmcgdGhlIHBvc2l4IHBhdGggZGVsaW1pdGVyLlxuICAgIGNvbnN0IHJvb3QgPSBmaWxlLnN1YnN0cigwLCBmaWxlLmxhc3RJbmRleE9mKGAke3N1ZmZpeH0vYCkgKyBzdWZmaXgubGVuZ3RoICsgMSk7XG4gICAgY29uc3QgcmVsID0gcGF0aC5kaXJuYW1lKHBhdGgucmVsYXRpdmUocGF0aC5qb2luKHJvb3QsIHNyY0RpciksIGZpbGUpKTtcbiAgICBpZiAoIXJlbC5zdGFydHNXaXRoKCcuLicpKSB7XG4gICAgICBjb3B5RmlsZShmaWxlLCBwYXRoLmpvaW4ob3V0LCBvdXREaXIpLCByZWwpO1xuICAgIH1cbiAgfVxuXG4gIGVzbTIwMTUuZm9yRWFjaChmaWxlID0+IHdyaXRlRXNtRmlsZShmaWxlLCAnLmVzNicsICdlc20yMDE1JykpO1xuICBlc201LmZvckVhY2goZmlsZSA9PiB3cml0ZUVzbUZpbGUoZmlsZSwgJy5lc201JywgJ2VzbTUnKSk7XG5cbiAgYnVuZGxlcy5mb3JFYWNoKGJ1bmRsZSA9PiB7IGNvcHlGaWxlKGJ1bmRsZSwgb3V0LCAnYnVuZGxlcycpOyB9KTtcbiAgZmVzbTIwMTUuZm9yRWFjaChmaWxlID0+IHsgY29weUZpbGUoZmlsZSwgb3V0LCAnZmVzbTIwMTUnKTsgfSk7XG4gIGZlc201LmZvckVhY2goZmlsZSA9PiB7IGNvcHlGaWxlKGZpbGUsIG91dCwgJ2Zlc201Jyk7IH0pO1xuXG4gIC8vIENvcHkgYWxsIHR5cGUgZGVmaW5pdGlvbnMgaW50byB0aGUgcGFja2FnZS4gVGhpcyBpcyBuZWNlc3Nhcnkgc28gdGhhdCBkZXZlbG9wZXJzIGNhbiB1c2VcbiAgLy8gdGhlIHBhY2thZ2Ugd2l0aCB0eXBlIGRlZmluaXRpb25zLlxuICB0eXBlRGVmaW5pdGlvbnMuZm9yRWFjaChmID0+IHdyaXRlRmlsZUZyb21JbnB1dFBhdGgoZiwgcmVhZFR5cGluZ3NBbmRTdHJpcEFtZE1vZHVsZShmKSkpO1xuXG4gIC8vIENvcHkgYWxsIGBkYXRhYCBmaWxlcyBpbnRvIHRoZSBwYWNrYWdlLiBUaGVzZSBhcmUgZmlsZXMgdGhhdCBhcmVuJ3QgYnVpbHQgYnkgdGhlIG5nX3BhY2thZ2VcbiAgLy8gcnVsZSwgYnV0IGluc3RlYWQgYXJlIGp1c3Qgc3RyYWlnaHQgY29waWVkIGludG8gdGhlIHBhY2thZ2UsIGUuZy4gZ2xvYmFsIENTUyBhc3NldHMuXG4gIGRhdGFGaWxlcy5mb3JFYWNoKGYgPT4gY29weUZpbGVGcm9tSW5wdXRQYXRoKGYpKTtcblxuICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIGVudHJ5IHBvaW50IG1vZHVsZXNcbiAgLy8gV2UgZG8gdGhpcyBmaXJzdCBiZWNhdXNlIHdlIGFsc28gcmVjb3JkIG5ldyBwYXRocyBmb3IgdGhlIGVzbTUgYW5kIGVzbTIwMTUgY29waWVzXG4gIC8vIG9mIHRoZSBpbmRleCBKUyBmaWxlLCB3aGljaCB3ZSBuZWVkIHRvIGFtZW5kIHRoZSBwYWNrYWdlLmpzb24uXG4gIE9iamVjdC5rZXlzKG1vZHVsZXNNYW5pZmVzdCkuZm9yRWFjaChtb2R1bGVOYW1lID0+IHtcbiAgICBjb25zdCBtb2R1bGVGaWxlcyA9IG1vZHVsZXNNYW5pZmVzdFttb2R1bGVOYW1lXTtcbiAgICBjb25zdCByZWxhdGl2ZSA9IHBhdGgucmVsYXRpdmUoYmluRGlyLCBtb2R1bGVGaWxlc1snaW5kZXgnXSk7XG5cbiAgICBtb2R1bGVGaWxlc1snZXNtNV9pbmRleCddID0gcGF0aC5qb2luKGJpbkRpciwgJ2VzbTUnLCByZWxhdGl2ZSk7XG4gICAgbW9kdWxlRmlsZXNbJ2VzbTIwMTVfaW5kZXgnXSA9IHBhdGguam9pbihiaW5EaXIsICdlc20yMDE1JywgcmVsYXRpdmUpO1xuXG4gICAgY29uc3QgbWV0YWRhdGFGaWxlID0gbW9kdWxlRmlsZXNbJ21ldGFkYXRhJ107XG4gICAgY29uc3QgdHlwaW5nc091dEZpbGUgPSBtb2R1bGVGaWxlc1sndHlwaW5ncyddO1xuXG4gICAgLy8gV2Ugb25seSBzdXBwb3J0IGFsbCBtb2R1bGVzIHdpdGhpbiBhIHBhY2thZ2UgdG8gYmUgZHRzIGJ1bmRsZWRcbiAgICAvLyBpZTogaWYgQGFuZ3VsYXIvY29tbW9uL2h0dHAgaGFzIGZsYXQgZHRzLCBzbyBzaG91bGQgQGFuZ3VsYXIvY29tbW9uXG4gICAgaWYgKGR0c0J1bmRsZXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBtZXRhZGF0YUNvbnRlbnQgPSByZXdpcmVNZXRhZGF0YShtZXRhZGF0YUZpbGUsIHR5cGluZ3NPdXRGaWxlKTtcbiAgICAgIHdyaXRlRmlsZUZyb21JbnB1dFBhdGgobWV0YWRhdGFGaWxlLCBtZXRhZGF0YUNvbnRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb3B5RmlsZUZyb21JbnB1dFBhdGgobWV0YWRhdGFGaWxlKTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IGxpY2Vuc2VCYW5uZXIgPSBsaWNlbnNlRmlsZSA/IGZzLnJlYWRGaWxlU3luYyhsaWNlbnNlRmlsZSwgJ3V0Zi04JykgOiAnJztcblxuICBkdHNCdW5kbGVzLmZvckVhY2goYnVuZGxlRmlsZSA9PiB7XG4gICAgY29uc3QgY2xlYW5EaXN0UGF0aCA9IGJ1bmRsZUZpbGUucmVwbGFjZShkdHNCdW5kbGVGaWxlU3VmZml4LCAnLmQudHMnKTtcbiAgICAvLyBBUEkgZXh0cmFjdG9yIHdpbGwgbm90IGRlZHVwZSBsaWNlbnNlIGNvbW1lbnRzIGZyb20gdmFyaW91cyBmaWxlc1xuICAgIC8vIHRoaXMgd2lsbCByZW1vdmUgYWxsIHRoZSBsaWNlbnNlIGNvbW1lbnRzIGFuZCBhcHBlbmQgdGhlIGxpY2Vuc2UgYmFubmVyLlxuICAgIGNvbnN0IGNvbnRlbnQgPSBsaWNlbnNlQmFubmVyICsgJ1xcbicgK1xuICAgICAgICByZWFkVHlwaW5nc0FuZFN0cmlwQW1kTW9kdWxlKGJ1bmRsZUZpbGUpXG4gICAgICAgICAgICAucmVwbGFjZSgvKFxcL1xcKlxcKlxccytcXCpcXHNcXEBsaWNlbnNlKCgoPyFcXCpcXC8pLnxcXHMpKilcXCpcXC8pL2dtLCAnJyk7XG5cbiAgICB3cml0ZUZpbGVGcm9tSW5wdXRQYXRoKGNsZWFuRGlzdFBhdGgsIGNvbnRlbnQpO1xuICB9KTtcblxuICAvLyBSb290IHBhY2thZ2UgbmFtZSAoZS5nLiAnQGFuZ3VsYXIvY29tbW9uJyksIGNhcHR1cmVzIGFzIHdlIGl0ZXJhdGUgdGhyb3VnaCBzb3VyY2VzIGJlbG93LlxuICBsZXQgcm9vdFBhY2thZ2VOYW1lID0gJyc7XG4gIGNvbnN0IHBhY2thZ2VzV2l0aEV4aXN0aW5nUGFja2FnZUpzb24gPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICBmb3IgKGNvbnN0IHNyYyBvZiBzcmNzKSB7XG4gICAgaWYgKHNyYy5pbmNsdWRlcyhiaW5EaXIpIHx8IHNyYy5pbmNsdWRlcyhnZW5maWxlc0RpcikpIHtcbiAgICAgIGVycm9ySGFzT2NjdXJlZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdUaGUgXCJzcmNzXCIgZm9yIG5nX3BhY2thZ2Ugc2hvdWxkIG5vdCBpbmNsdWRlIG91dHB1dCBvZiBvdGhlciBydWxlcy4gRm91bmQ6XFxuJyArXG4gICAgICAgICAgYCAgJHtzcmN9YCk7XG4gICAgfVxuXG4gICAgbGV0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoc3JjLCAndXRmLTgnKTtcbiAgICAvLyBNb2RpZnkgcGFja2FnZS5qc29uIGZpbGVzIGFzIG5lY2Vzc2FyeSBmb3IgcHVibGlzaGluZ1xuICAgIGlmIChwYXRoLmJhc2VuYW1lKHNyYykgPT09ICdwYWNrYWdlLmpzb24nKSB7XG4gICAgICBjb25zdCBwYWNrYWdlSnNvbiA9IEpTT04ucGFyc2UoY29udGVudCk7XG4gICAgICBjb250ZW50ID0gYW1lbmRQYWNrYWdlSnNvbihzcmMsIHBhY2thZ2VKc29uKTtcblxuICAgICAgY29uc3QgcGFja2FnZU5hbWUgPSBwYWNrYWdlSnNvblsnbmFtZSddO1xuICAgICAgcGFja2FnZXNXaXRoRXhpc3RpbmdQYWNrYWdlSnNvbi5hZGQocGFja2FnZU5hbWUpO1xuXG4gICAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSByb290IHBhY2thZ2UgbmFtZSwgZS5nLiBcIkBhbmd1bGFyL2NvbW1vblwiLiBXZSBhc3N1bWUgdGhhdCB0aGVcbiAgICAgIC8vIHJvb3QgbmFtZSB3aWxsIGJlIHNob3J0ZXN0IGJlY2F1c2Ugc2Vjb25kYXJ5IGVudHJ5LXBvaW50cyB3aWxsIGFwcGVuZCB0byBpdFxuICAgICAgLy8gKGUuZy4gXCJAYW5ndWxhci9jb21tb24vaHR0cFwiKS5cbiAgICAgIGlmICghcm9vdFBhY2thZ2VOYW1lIHx8IHBhY2thZ2VOYW1lLmxlbmd0aCA8IHJvb3RQYWNrYWdlTmFtZS5sZW5ndGgpIHtcbiAgICAgICAgcm9vdFBhY2thZ2VOYW1lID0gcGFja2FnZUpzb25bJ25hbWUnXTtcbiAgICAgIH1cbiAgICB9XG4gICAgd3JpdGVGaWxlRnJvbUlucHV0UGF0aChzcmMsIGNvbnRlbnQpO1xuICB9XG5cbiAgLy8gR2VuZXJhdGUgZXh0cmEgZmlsZXMgZm9yIHNlY29uZGFyeSBlbnRyeS1wb2ludHMuXG4gIE9iamVjdC5rZXlzKG1vZHVsZXNNYW5pZmVzdCkuZm9yRWFjaChlbnRyeVBvaW50UGFja2FnZU5hbWUgPT4ge1xuICAgIGNvbnN0IGVudHJ5UG9pbnROYW1lID0gZW50cnlQb2ludFBhY2thZ2VOYW1lLnN1YnN0cihyb290UGFja2FnZU5hbWUubGVuZ3RoICsgMSk7XG4gICAgaWYgKCFlbnRyeVBvaW50TmFtZSkgcmV0dXJuO1xuXG4gICAgY3JlYXRlTWV0YWRhdGFSZWV4cG9ydEZpbGUoXG4gICAgICAgIGVudHJ5UG9pbnROYW1lLCBtb2R1bGVzTWFuaWZlc3RbZW50cnlQb2ludFBhY2thZ2VOYW1lXVsnbWV0YWRhdGEnXSwgZW50cnlQb2ludFBhY2thZ2VOYW1lKTtcbiAgICBjcmVhdGVUeXBpbmdzUmVleHBvcnRGaWxlKFxuICAgICAgICBlbnRyeVBvaW50TmFtZSwgbGljZW5zZUJhbm5lciwgbW9kdWxlc01hbmlmZXN0W2VudHJ5UG9pbnRQYWNrYWdlTmFtZV1bJ3R5cGluZ3MnXSk7XG5cbiAgICBpZiAoIXBhY2thZ2VzV2l0aEV4aXN0aW5nUGFja2FnZUpzb24uaGFzKGVudHJ5UG9pbnRQYWNrYWdlTmFtZSkpIHtcbiAgICAgIGNyZWF0ZUVudHJ5UG9pbnRQYWNrYWdlSnNvbihlbnRyeVBvaW50TmFtZSwgZW50cnlQb2ludFBhY2thZ2VOYW1lKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBlcnJvckhhc09jY3VyZWQgPyAxIDogMDtcblxuICAvKipcbiAgICogQ29udmVydCBhIGJpbkRpci1yZWxhdGl2ZSBwYXRoIHRvIHNyY0Rpci1yZWxhdGl2ZVxuICAgKiBAcGFyYW0gZnJvbSBwYXRoIHRvIGEgZmlsZSB1bmRlciB0aGUgc3JjRGlyLCBsaWtlIHBhY2thZ2VzL2NvcmUvdGVzdGluZy9wYWNrYWdlLmpzb25cbiAgICogQHBhcmFtIGZpbGUgcGF0aCB0byBhIGZpbGUgdW5kZXIgdGhlIGJpbkRpciwgbGlrZSBiYXplbC1iaW4vY29yZS90ZXN0aW5nL2dlbmVyYXRlZC5qc1xuICAgKi9cbiAgZnVuY3Rpb24gc3JjRGlyUmVsYXRpdmUoZnJvbTogc3RyaW5nLCBmaWxlOiBzdHJpbmcpIHtcbiAgICBjb25zdCByZXN1bHQgPSBub3JtYWxpemVTZXBhcmF0b3JzKFxuICAgICAgICBwYXRoLnJlbGF0aXZlKHBhdGguZGlybmFtZShmcm9tKSwgcGF0aC5qb2luKHNyY0RpciwgcGF0aC5yZWxhdGl2ZShiaW5EaXIsIGZpbGUpKSkpO1xuICAgIGlmIChyZXN1bHQuc3RhcnRzV2l0aCgnLi4nKSkgcmV0dXJuIHJlc3VsdDtcbiAgICByZXR1cm4gYC4vJHtyZXN1bHR9YDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvcHlGaWxlKGZpbGU6IHN0cmluZywgYmFzZURpcjogc3RyaW5nLCByZWxhdGl2ZSA9ICcuJykge1xuICAgIGNvbnN0IGRpciA9IHBhdGguam9pbihiYXNlRGlyLCByZWxhdGl2ZSk7XG4gICAgc2h4Lm1rZGlyKCctcCcsIGRpcik7XG4gICAgc2h4LmNwKGZpbGUsIGRpcik7XG4gICAgLy8gRG91YmxlLXVuZGVyc2NvcmUgaXMgdXNlZCB0byBlc2NhcGUgZm9yd2FyZCBzbGFzaCBpbiBGRVNNIGZpbGVuYW1lcy5cbiAgICAvLyBTZWUgbmdfcGFja2FnZS5iemw6XG4gICAgLy8gICBmZXNtX291dHB1dF9maWxlbmFtZSA9IGVudHJ5X3BvaW50LnJlcGxhY2UoXCIvXCIsIFwiX19cIilcbiAgICAvLyBXZSBuZWVkIHRvIHVuZXNjYXBlIHRoZXNlLlxuICAgIGlmIChmaWxlLmluZGV4T2YoJ19fJykgPj0gMCkge1xuICAgICAgY29uc3Qgb3V0cHV0UGF0aCA9IHBhdGguam9pbihkaXIsIC4uLnBhdGguYmFzZW5hbWUoZmlsZSkuc3BsaXQoJ19fJykpO1xuICAgICAgc2h4Lm1rZGlyKCctcCcsIHBhdGguZGlybmFtZShvdXRwdXRQYXRoKSk7XG4gICAgICBzaHgubXYocGF0aC5qb2luKGRpciwgcGF0aC5iYXNlbmFtZShmaWxlKSksIG91dHB1dFBhdGgpO1xuXG4gICAgICAvLyBpZiB3ZSBhcmUgcmVuYW1pbmcgdGhlIC5qcyBmaWxlLCB3ZSdsbCBhbHNvIG5lZWQgdG8gdXBkYXRlIHRoZSBzb3VyY2VNYXBwaW5nVVJMIGluIHRoZSBmaWxlXG4gICAgICBpZiAoZmlsZS5lbmRzV2l0aCgnLmpzJykpIHtcbiAgICAgICAgc2h4LmNobW9kKCcrdycsIG91dHB1dFBhdGgpO1xuICAgICAgICBzaHguc2VkKCctaScsIGAke3BhdGguYmFzZW5hbWUoZmlsZSl9Lm1hcGAsIGAke3BhdGguYmFzZW5hbWUob3V0cHV0UGF0aCl9Lm1hcGAsIG91dHB1dFBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIG9yIGVkaXRzIHByb3BlcnRpZXMgaW50byB0aGUgcGFja2FnZS5qc29uIGZpbGUocykgaW4gdGhlIHBhY2thZ2Ugc28gdGhhdFxuICAgKiB0aGV5IHBvaW50IHRvIGFsbCB0aGUgcmlnaHQgZ2VuZXJhdGVkIGFydGlmYWN0cy5cbiAgICpcbiAgICogQHBhcmFtIHBhY2thZ2VKc29uIFRoZSBwYXRoIHRvIHRoZSBwYWNrYWdlLmpzb24gZmlsZS5cbiAgICogQHBhcmFtIHBhcnNlZFBhY2thZ2UgUGFyc2VkIHBhY2thZ2UuanNvbiBjb250ZW50XG4gICAqL1xuICBmdW5jdGlvbiBhbWVuZFBhY2thZ2VKc29uKHBhY2thZ2VKc29uOiBzdHJpbmcsIHBhcnNlZFBhY2thZ2U6IHtba2V5OiBzdHJpbmddOiBzdHJpbmd9KSB7XG4gICAgY29uc3QgcGFja2FnZU5hbWUgPSBwYXJzZWRQYWNrYWdlWyduYW1lJ107XG4gICAgY29uc3QgbW9kdWxlRmlsZXMgPSBtb2R1bGVzTWFuaWZlc3RbcGFja2FnZU5hbWVdO1xuICAgIGlmICghbW9kdWxlRmlsZXMpIHtcbiAgICAgIC8vIElkZWFsbHkgd2Ugc2hvdWxkIHRocm93IGhlcmUsIGFzIHdlIGdvdCBhbiBlbnRyeSBwb2ludCB0aGF0IGRvZXNuJ3RcbiAgICAgIC8vIGhhdmUgZmxhdCBtb2R1bGUgbWV0YWRhdGEgLyBidW5kbGUgaW5kZXgsIHNvIGl0IG1heSBoYXZlIGJlZW4gYW5cbiAgICAgIC8vIG5nX21vZHVsZSB0aGF0J3MgbWlzc2luZyBhIG1vZHVsZV9uYW1lIGF0dHJpYnV0ZS5cbiAgICAgIC8vIEhvd2V2ZXIsIEBhbmd1bGFyL2NvbXBpbGVyIGNhbid0IGJlIGFuIG5nX21vZHVsZSwgYXMgaXQncyB0aGUgaW50ZXJuYWxzXG4gICAgICAvLyBvZiB0aGUgbmdjIGNvbXBpbGVyLCB5ZXQgd2Ugd2FudCB0byBidWlsZCBhbiBuZ19wYWNrYWdlIGZvciBpdC5cbiAgICAgIC8vIFNvIGlnbm9yZSBwYWNrYWdlLmpzb24gZmlsZXMgd2hlbiB3ZSBhcmUgbWlzc2luZyBkYXRhLlxuICAgICAgY29uc29sZS5lcnJvcignV0FSTklORzogbm8gbW9kdWxlIG1ldGFkYXRhIGZvciBwYWNrYWdlJywgcGFja2FnZU5hbWUpO1xuICAgICAgY29uc29sZS5lcnJvcignICAgTm90IHVwZGF0aW5nIHRoZSBwYWNrYWdlLmpzb24gZmlsZSB0byBwb2ludCB0byBpdCcpO1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAnICAgVGhlIG5nX21vZHVsZSBmb3IgdGhpcyBwYWNrYWdlIGlzIHBvc3NpYmx5IG1pc3NpbmcgdGhlIG1vZHVsZV9uYW1lIGF0dHJpYnV0ZSAnKTtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXJzZWRQYWNrYWdlLCBudWxsLCAyKTtcbiAgICB9XG5cbiAgICAvLyBEZXJpdmUgdGhlIHBhdGhzIHRvIHRoZSBmaWxlcyBmcm9tIHRoZSBoYXJkLWNvZGVkIG5hbWVzIHdlIGdhdmUgdGhlbS5cbiAgICAvLyBUT0RPKGFsZXhlYWdsZSk6IGl0IHdvdWxkIGJlIGJldHRlciB0byB0cmFuc2ZlciB0aGlzIGluZm9ybWF0aW9uIGZyb20gdGhlIHBsYWNlXG4gICAgLy8gd2hlcmUgd2UgY3JlYXRlZCB0aGUgZmlsZW5hbWVzLCB2aWEgdGhlIG1vZHVsZXNNYW5pZmVzdEFyZ1xuICAgIHBhcnNlZFBhY2thZ2VbJ21haW4nXSA9IGdldEJ1bmRsZU5hbWUocGFja2FnZU5hbWUsICdidW5kbGVzJyk7XG4gICAgcGFyc2VkUGFja2FnZVsnZmVzbTUnXSA9IGdldEJ1bmRsZU5hbWUocGFja2FnZU5hbWUsICdmZXNtNScpO1xuICAgIHBhcnNlZFBhY2thZ2VbJ2Zlc20yMDE1J10gPSBnZXRCdW5kbGVOYW1lKHBhY2thZ2VOYW1lLCAnZmVzbTIwMTUnKTtcblxuICAgIHBhcnNlZFBhY2thZ2VbJ2VzbTUnXSA9IHNyY0RpclJlbGF0aXZlKHBhY2thZ2VKc29uLCBtb2R1bGVGaWxlc1snZXNtNV9pbmRleCddKTtcbiAgICBwYXJzZWRQYWNrYWdlWydlc20yMDE1J10gPSBzcmNEaXJSZWxhdGl2ZShwYWNrYWdlSnNvbiwgbW9kdWxlRmlsZXNbJ2VzbTIwMTVfaW5kZXgnXSk7XG4gICAgcGFyc2VkUGFja2FnZVsndHlwaW5ncyddID0gc3JjRGlyUmVsYXRpdmUocGFja2FnZUpzb24sIG1vZHVsZUZpbGVzWyd0eXBpbmdzJ10pO1xuXG4gICAgLy8gRm9yIG5vdywgd2UgcG9pbnQgdGhlIHByaW1hcnkgZW50cnkgcG9pbnRzIGF0IHRoZSBmZXNtIGZpbGVzLCBiZWNhdXNlIG9mIFdlYnBhY2tcbiAgICAvLyBwZXJmb3JtYW5jZSBpc3N1ZXMgd2l0aCBhIGxhcmdlIG51bWJlciBvZiBpbmRpdmlkdWFsIGZpbGVzLlxuICAgIC8vIFRPRE8oaW1pbmFyKTogcmVzb2x2ZSBwZXJmb3JtYW5jZSBpc3N1ZXMgd2l0aCB0aGUgdG9vbGNoYWluIGFuZCBwb2ludCB0aGVzZSB0byBlc21cbiAgICBwYXJzZWRQYWNrYWdlWydtb2R1bGUnXSA9IHBhcnNlZFBhY2thZ2VbJ2Zlc201J107XG4gICAgcGFyc2VkUGFja2FnZVsnZXMyMDE1J10gPSBwYXJzZWRQYWNrYWdlWydmZXNtMjAxNSddO1xuXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBhcnNlZFBhY2thZ2UsIG51bGwsIDIpO1xuICB9XG5cbiAgLy8gZS5nLiBAYW5ndWxhci9jb21tb24vaHR0cC90ZXN0aW5nIC0+IC4uLy4uL2J1bmRsZXMvY29tbW9uLWh0dHAtdGVzdGluZy51bWQuanNcbiAgLy8gb3IgICBAYW5ndWxhci9jb21tb24vaHR0cC90ZXN0aW5nIC0+IC4uLy4uL2Zlc201L2h0dHAvdGVzdGluZy5qc1xuICBmdW5jdGlvbiBnZXRCdW5kbGVOYW1lKHBhY2thZ2VOYW1lOiBzdHJpbmcsIGRpcjogc3RyaW5nKSB7XG4gICAgY29uc3QgcGFydHMgPSBwYWNrYWdlTmFtZS5zcGxpdCgnLycpO1xuICAgIC8vIFJlbW92ZSB0aGUgc2NvcGVkIHBhY2thZ2UgcGFydCwgbGlrZSBAYW5ndWxhciBpZiBwcmVzZW50XG4gICAgY29uc3QgbmFtZVBhcnRzID0gcGFja2FnZU5hbWUuc3RhcnRzV2l0aCgnQCcpID8gcGFydHMuc3BsaWNlKDEpIDogcGFydHM7XG4gICAgY29uc3QgcmVsYXRpdmVQYXRoID0gQXJyYXkobmFtZVBhcnRzLmxlbmd0aCAtIDEpLmZpbGwoJy4uJykuam9pbignLycpIHx8ICcuJztcbiAgICBsZXQgYmFzZW5hbWU6IHN0cmluZztcbiAgICBpZiAoZGlyID09PSAnYnVuZGxlcycpIHtcbiAgICAgIGJhc2VuYW1lID0gbmFtZVBhcnRzLmpvaW4oJy0nKSArICcudW1kJztcbiAgICB9IGVsc2UgaWYgKG5hbWVQYXJ0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGJhc2VuYW1lID0gbmFtZVBhcnRzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlbmFtZSA9IG5hbWVQYXJ0cy5zbGljZSgxKS5qb2luKCcvJyk7XG4gICAgfVxuICAgIHJldHVybiBbcmVsYXRpdmVQYXRoLCBkaXIsIGJhc2VuYW1lICsgJy5qcyddLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8qKiBDcmVhdGVzIG1ldGFkYXRhIHJlLWV4cG9ydCBmaWxlIGZvciBhIHNlY29uZGFyeSBlbnRyeS1wb2ludC4gKi9cbiAgZnVuY3Rpb24gY3JlYXRlTWV0YWRhdGFSZWV4cG9ydEZpbGUoXG4gICAgICBlbnRyeVBvaW50TmFtZTogc3RyaW5nLCBtZXRhZGF0YUZpbGU6IHN0cmluZywgcGFja2FnZU5hbWU6IHN0cmluZykge1xuICAgIGNvbnN0IGlucHV0UGF0aCA9IHBhdGguam9pbihzcmNEaXIsIGAke2VudHJ5UG9pbnROYW1lfS5tZXRhZGF0YS5qc29uYCk7XG4gICAgd3JpdGVGaWxlRnJvbUlucHV0UGF0aChpbnB1dFBhdGgsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICdfX3N5bWJvbGljJzogJ21vZHVsZScsXG4gICAgICAndmVyc2lvbic6IDMsXG4gICAgICAnbWV0YWRhdGEnOiB7fSxcbiAgICAgICdleHBvcnRzJzpcbiAgICAgICAgICBbeydmcm9tJzogYCR7c3JjRGlyUmVsYXRpdmUoaW5wdXRQYXRoLCBtZXRhZGF0YUZpbGUucmVwbGFjZSgvLm1ldGFkYXRhLmpzb24kLywgJycpKX1gfV0sXG4gICAgICAnZmxhdE1vZHVsZUluZGV4UmVkaXJlY3QnOiB0cnVlLFxuICAgICAgJ2ltcG9ydEFzJzogcGFja2FnZU5hbWVcbiAgICB9KSArICdcXG4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdHlwaW5ncyAoZC50cykgcmUtZXhwb3J0IGZpbGUgZm9yIGEgc2Vjb25kYXJ5LWVudHJ5IHBvaW50LFxuICAgKiBlLmcuLCBgZXhwb3J0ICogZnJvbSAnLi9jb21tb24vY29tbW9uJ2BcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZVR5cGluZ3NSZWV4cG9ydEZpbGUoZW50cnlQb2ludE5hbWU6IHN0cmluZywgbGljZW5zZTogc3RyaW5nLCB0eXBpbmdzRmlsZTogc3RyaW5nKSB7XG4gICAgY29uc3QgaW5wdXRQYXRoID0gcGF0aC5qb2luKHNyY0RpciwgYCR7ZW50cnlQb2ludE5hbWV9LmQudHNgKTtcbiAgICBjb25zdCBjb250ZW50ID0gYCR7bGljZW5zZX1cbmV4cG9ydCAqIGZyb20gJyR7c3JjRGlyUmVsYXRpdmUoaW5wdXRQYXRoLCB0eXBpbmdzRmlsZS5yZXBsYWNlKC9cXC5kXFwudHN4PyQvLCAnJykpfSc7XG5gO1xuICAgIHdyaXRlRmlsZUZyb21JbnB1dFBhdGgoaW5wdXRQYXRoLCBjb250ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcGFja2FnZS5qc29uIGZvciBhIHNlY29uZGFyeSBlbnRyeS1wb2ludC5cbiAgICogQHBhcmFtIGRpciBUaGUgZGlyZWN0b3J5IHVuZGVyIHdoaWNoIHRoZSBwYWNrYWdlLmpzb24gc2hvdWxkIGJlIHdyaXR0ZW4uXG4gICAqIEBwYXJhbSBlbnRyeVBvaW50UGFja2FnZU5hbWUgVGhlIGZ1bGwgcGFja2FnZSBuYW1lIGZvciB0aGUgZW50cnkgcG9pbnQsXG4gICAqICAgICBlLmcuICdAYW5ndWxhci9jb21tb24vaHR0cCcuXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVFbnRyeVBvaW50UGFja2FnZUpzb24oZGlyOiBzdHJpbmcsIGVudHJ5UG9pbnRQYWNrYWdlTmFtZTogc3RyaW5nKSB7XG4gICAgY29uc3QgcGtnSnNvbiA9IHBhdGguam9pbihzcmNEaXIsIGRpciwgJ3BhY2thZ2UuanNvbicpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBhbWVuZFBhY2thZ2VKc29uKHBrZ0pzb24sIHtuYW1lOiBlbnRyeVBvaW50UGFja2FnZU5hbWV9KTtcbiAgICB3cml0ZUZpbGVGcm9tSW5wdXRQYXRoKHBrZ0pzb24sIGNvbnRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZXMgdGhlIHNwZWNpZmllZCBwYXRoIGJ5IHJlcGxhY2luZyBiYWNrc2xhc2ggc2VwYXJhdG9ycyB3aXRoIFBvc2l4XG4gICAqIGZvcndhcmQgc2xhc2ggc2VwYXJhdG9ycy5cbiAgICovXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVNlcGFyYXRvcnMocGF0aDogc3RyaW5nKTogc3RyaW5nIHsgcmV0dXJuIHBhdGgucmVwbGFjZSgvXFxcXC9nLCAnLycpOyB9XG5cbiAgLyoqXG4gICogUmV3aXJlcyBtZXRhZGF0YSB0byBwb2ludCB0byB0aGUgZmxhdHRlbmVkIGR0cyBmaWxlLlxuICAqXG4gICogQHBhcmFtIG1ldGFkYXRhUGF0aCB0aGUgbWV0YWRhdGEgZmlsZSBwYXRoXG4gICogQHBhcmFtIHR5cGluZ3NQYXRoIHRoZSB0eXBpbmdzIGJ1bmRsZSBlbnRyeXBvaW50XG4gICovXG4gIGZ1bmN0aW9uIHJld2lyZU1ldGFkYXRhKG1ldGFkYXRhUGF0aDogc3RyaW5nLCB0eXBpbmdzUGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKG1ldGFkYXRhUGF0aCwgJ3V0Zi04JykpO1xuXG4gICAgbGV0IHR5cGluZ3NSZWxhdGl2ZVBhdGggPVxuICAgICAgICBub3JtYWxpemVTZXBhcmF0b3JzKHBhdGgucmVsYXRpdmUocGF0aC5kaXJuYW1lKG1ldGFkYXRhUGF0aCksIHR5cGluZ3NQYXRoKSk7XG4gICAgaWYgKCF0eXBpbmdzUmVsYXRpdmVQYXRoLnN0YXJ0c1dpdGgoJy4uJykpIHtcbiAgICAgIHR5cGluZ3NSZWxhdGl2ZVBhdGggPSBgLi8ke3R5cGluZ3NSZWxhdGl2ZVBhdGh9YDtcbiAgICB9XG5cbiAgICB0eXBpbmdzUmVsYXRpdmVQYXRoID0gdHlwaW5nc1JlbGF0aXZlUGF0aC5yZXBsYWNlKCcuZC50cycsICcnKTtcblxuICAgIC8vIHRoZSByZWdleHAgaGVyZSBjYXRjaGVzIGFsbCByZWxhdGl2ZSBwYXRocyBzdWNoIGFzOlxuICAgIC8vIC4vc3JjL2NvcmUvZm9vLmQudHMgYW5kIC4uL3NyYy9jb3JlL2Zvby5kLnRzXG4gICAgY29uc3QgcmVsYXRpdmVQYXRoUmVnZXggPSAvXFwuP1xcLlxcL1tcXHdcXC5cXC1fXFwvXSsvZztcbiAgICBpZiAobWV0YWRhdGEuZXhwb3J0cykge1xuICAgICAgLy8gU3RyaXAgcmUtZXhwb3J0cyB3aGljaCBhcmUgbm93IHNlbGYtcmVmZXJlbmNlc1xuICAgICAgbWV0YWRhdGEuZXhwb3J0cyA9XG4gICAgICAgICAgbWV0YWRhdGEuZXhwb3J0cy5maWx0ZXIoKGU6IHtmcm9tOiBzdHJpbmd9KSA9PiAhZS5mcm9tLm1hdGNoKHJlbGF0aXZlUGF0aFJlZ2V4KSk7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkucmVwbGFjZShyZWxhdGl2ZVBhdGhSZWdleCwgdHlwaW5nc1JlbGF0aXZlUGF0aCk7XG4gIH1cblxuICAvKipcbiAgICogU3RyaXAgdGhlIG5hbWVkIEFNRCBtb2R1bGUgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24tYmF6ZWwgdXNlcnMgZnJvbSB0eXBpbmdzIGNvbnRlbnRcbiAgICogQHBhcmFtIGZpbGVQYXRoIGR0cyBmaWxlIHBhdGhcbiAgICovXG4gIGZ1bmN0aW9uIHJlYWRUeXBpbmdzQW5kU3RyaXBBbWRNb2R1bGUoZmlsZVBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGZzXG4gICAgICAgIC5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsICd1dGYtOCcpXG4gICAgICAgIC8vIFN0cmlwIHRoZSBuYW1lZCBBTUQgbW9kdWxlIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWJhemVsIHVzZXJzXG4gICAgICAgIC5yZXBsYWNlKC9eXFwvXFwvXFwvIDxhbWQtbW9kdWxlIG5hbWU9LipcXC8+W1xcclxcbl0rL2dtLCAnJyk7XG4gIH1cbn1cblxuaWYgKHJlcXVpcmUubWFpbiA9PT0gbW9kdWxlKSB7XG4gIHByb2Nlc3MuZXhpdENvZGUgPSBtYWluKHByb2Nlc3MuYXJndi5zbGljZSgyKSk7XG59XG4iXX0=